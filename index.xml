<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>mLAB</title>
    <link>https://mukai-lab.info/</link>
    <description>Recent content on mLAB</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>ja</language>
    <lastBuildDate>Tue, 01 Nov 2022 19:05:46 +0900</lastBuildDate>
    
	<atom:link href="https://mukai-lab.info/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>線形計画法②・最短経路問題</title>
      <link>https://mukai-lab.info/pages/classes/management_data_analysis/chapter9/</link>
      <pubDate>Tue, 01 Nov 2022 19:05:46 +0900</pubDate>
      
      <guid>https://mukai-lab.info/pages/classes/management_data_analysis/chapter9/</guid>
      <description>最短経路問題  重み付き有向グラフの2点間を結ぶ最短経路を導出する 最短経路問題 に挑戦しましょう． 最短経路問題も，最適生産計画と同様に，線形計画問題の一つとして扱うことが可能です．
例題   AからFまでの6つの都市（ノード）がある． Aを始点，Fを終点としたとき，2都市間を結ぶ最短の経路を求めよ． このとき，都市間の移動はエッジの向きに限定される． また，都市間の距離（コスト）は，エッジの重みとして与えられる．  
まずは，解となり得る経路を列挙してみましょう． 経路の距離を比較してみると，$A \rightarrow B \rightarrow D \rightarrow F$が最短であることが分かります．
$$ A \rightarrow B \rightarrow D \rightarrow F （距離: 13） $$
$$ A \rightarrow C \rightarrow E \rightarrow F （距離: 17） $$
$$ A \rightarrow D \rightarrow F （距離: 14） $$
$$ A \rightarrow E \rightarrow F （距離: 19） $$
問題を定式化するために，変数$x_{ij}$を導入します． ノード$i$からノード$j$の経路を含むときは$x_{ij}=1$，経路を含まないときは$x_{ij}=0$とします． この$x_{ij}$を用いて，目的関数は次のように定義することができます． ここで，$w_{ij}$は，ノード$i$からノード$j$までの距離，$E$はエッジの集合を表します．
$$ 経路長 = \sum_{i,j \in E} w_{ij} \cdot x_{ij} $$</description>
    </item>
    
    <item>
      <title>線形計画法①・最適生産計画</title>
      <link>https://mukai-lab.info/pages/classes/management_data_analysis/chapter8/</link>
      <pubDate>Tue, 01 Nov 2022 14:46:09 +0900</pubDate>
      
      <guid>https://mukai-lab.info/pages/classes/management_data_analysis/chapter8/</guid>
      <description>線形計画法と最適生産計画  線形計画法（Linear Programming: LP） とは， 対象の問題の制約や目的が1次式で表される線形計画問題において， 制約を満たしながら，目的を達成する計画（変数）を導出するための手法です． また， 最適生産計画 は，利益を最大化するために， 製品の生産に要する原材料や部品などのコストや在庫数を最適化する問題のことであり， ここでは線形計画問題の一つとして扱います．
最初に次の例題を考えます．
例題   A社では2種類の製品A,Bを生産しています． 製品Aを1kg作るには原料1が5kg，原料2が3kg，原料3が2kg必要です． 製品Bを1kg作るには原料1が3kg，原料2が4kg，原料3が1kg必要です． 倉庫には原料1が100kg，原料2が80kg，原料3が90kgあります． 製品Aの利益は1kg当たり10万円，製品Bの利益は1kg当たり8万円であるとき， 最大の利益を得るには，製品A，Bをどれだけ生産すれば良いでしょうか．     製品(kg) 原料1(kg) 原料2(kg) 原料3(kg) 利益(万円)     A 5 3 2 10   B 3 4 3 8    この問題を定式化するために， 目的関数 と 制約条件 を定義します． 製品Aの生産数を$x$，製品Bの生産数を$y$とすると，目的関数を表す利益は次のように定義できます．
$$ 利益 = 10x + 8y $$
原料1，原料2，原料3の制約条件を定義します． 原料が倉庫にある在庫を超えないことが条件となります．
$$ 原料1の制約条件: 5x + 3y \leq 100 $$</description>
    </item>
    
    <item>
      <title>統計的仮説検定③・ANOVA</title>
      <link>https://mukai-lab.info/pages/classes/management_data_analysis/chapter7/</link>
      <pubDate>Thu, 27 Oct 2022 18:22:55 +0900</pubDate>
      
      <guid>https://mukai-lab.info/pages/classes/management_data_analysis/chapter7/</guid>
      <description>3群の平均値差の検定  これまでに学習したt検定は，2群の平均値差の検定には有効ですが，3群以上の平均値差の検定に用いることができません． まずはこの理由から考えてみましょう．
検定の多重性 例えば，3つの小学校の50メートル走のタイムを考えます． このとき，t検定を利用して，3つの小学校のタイムの平均値差を検定することを考えます． 帰無仮説は$\mu_A = \mu_B = \mu_C$であり，有意水準は$\alpha=0.05$（5%）とします．
   A小学校 B小学校 C小学校     12.4 11.5 10.9   11.8 12.3 10.6   10.3 13.2 11.1   12.0 10.8 9.9   13.2 11.3 10.2    t検定は2群の平均値差の検定のため，次の組み合わせで3回のt検定を適用しなくてはいけません．
 A小学校とB小学校（帰無仮説: $\mu_A = \mu_B$） B小学校とC小学校（帰無仮説: $\mu_B = \mu_C$） C小学校とA小学校（帰無仮説: $\mu_C = \mu_A$）  この場合，検定の多重性 という問題が生じます． この3つに分けた検定のうち，少なくとも1つが有意差有り（$p値 &amp;lt; \alpha$）となる確率は次のように求めることができます（1から「全てが有意差なしの確率」を引く）．
$$ 1 - (1 - \alpha)^3 = 1 - 0.</description>
    </item>
    
    <item>
      <title>統計的仮説検定②・t検定（平均値差の検定）</title>
      <link>https://mukai-lab.info/pages/classes/management_data_analysis/chapter6/</link>
      <pubDate>Tue, 04 Oct 2022 16:17:11 +0900</pubDate>
      
      <guid>https://mukai-lab.info/pages/classes/management_data_analysis/chapter6/</guid>
      <description>平均値差の検定  前回，母集団とその標本との関係性から仮説を検証するためのt検定を学びました． この他にも，t検定は2つの標本間の関係性から仮説を検証することが可能です（正確には母集団を介して2つの標本の関係性を検証する）．

対応のない（独立な）2郡のt検定 例えば，ある学校の生徒の50メートル走のタイムを考えます． クラス1からはA,B,C,D,Eの5人，クラス2からはF,G,H,I,Jの5人を抽出し，この2つの標本のタイムの平均が等しいかどうかを検定することができます． これは，対応のない（独立な）2郡のt検定 と呼ばれます．
   生徒 タイム     A 12.4   B 11.8   C 10.3   D 12.0   E 13.2       生徒 タイム     F 13.1   G 10.9   H 12.5   I 11.3   J 12.8    この検定では，クラス1の標本とクラス2の標本が異なる母集団から無作為抽出されたと考え，標本平均$\bar{X}_1$と$\bar{X}_2$の差が次の正規分布に従うことを利用します．</description>
    </item>
    
    <item>
      <title>統計的仮説検定①・t検定</title>
      <link>https://mukai-lab.info/pages/classes/management_data_analysis/chapter5/</link>
      <pubDate>Sun, 02 Oct 2022 15:28:41 +0900</pubDate>
      
      <guid>https://mukai-lab.info/pages/classes/management_data_analysis/chapter5/</guid>
      <description>t検定  統計的仮説検定 とは，母集団から抽出した標本を利用して，母集団に関する仮説を検証する方法です． 例えば「母集団の平均（母平均）は $\mu$である」などの仮説が考えられます． この仮説を検証するために z検定 や t検定 などと呼ばれる方法が用いられます．

まずは，z検定 について考えていきましょう． z検定は平均$\mu=0$，分散$\sigma^2=1$の正規分布（標準正規分布）を用いる手法です． 平均$\mu$，分散$\sigma^2$の正規分布に従う母集団の分布$X$から， 無作為に抽出した 標本の平均（標本平均） の分布も，正規分布に従うことが知られています． このとき，サンプルサイズ$n$の標本平均$\bar{X}$は，平均$\mu$，分散$\frac{\sigma^2}{n}$の正規分布になります（分散はサンプルサイズに合わせて小さくなることに注意）．
$$ \bar{X} \sim N\left( \mu, \frac{\sigma^2}{n} \right) $$

これを標準化すると平均0，分散1の標準正規分布に従うことになり，これを検定統計量$Z$とします． この検定統計量$z$から，その標本が母集団から無作為抽出された標本かどうかを判断することができます．
$$ Z = \frac{\bar{X} - \mu}{\sqrt{\sigma^2 / n}} = \frac{\bar{X} - \mu}{\sigma / \sqrt{n}} \sim N\left( 0, 1 \right) $$

次は，t検定 について考えていきましょう． t検定は母集団の分散$\sigma^2$が分からないときに採用する手法であり，標準正規分布ではなく 自由度を特徴とするt分布 を用います． 一般に母集団の分散は不明であるため z検定 を採用することは稀で，常に t検定 を用いれば良いとされます． 平均$\mu$の正規分布に従う母集団の分布$X$から，無作為に抽出した 標本の平均（標本平均） の分布を考えます． 母集団の分散$\sigma^2$は不明であることから，標本から算出した不偏分散$\hat{\sigma}^2$を代わりに使用します（標本平均の分布の分散ではないことに注意）． このとき，サンプルサイズ$n$の標本平均$\bar{X}$は，平均$\mu$，分散$\frac{\hat{\sigma}^2}{n}$の正規分布に従います．
$$ \bar{X} \sim N\left( \mu, \frac{\hat{\sigma}^2}{n} \right) $$</description>
    </item>
    
    <item>
      <title>Pythonを利用した統計処理③・正規分布</title>
      <link>https://mukai-lab.info/pages/classes/management_data_analysis/chapter4/</link>
      <pubDate>Sat, 10 Sep 2022 12:42:52 +0900</pubDate>
      
      <guid>https://mukai-lab.info/pages/classes/management_data_analysis/chapter4/</guid>
      <description>正規分布  正規分布（ガウス分布） は，前回の 2項分布 と同じ確率分布の一つです． 正規分布は平均に近い値が高い確率で発生し，平均から遠い値が生じる確率は低いという特徴があります． 自然現象や社会現象において，正規分布は多数存在すると言われており，動物の身長・体重，降雨量・雨粒の大きさなどは，正規分布に従っていると考えることができます．
正規分布と2項分布との大きな違いは，2項分布は 離散確率分布 であるのに対し，正規分布は 連続確率分布 であるということです． 離散確率分布では，試行の繰り返しの結果，生じる値は離散値となります． 例えば，コインを10回投げるという試行の結果は，$x=0$から$x=10$までの11通りの値しか存在しません． このため11通りの生起確率を全て合計すると$1$（100%）になります．
$$ \sum_{x=0}^{10} P(x) = P(0) + P(1) + \cdots + P(10) = 1 $$

一方，連続確率分布 では，生じる値は連続値となります． 例えば，人間の身長は様々であり，何通りと定めることはできません． このため，連続確率分布では，ある値$x$に対して 確率密度 $f(x)$を定義し， その確率密度の積分で生起確率を表すことになります． 例えば，$a \leq x \leq b$である確率$P(a \leq x \leq b)$は次のように表せます．
$$ P(a \leq x \leq b) = \int_{a}^{b}f(x)dx $$

また，全ての事象の確率密度を積分すると$1$(100%)になります．
$$ P(-\infty \leq x \leq \infty)=\int_{-\infty}^{\infty}f(x)dx = 1 $$
正規分布の確率密度$f(x)$は次の式で求めることができます． ここで，式中の$\mu$は平均，$\sigma^2$は分散です（$\sigma$は標準偏差）．
$$ f(x) = \frac{1}{\sqrt{2 \pi \sigma^2}} exp \left( -\frac{(x - \mu)^2}{2 \sigma^2}\right) $$</description>
    </item>
    
    <item>
      <title>Pythonを利用した統計処理②・2項分布</title>
      <link>https://mukai-lab.info/pages/classes/management_data_analysis/chapter3/</link>
      <pubDate>Fri, 09 Sep 2022 21:17:39 +0900</pubDate>
      
      <guid>https://mukai-lab.info/pages/classes/management_data_analysis/chapter3/</guid>
      <description>2項分布  2項分布 は，コインの表と裏のように結果が2通りとなる試行を， $n$回繰り返したときに，表が出る回数の 確率分布 を表しています． 例えば，コインを投げたときに表が出る確率を$p=1/2$とします． このとき裏が出る確率は$(1-p)=1/2$です．
試行回数$n=1$のときの確率分布は次のようになります． 1回の試行では，表が出る回数は$0$または$1$の2通りです．
   表が出る回数 確率     0 1/2   1 1/2    試行回数$n=2$のときの確率分布は次のようになります． 2回の試行では，表が出る回数は$0$，$1$，$2$の3通りです．
   表が出る回数 確率     0 1/4   1 1/2   2 1/4    表が出る回数を$x$としたとき，その確率$P(x)$は次の式で求めることができます．
$$ P(x) = {}_nC_x p^x (1-p)^{n-x} $$
例えば，上記の試行回数$n=2$において，表が出る回数$x$の確率は次のように計算します．
$$ P(0) = {}_2C_0 \cdot (1/2)^0 \cdot (1-(1/2))^{2-0} = 1/4 $$</description>
    </item>
    
    <item>
      <title>Pythonを利用した統計処理①・相関係数</title>
      <link>https://mukai-lab.info/pages/classes/management_data_analysis/chapter2/</link>
      <pubDate>Thu, 08 Sep 2022 18:10:18 +0900</pubDate>
      
      <guid>https://mukai-lab.info/pages/classes/management_data_analysis/chapter2/</guid>
      <description>相関係数  相関係数とは2つの変数XとYのの関係性を表す指標です． 例として，X=気温とY=アイスクリームの売上数を考えてみましょう． 気温が高い夏にアイスクリームの売上数は増加し， 逆に気温が低い冬にアイスクリームの売上数は減少すると考えられます． このような関係を 正の相関 と呼びます． 同様に，X=気温とY=おでんの売上数を考えてみましょう． 気温が高い夏におでんの売上数は減少し， 逆に気温が低い冬におでんの売上数は減少すると考えられます． このような関係を 負の相関 と呼びます． この関係性を定量的に表す方法が 相関係数 です．
相関係数の公式を確認しておきましょう． $X=\{x_1, x2, \cdots, x_n\}$，$Y=\{y_1,y_2,\cdots,y_n\}$とします． このとき，$X$と$Y$の相関係数は次の式で求められます．
$$ XとYの相関係数=\frac{\sum (x_i - \bar{x})(y_i - \bar{y})}{\sqrt{\sum (x_i - \bar{x})^2} \cdot \sqrt{\sum (y_i - \bar{y})^2}} $$
算出された相関係数は-1から1の範囲となり，1に近いほど強い正の相関，-1に近いほど強い負の相関となります． また，相関係数が-0.2から0.2の範囲のときは，相関なしとみなすことが一般的です．
   相関係数 相関の強さ     0.7～1.0 強い正の相関   0.4～0.7 正の相関   0.2～0.4 弱い正の相関   -0.2～0.2 相関なし   -0.4～-0.2 弱い負の相関   -0.</description>
    </item>
    
    <item>
      <title>Pythonの基本</title>
      <link>https://mukai-lab.info/pages/classes/management_data_analysis/chapter1/</link>
      <pubDate>Thu, 08 Sep 2022 16:34:29 +0900</pubDate>
      
      <guid>https://mukai-lab.info/pages/classes/management_data_analysis/chapter1/</guid>
      <description>授業目的と学習方法  この授業では，ビジネスや日常生活における意思決定の場面において， 論理的に問題を捉えて最適な行動を選択できるようになるために， 統計に基づくデータサイエンスのスキルを学ぶことを目的とします． 近年は高速な計算機（PC）を用いて，多種多様なデータを大量に分析することが可能になり， データサイエンス が一つの学問として注目される様になりました． 本授業を履修した学生には，この授業で学んだデータサイエンスのスキルをレポートや卒業論文で活かすことはもちろん， 世の中に存在する社会課題の解決手段として応用することを期待しています．
データ分析のためのツールとして，次のソフトウェアを利用します． Excel は分析対象のデータの概要を把握するために用い， Jupyter Lab はPythonで実装されたデータ分析手法を適用するために用います． 多くの学生はExcelの利用経験があると思いますが，Pythonによるプログラミングは初めてかもしれません． この授業では，実際にデータに触れながら，Pythonの使い方に関しても学習してもらいます．
 表計算ソフト Microsoft Excel Pythonのプログラミング環境 Jupyter Lab  Jupyter Lab  Pythonのプログラム開発にはJupyter Labを利用します． Jupyter Labは，ChromeやEdgeなどのブラウザで動作するウェブ・アプリケーションです． 公式サイトが公開しているオンラインの体験版の利用も可能ですが， ローカルのPCにインストールして利用する方が良いでしょう（大学のPCにインストールされています）． Jupyter Labを起動して，Python 3 のノートブックを開きましょう． 最初にノートブックに名前を付けて保存します． ここでは，chapter1.ipynbという名前に設定しましょう．

Jupyter Labは，セル と呼ばれるテキストフィールドにプログラムを入力する仕組みになっています． セルに次のコードを入力してみましょう．
# 加算をするプログラム 1+2 コードを入力したら，Runボタン をクリックしましょう（[Shift]+[Enter] でもOK）． するとプログラムが実行され，その結果3が表示されます．

このように，Jupyter Labでは，ユーザはセルにプログラムを入力しながら，インタラクティブにプログラムの開発が可能です． 本授業のテーマであるデータ分析はもちろん，機械学習やAIなどのプログラム開発にも用いられます．
Pythonの基本  これから，Pythonを利用してデータ分析に取り組む上で最低限知っておくべきPythonの基本を学んでおきましょう．
print関数 数値や文字列を画面に出力するには print関数 を用います． 文字列を出力する際は&amp;quot;で括る必要があることに注意してください． 後に説明する 変数 出力することもできます． セルに複数行のコードを入力したときは，print関数を用いなくとも最後のコードの実行結果は， 必ず画面に出力される仕組みになっています．</description>
    </item>
    
    <item>
      <title>js-turtleで図形を描こう!</title>
      <link>https://mukai-lab.info/pages/tech/turtle/js-turtle/</link>
      <pubDate>Sun, 17 Jul 2022 10:45:15 +0900</pubDate>
      
      <guid>https://mukai-lab.info/pages/tech/turtle/js-turtle/</guid>
      <description>js-turtleとは  この模擬授業では，タートル・グラフィクスと呼ばれるコンピュータ・グラフィックスを記述するための方法を用いて図形を描くことに挑戦します． タートル・グラフィックスでは，ペンの代わりとなるカメを動かすことで，キャンバス上に直線や矩形などの図形を描く仕組みとなっており，プログラミング学習に最適とされています． タートル・グラフィックスの歴史は古く，1960年代にプログラミング言語LOGOに導入されたことから始まり，現在ではJavaScriptやPythonなど主要なプログラミング言語で利用可能になっています． JavaScriptでタートル・グラフィックスを利用するための追加機能（ライブラリ）がjs-turtleです． ここでは，Webページを記述するために用いられるJavaScriptで，タートル・グラフィックスに挑戦しましょう．

プログラミング環境  CodePenというオンラインのプログラミング環境を利用します． 下図のように，CodePenの画面に表示されている JS というボタンをクリックしてみましょう． コード（プログラム）を記述するためのエディタが表示されます． このエディタに記述したコードに合わせて，右側のキャンバスにプレビュー（プログラムの結果）が表示されます． もう一度 JS をクリックすると，エディタが非表示になり，キャンバスが大きく表示されるので，適宜切り替えて確認しましょう．

See the Pen js-turtleで図形を描こう！ by Naoto Mukai (@nmukai) on CodePen.  座標系の確認  タートル・グラフィックスの座標系を確認しましょう． キャンバスの中央にある緑色の矢印がカメです． このカメの座標は$(x,y) = (0, 0)$です． カメには向きがあり，最初は上方向 $\theta=0$ を向いています． キャンバスの右方向にXは増加し，上方向にYは増加します．

具体例を考えてみましょう． 下記の4種類の座標はどこにあるでしょうか．
 $(x, y)=(200, 200)$ $(x, y)=(200, -200)$ $(x, y)=(-200, -200)$ $(x, y)=(-200,200)$  
タートル・グラフィックスの基本  直進 カメを進行方向に直進させるにはforward(進む距離)と記述します． 括弧の中には 進む距離 を指定します．
forward(200) // 200だけ直進</description>
    </item>
    
    <item>
      <title>ロブリックでロボホンをプログラミング！</title>
      <link>https://mukai-lab.info/pages/tech/robohon/roblick/</link>
      <pubDate>Sat, 14 May 2022 15:06:41 +0900</pubDate>
      
      <guid>https://mukai-lab.info/pages/tech/robohon/roblick/</guid>
      <description>ロブリック（ROBLICK）とは  ロブリック（ROBLICK）は，シャープ株式会社が提供しているロボホンの開発ツールです． ロボホンは人型のロボットですが，アンドロイド（Android）のスマートフォンでもあります． アンドロイドの開発は，プログラミング言語のJavaが用いられるため， シャープ株式会社が提供しているロボホンの開発キット（Software Development Kit: SDK）を利用するにはJavaの知識が必要です． 一方，ロブリックは，Scratchによく似たインターフェースを備えた，ビジュアル・プログラミングのツールです． ロボホンの動作を表すブロックを，マウスで操作して組み立てることで，プログラミングの初心者でもロボホンのプログラミングが可能です． ロブリックは有料アプリのため購入が必要ですが，30日間のトライアル期間が設けられているので，ロボホン・ユーザは是非トライしてみましょう． この資料ではロブリックの基本的な使い方を説明します．
ロブリックの起動  ロブリックをダウンロードしたロボホンには，「ロブリック」と「ロブリック実行」の2種類のアプリがインストールされています． プログラミングを開発するときは「ロブリック」，開発したプログラムをデモンストレーションするときは「ロブリック実行」を起動します． ここでは，前者の「ロブリック」を起動しましょう．

ロブリックを起動すると，次のように IPアドレス:ポート番号 が表示されます． このとき，ロボホンはサーバーとして動作しており，クライアントとなるPCから上記のIPアドレスとポート番号でアクセスが可能な状態です(PCは同じネットワークに存在する必要があることに注意)．

PCでウェブブラウザ（Chromeなど）を起動して，URLに上記の「IPアドレス:ポート番号」入力すると，ロブリックの開発画面が表示されます． とても簡単に接続できますね．

プログラムの開発  ロブリックはScratchのように，ブロックを組み立てることでプログラミングを開発します． ブロックは，5種類の「ロボホンの基本動作」と，5種類の「ロブリックのデータ構造」，3種類の「ロブリックの制御」のグループで構成されています． 複雑なプログラムをするときは，ロブリックのデータ構造と制御のブロックは便利ですが， 取り敢えず動かしてみるだけならロボホンの基本動作だけで十分です．
ロボホンの基本動作
 しゃべる 動く 聞く 表示する その他  ロブリックのデータ構造
 テキスト リスト 連想配列 変数 関数  ロブリックの制御
 計算 条件 繰り返し  ロボホンが「しゃべる」 ブロックを組み立ててプログラムを作成しましょう． 「しゃべる」グループから，「スタート」のブロックを ドラッグ&amp;amp;ドロップ で，中央のエディタに移動させます． プログラムは必ず「スタート」から始める必要があります．

同様に「しゃべる」グループから，「&amp;ldquo;こんにちは&amp;quot;としゃべる」のブロックをドラッグ&amp;amp;ドロップで， 上記の「スタート」のブロックに接続します． ブロックを削除したい場合は，ドラッグ&amp;amp;ドロップでゴミ箱までブロックを移動させればOKです．

最後にロブリックの開発画面の下部にある「スタート」ボタンをクリックしましょう． ロボホンが「こんにちは」と発話すれば成功です．

   試してみよう！   ロボホンのセリフを設定して，自由に発話させてみてください．  ロボホンが「動く」 ロボホンは「しゃべる」だけでなく「動く」こともできます． ダイナミックな動きも可能ですが，テーブルなど 高所から落とさないよう 注意しましょう． 「動く」グループから，「右を向く」のブロックをドラッグ&amp;amp;ドロップで，「スタート」のブロックに接続しましょう． この「右を向く」ブロックは，「左を向く」，「正面を向く」など他の動作に変更することが可能です． ここでは，「右を向く」の後に，「正面を向く」「左を向く」「バンザイ」を続けて接続しましょう．</description>
    </item>
    
    <item>
      <title>p5.js②・アニメーションと衝突処理</title>
      <link>https://mukai-lab.info/pages/classes/applied_programming_wa/chapter12/</link>
      <pubDate>Fri, 13 May 2022 13:56:27 +0900</pubDate>
      
      <guid>https://mukai-lab.info/pages/classes/applied_programming_wa/chapter12/</guid>
      <description>p5.jsでアニメーション  p5.jsでアニメーションを表現するには，フレームごとに図形を少しずつ動かすことで，パラパラ漫画のように図形が動いているように錯覚させます． 1秒間に切り替わるフレーム数のことは，フレームレートと呼ばれます（単位はfps）． p5.jsのフレームレートは，ディスプレイのフレームレートに基づいて決定され， 一般に60fpsが用いられることが多いです． ここでは，「ブロックくずし」を作成しながら，アニメーションや衝突の処理について学びます．
CodePenの準備  CodePenにアクセスして，Penを作成し，タイトルを設定しましょう． Penのタイトルは「Chapter12」に設定しましょう．

前回と同様にVue.jsとvue-p5のライブラリをペンに追加してください． Vue.jsのバージョンは2.6.11，vue-p5はhttps://unpkg.com/vue-p5を直接入力してください．

vue-p5  HTMLは次のように記述します． vue-p5タグにおいて，p5.jsの実装に必要なsetup()とdraw()を宣言します．
&amp;lt;!-- HTML --&amp;gt; &amp;lt;div id=&amp;#34;app&amp;#34;&amp;gt; &amp;lt;h1&amp;gt;{{ title }}&amp;lt;/h1&amp;gt; &amp;lt;vue-p5 @setup=&amp;#34;setup&amp;#34; @draw=&amp;#34;draw&amp;#34;&amp;gt; &amp;lt;/vue-p5&amp;gt; &amp;lt;/div&amp;gt; JavaScriptでVueクラスを定義します． キャンバスの幅と高さはいずれも500px，キャンバスの背景色は黒色にします．
// JavaScript new Vue({ el: &amp;#39;#app&amp;#39;, data: { title: &amp;#34;ブロックくずし&amp;#34;, }, methods: { setup(sketch){ sketch.createCanvas(500, 500); // キャンバスの大きさ  sketch.background(&amp;#34;black&amp;#34;); // キャンバスの背景色  }, draw(sketch){ } } }); 
図形描画  プレイヤーが操作するパドルを四角形で表現します． dataオプションで，パドルの位置を表すplayer_xとplayer_yを定義します． また，パドルの大きさは，幅が100，高さが50とします．
data: { title: &amp;#34;ブロックくずし&amp;#34;, player_x: 250, player_y: 490, } 上記で定義したplayer_xとplayer_yを利用して四角形を描きます． 四角形を描く関数はrect(x, y, width, height)です． 引数のx，yは四角形の左上の座標，widthは幅，heightは高さです． パドルの中心をplayer_xとするため，四角形のX座標はx=this.</description>
    </item>
    
    <item>
      <title>p5.js①・図形描画とイベント処理</title>
      <link>https://mukai-lab.info/pages/classes/applied_programming_wa/chapter11/</link>
      <pubDate>Fri, 13 May 2022 13:56:25 +0900</pubDate>
      
      <guid>https://mukai-lab.info/pages/classes/applied_programming_wa/chapter11/</guid>
      <description>p5.jsとは  p5.jsは，芸術家やデザイナーのためのオープンソースのJavaScriptライブラリです． ウェブページに，キャンバスを設置し，図形やアニメーションを描画することができます． Processingと同等の機能を備えていることから，Processing経験者には学習コストが低く，プログラミングの初学者にも適したライブラリです． ここでは，vue-p5を利用することで，Vue.jsとp5.jsを共存させながら，「３目並べ」のWebアプリを開発することを目指します．
CodePenの準備  CodePenにアクセスして，Penを作成し，タイトルを設定しましょう． Penのタイトルは「Chapter11」に設定しましょう．

前回と同様にVue.jsのライブラリをペンに追加してください． Vue.jsのバージョンは2.6.11を採用します．

次に，Vue.jsとp5.jsを共存させるためのvue-p5を導入します． 検索してもCDNがリストアップされないので，https://unpkg.com/vue-p5を直接入力します．

vue-p5  vue-p5を利用することで，Vueクラスのメソッドとしてシンプルにp5.jsを記述することができます． HTMLは次のように記述します． vue-p5タグで，p5.jsの実装に必要な関数setup()とdraw()を宣言します． 次回利用するマウスの移動を検出するmouseMoved()なども，必要があれば追加で宣言します．
&amp;lt;!-- HTML --&amp;gt; &amp;lt;div id=&amp;#34;app&amp;#34;&amp;gt; &amp;lt;h1&amp;gt;{{ title }}&amp;lt;/h1&amp;gt; &amp;lt;vue-p5 @setup=&amp;#34;setup&amp;#34; @draw=&amp;#34;draw&amp;#34;&amp;gt; &amp;lt;/vue-p5&amp;gt; &amp;lt;/div&amp;gt; JavaScriptでは，Vueクラスを定義します． このとき，methodsオプションに，上記で宣言したsetup()とdraw()を記述します． これらの関数の引数であるsketchを利用して，p5.jsの関数を呼び出します． 例えば，キャンバスの大きさを設定する関数はsketch.createCanvas(width, height)，また，キャンバスの背景色を設定する関数はsketch.background(color)のように記述します． キャンバスの原点(0,0)は左上であり，右方向にX軸，下方向にY軸が伸びています．
// JavaScript new Vue({ el: &amp;#39;#app&amp;#39;, data: { title: &amp;#34;３目並べ&amp;#34;, }, methods: { setup(sketch){ sketch.createCanvas(500, 500); // キャンバスの大きさ  sketch.background(&amp;#34;black&amp;#34;); // キャンバスの背景色  }, draw(sketch){ } } });</description>
    </item>
    
    <item>
      <title>Vue.js③・コンポーネント</title>
      <link>https://mukai-lab.info/pages/classes/applied_programming_wa/chapter10/</link>
      <pubDate>Thu, 05 May 2022 16:29:09 +0900</pubDate>
      
      <guid>https://mukai-lab.info/pages/classes/applied_programming_wa/chapter10/</guid>
      <description>コンポーネントとは  コンポーネント はHTMLを構成する部品のことです． Vue.jsでは，Vue.component()を使ってコンポーネントを定義します． コンポーネントには，複数のHTML要素をまとめたtemplateオプション，データバインディングのためのdataオプション，関数を定義するためのmethodsオプションなどを記述します． コンポーネントとして定義することで，コンポーネントの再利用が可能となり，プログラムの設計が簡単になります． また，propsオプションを利用することで，コンポーネントに任意のデータを渡すことが可能です． 今回は日進市の観光地を紹介するアプリを開発します． 観光地の情報や画像を表示するHTML要素をコンポーネントとして実装します．
CodePenの準備  CodePenにアクセスして，Penを作成し，タイトルを設定しましょう． Penのタイトルは「Chapter10」に設定しましょう．

前回と同様にVue.jsのライブラリをペンに追加してください． Vue.jsのバージョンは2.6.11を採用します．

また，Vue.jsの基本構造も記述しておきます． Vueクラスのインスタンスには，el，data，methodsを指定します． Webアプリのタイトルと説明文も記載しておきましょう．
&amp;lt;!-- HTML --&amp;gt; &amp;lt;div id=&amp;#34;app&amp;#34;&amp;gt; &amp;lt;h1&amp;gt; {{ title }} &amp;lt;/h1&amp;gt; &amp;lt;p&amp;gt; {{ description }} &amp;lt;/p&amp;gt; &amp;lt;div&amp;gt; // JavaScript let app = new Vue({ el: &amp;#34;#app&amp;#34;, data: { title: &amp;#34;日進市観光アプリ&amp;#34;, description: &amp;#34;日進市の観光地を紹介するアプリです．&amp;#34;, }, methods: { }, }) 
コンポーネントの作成  日進市の観光情報を表示するためのHTML要素を コンポーネント として定義します． コンポーネントを定義するには，Vue.component()を利用します． コンポーネントには名前を付けることが可能で，ここではpanel-componentに設定しています． コンポーネントには，templateオプションを記述します． templateオプションでは，テンプレート文字列を利用して，コンポーネントで表示するHTMLを記述します． ここでは，マスタッシュ記法を利用して，dataプロパティで定義したnameを表示しています． この他にも，dataオプション，methodsオプションなどを定義することができます． dataオプションで定義する変数は，returnを使って関数として定義する必要があることに注意してください（インスタンス間で変数の競合を避けるため）．</description>
    </item>
    
    <item>
      <title>Vue.js②・フォーム処理</title>
      <link>https://mukai-lab.info/pages/classes/applied_programming_wa/chapter9/</link>
      <pubDate>Thu, 05 May 2022 16:25:39 +0900</pubDate>
      
      <guid>https://mukai-lab.info/pages/classes/applied_programming_wa/chapter9/</guid>
      <description>フォーム処理  Webアプリでは，テキストフィールド や ラジオボタン などのフォームを利用して，ユーザの入力を受け付けることになります． これらのフォームに入力された値も，データバインディングの対象となります． ここでは，英単語のクイズ問題を作成して，クイズに対するユーザの回答を処理してみましょう． クイズの回答には，ユーザが文字列を入力するためのテキストフィールドや，選択肢から選ぶためのラジオボックスを利用します． また，ユーザに情報を伝達するために便利な ダイアログ の使い方も確認します．
CodePenの準備  CodePenにアクセスして，Penを作成し，タイトルを設定しましょう． Penのタイトルは「Chapter9」に設定しましょう．

前回と同様にVue.jsのライブラリをペンに追加してください． Vue.jsのバージョンは2.6.11を採用します．

また，Vue.jsの基本構造も記述しておきます． Vueクラスのインスタンスには，el，data，methodsを指定します． Webアプリのタイトルと説明文も記載しておきましょう．
&amp;lt;!-- HTML --&amp;gt; &amp;lt;div id=&amp;#34;app&amp;#34;&amp;gt; &amp;lt;h1&amp;gt; {{ title }} &amp;lt;/h1&amp;gt; &amp;lt;p&amp;gt; {{ description }} &amp;lt;/p&amp;gt; &amp;lt;div&amp;gt; // JavaScript let app = new Vue({ el: &amp;#34;#app&amp;#34;, data: { title: &amp;#34;英単語クイズアプリ&amp;#34;, description: &amp;#34;英単語に関するクイズを出題します．&amp;#34;, }, methods: { }, }) 
クイズ問題の作成  「英単語のスペル（spell）」と「英単語の意味（meaning）」を回答するクイズ問題を配列で作成します． スペルの問題は，type，question，image，answerのキーを持つ連想配列です． typeはspellに設定します． imageはいらすとやで提供されている動物の画像のURLです． 同様に，意味の問題は，type，question，options，answerのキーを持つ連想配列です． typeはmeaningに設定します． optionsは回答の選択肢であり，配列で表現することにします．</description>
    </item>
    
    <item>
      <title>Vue.js①・データバインディング</title>
      <link>https://mukai-lab.info/pages/classes/applied_programming_wa/chapter8/</link>
      <pubDate>Thu, 05 May 2022 16:19:33 +0900</pubDate>
      
      <guid>https://mukai-lab.info/pages/classes/applied_programming_wa/chapter8/</guid>
      <description>Vue.js  Vue.jsは，JavaScriptフレームワークの一つであり，フロントエンドの開発に用いられます． フレームワークとは，Webアプリの骨組みとしての役割を担い，データを同期させる データバインディング ，ウェブページの部品となる コンポーネント などの機能が提供されます． JavaScriptフレームワークには，Vue.js以外にも，React，Angularなどがありますが，その中でもVue.jsは学習コストが低く，ページの一部分から大規模な開発まで手軽に利用できることが強みです． また，Vue.jsは日本での導入事例が比較的多く，日本語で書かれたドキュメントも豊富にあります（任天堂の公式サイトはVue.jsで開発）．
 Vue.js 2014年にEvan You氏がリリース．MITライセンス． React 2013年にJordan Walke氏がリリース．MITライセンス． Angular 2016年にGoogleを中心としたコミュニティがリリース．MITライセンス．  CodePenの準備  CodePenにアクセスして，Penを作成し，タイトルを設定しましょう． Penのタイトルは「Chapter8」に設定しましょう．
 https://codepen.io/

ここでVue.jsのライブラリをペンに追加します． Settingsのウィンドウを開き，JS（JavaScript）のAdd External Scripts/Pensで，「Vue.js」を検索します． 検索結果の一覧から，バージョン2.6.11のVue.jsのCDN（Content Delivery Network）を追加します． CDNはライブラリなどに対するアクセスの集中を分散させる仕組みになっています．

Vue.jsの基本構造  Vue.jsの基本構造として次のように記述します． HTMLでは，divタグにID属性（id=&amp;quot;app&amp;quot;）を設定します． JavaScriptでは，Vueクラスのインスタンスを作成します． 引数は連想配列で与えられ，el，data，methodsなどのオプションを指定します．
elでは，対応するdivタグのID属性を指定します． dataでは，次節で説明するデータバインディングのための変数を定義します． データバインディングとは，JavaScriptで宣言した変数を，HTMLで同期させる仕組みです． methodsでは，ボタンをクリックしたなどのイベントが発生したタイミングで実行する関数を定義します．
&amp;lt;!-- HTML --&amp;gt; &amp;lt;div id=&amp;#34;app&amp;#34;&amp;gt; &amp;lt;div&amp;gt; // JavaScript let app = new Vue({ el: &amp;#34;#app&amp;#34;, // 対象のID属性を指定  data: { // 変数を定義  }, methods: { // 関数を定義  }, }) データバインディング  データバインディングを利用して，ページのタイトルと説明文を記述しましょう． dataオプションに，titleとdescriptionを連想配列の形式で記述します． これらは，リアクティブデータと呼ばれ，データの更新がHTMLにも自動的に反映されます．</description>
    </item>
    
    <item>
      <title>Pygame Zero⑤マップの作成</title>
      <link>https://mukai-lab.info/pages/classes/programming/chapter12/</link>
      <pubDate>Wed, 27 Apr 2022 12:34:43 +0900</pubDate>
      
      <guid>https://mukai-lab.info/pages/classes/programming/chapter12/</guid>
      <description>マップの作成  2Dゲームでは画像をタイル状に表示することで，ゲーム・マップを作成する方法が採用されています． タイル状の画像を進行方向とは逆にシフトさせることで，ゲーム画面のスクロールも表現できます． Pygame Zeroでは，マップを作成・表示するためのクラスは用意されていませんので，独自に Mapクラス を実装します． また，これまで取り上げてこなかった ディクショナリ と呼ばれるデータ構造も紹介します． ディクショナリは，リストと同様に，複数の値を記憶するために用います． if文で表現される条件分岐の代替として用いることが可能であり，状況に応じて，リストと使い分けると効果的です．
準備  Muエディタを起動したら，Pygame Zero モードを選択しましょう． 保存用のフォルダを「chapter12」という名前で作成し，ソースファイルを「game.py」という名前でフォルダ内に保存します． また，ゲームを表示するためのウィンドウを作成します． ウィンドウの幅は640px，高さは480px，背景色は白色に設定します．
WIDTH = 640 HEIGHT = 480 def draw(): screen.fill(&amp;#34;white&amp;#34;) ディクショナリ  ここでは，Pythonのデータ構造の一つであるディクショナリ（辞書）について確認しましょう． リストとの違いを意識すると良いです．
ディクショナリの使い方 リストは，0，1，2などの参照番号で，記憶させた要素を参照する仕組みでした． 一方，ディクショナリは，任意のキーで，記憶させた要素を参照する仕組みです． 数値だけでなく，文字列もキーとして指定が可能です． ここでは，&amp;ldquo;a&amp;rdquo;，&amp;ldquo;b&amp;rdquo;，&amp;ldquo;c&amp;rdquo;，をキーとして指定しています． ディクショナリを作成するときは，キーとバリュー（記憶させる値）の組み合わせを，{}で括って列挙します． しかし，データを参照するときは，リストと同様に[]を用いることに注意してください．
dic = {&amp;#34;a&amp;#34;: &amp;#34;apple&amp;#34;, &amp;#34;b&amp;#34;: &amp;#34;banana&amp;#34;, &amp;#34;c&amp;#34;: &amp;#34;cherry&amp;#34;} # ディクショナリの作成 print(dic) # -&amp;gt; {&amp;#39;a&amp;#39;: &amp;#39;apple&amp;#39;, &amp;#39;b&amp;#39;: &amp;#39;banana&amp;#39;, &amp;#39;c&amp;#39;: &amp;#39;cherry&amp;#39;} print(dic[&amp;#34;a&amp;#34;]) # -&amp;gt; apple print(dic[&amp;#34;b&amp;#34;]) # -&amp;gt; banana print(dic[&amp;#34;c&amp;#34;]) # -&amp;gt; cherry</description>
    </item>
    
    <item>
      <title>Pygame Zero④ アニメーションとサウンド</title>
      <link>https://mukai-lab.info/pages/classes/programming/chapter11/</link>
      <pubDate>Sun, 24 Apr 2022 19:10:14 +0900</pubDate>
      
      <guid>https://mukai-lab.info/pages/classes/programming/chapter11/</guid>
      <description>アニメーションとサウンド  スプライトをアニメーションさせるには，前回のようにupdate()の中で座標を更新する方法に加え，Animationクラスを利用する方法があります． Animationクラスでは，直線的な動きに加え，速度の変化や，揺れる動きなどを簡単に表現することが可能です． また，Soundクラスや，Musicクラスを利用すると，ゲームに効果音やBGMを再生することが可能です． これらのクラスを活用して，ゲームの雰囲気を高めましょう．
準備  Muエディタを起動したら，Pygame Zero モードを選択しましょう． 保存用のフォルダを「chapter11」という名前で作成し，ソースファイルを「game.py」という名前でフォルダ内に保存します． また，ゲームを表示するためのウィンドウを作成します． ウィンドウの幅は640px，高さは480px，背景色は白色に設定します．
WIDTH = 640 HEIGHT = 480 def draw(): screen.fill(&amp;#34;white&amp;#34;) アニメーション  KENNYのAlien UFO Packに収録されている UFOの画像ufo1.pngとufo2.pngをダウンロードして，imagesフォルダにコピーしてください．


Animationクラス Animationクラスを利用したアニメーションを実装しましょう． Animationクラスのオブジェクトはanimate()で生成します． animate()の引数として，対象のActorクラスのオブジェクト（ufo）， アニメーションで移動する目的の座標（pos=(640, 240)）， アニメーションのタイプ（tween=&amp;quot;linear&amp;quot;）， アニメーションの開始から終了までの秒数（duration=3）を指定します． ここでは，スクリーンの左から右に向かって，3秒間かけて直線上に移動します． また，アニメーションの終了後に呼び出す関数を指定する引数on_finishedが用意されていますが， 正常な動作を確認できなかったので注意しましょう（Version 1.2.1で確認）．
# スプライトの生成 ufo = Actor(&amp;#34;ufo1&amp;#34;, midleft=(0, 240)) # 座標(640, 240)に向かって線形に3秒間移動 animate(ufo, pos=(640, 240), tween=&amp;#34;linear&amp;#34;, duration=3) def draw(): screen.fill(&amp;#34;white&amp;#34;) ufo.draw() 
アニメーションのタイプには，linearを含めて，10種類が用意されています． accelerateは，ゆっくりとした速度から，だんだん速度が上昇するアニメーションです．
animate(ufo, pos=(640, 240), tween=&amp;#34;accelerate&amp;#34;, duration=3)</description>
    </item>
    
    <item>
      <title>Pygame Zero③ スプライトとイベント処理</title>
      <link>https://mukai-lab.info/pages/classes/programming/chapter10/</link>
      <pubDate>Sun, 24 Apr 2022 12:20:43 +0900</pubDate>
      
      <guid>https://mukai-lab.info/pages/classes/programming/chapter10/</guid>
      <description>スプライトとイベント処理  スプライト（Sprite）とは，ゲームにおいてキャラクターをスクリーンに合成表示させるための仕組みのことです． 背景に対して，キャラクター・物体・文字などのスプライトを重ねて表示させることができます． CPU処理能力が低かったファミコンなどのゲーム機においてはハードウェアとして実装されていましたが， 現在のゲームにおいては，同様の機能がソフトウェアで実現され，疑似スプライトなどと呼ばれています． ここでは，位置の変更を伴うキャラクター画像のことを「スプライト」と考えれば良いです． スプライト用の画像は，様々なサイトで提供されていますが，KENNYで公開されているフリー画像を利用することにします． KENNYが提供しているアセット（素材）は，一部を除きCC0のライセンスであり，パブリックドメインとして自由に利用が可能です． また，キャラクターを動かすには，マウスやキーボードなどのイベント処理が必要となります． スプライトの使い方と合わせて，イベント処理についても学びましょう．


準備  Muエディタを起動したら，Pygame Zero モードを選択しましょう． 保存用のフォルダを「chapter10」という名前で作成し，ソースファイルを「game.py」という名前でフォルダ内に保存します． また，ゲームを表示するためのウィンドウを作成します． ウィンドウの幅は640px，高さは480px，背景色は白色に設定します．
WIDTH = 640 HEIGHT = 480 def draw(): screen.fill(&amp;#34;white&amp;#34;) スプライトの表示  KENNYからPlatformer Charactersをダウンロードしましょう． このアセットには，プレイヤー（Player），女性（Female），冒険家（Adventurer），戦士（Soldier），ゾンビ（Zombie）の5種類のキャラクターが含まれています． この中から，プレイヤー（Player）に該当する24種類のPNG画像（player_idle.png，player_walk1.pngなど）を，新規作成した imagesフォルダ を作成し，コピーして配置します．

Actorクラス Pygame Zeroには，スプライトを扱うためのActorクラスが用意されています． Actorクラスには，位置を表すx，y，画像ファイルを表すimageなどの変数と， スクリーンに表示するためのdraw()，他のスプライトと衝突を判定するcollidepoint()，colliderect()などの関数が実装されています．
それでは，Actorクラスを利用して，画像ファイルplayer_idle.pngをスプライトとして表示させます． このとき，スプライトの位置は，スクリーンの中央とします． また，スプライトをスクリーンに表示させるにはdraw()を用います．
# スプライトを生成 player = Actor(&amp;#34;player_idle&amp;#34;, center=(WIDTH/2, HEIGHT/2)) def draw(): screen.fill(&amp;#34;white&amp;#34;) player.draw() # スプライトを描画 
スプライトの位置を設定には アンカーポイント を用いることができます． アンカーポイントとして9種類が用意されており，centerは画像の中央，topleftは画像の左上が，指定された座標と一致するよう配置されます．

# スプライトを生成 player = Actor(&amp;#34;player_idle&amp;#34;, topleft=(WIDTH/2, HEIGHT/2)) def draw(): screen.</description>
    </item>
    
    <item>
      <title>Pygame Zero② フレーム処理とクラス</title>
      <link>https://mukai-lab.info/pages/classes/programming/chapter9/</link>
      <pubDate>Sun, 17 Apr 2022 15:33:47 +0900</pubDate>
      
      <guid>https://mukai-lab.info/pages/classes/programming/chapter9/</guid>
      <description>フレーム処理とクラス  ゲーム開発において基本となる フレーム処理 について学習します． フレーム とは，図形，文字列，画像などが表示されているスクリーンのある時刻の状態のことです． パラパラ漫画の要領でフレームが切り替わることで，映像としてゲームが成立しています． フレームの切り替わりの速度は， フレームレート（fps） として表され，一般的なゲームで必要とされる60fpsは，1秒間に60回フレームが切り替わることを意味しています． また，ゲーム開発において，利用すると便利な クラス についても説明します． クラスは，整数や文字列などを記憶するための変数と，複数の処理を実行する関数を，まとめて管理するための仕組みです． クラスを正しく理解するには， オブジェクト指向を学ぶ必要がありますが，本授業では割愛します．
準備  Muエディタを起動したら，Pygame Zero モードを選択しましょう． 保存用のフォルダを「chapter9」という名前で作成し，ソースファイルを「game.py」という名前でフォルダ内に保存します． また，ゲームを表示するためのウィンドウを作成します． ウィンドウの幅は640px，高さは480px，背景色は白色に設定します．
WIDTH = 640 HEIGHT = 480 def draw(): screen.fill(&amp;#34;white&amp;#34;) フレーム処理  Pygame Zeroでフレーム処理を実装するには，draw()とupdate()を定義します． 1つのフレームにおいて，最初にdraw()が実行され，その後でupdate()が実行されます． draw()では図形や画像などの 表示，update()では図形や画像の移動などの 更新 を記述します．

最初にdraw()において，filled_circle()とline()で赤いリンゴを表示します． リンゴの位置は変数xとyを利用して相対的に決まることに注意してください．
x = 320 # X座標 y = 0 # Y座標 speed = 1 # 落下速度 def draw(): screen.fill(&amp;#34;white&amp;#34;) # screen.fill((255, 255, 255))でもOK # 赤いリンゴ screen.</description>
    </item>
    
    <item>
      <title>Pygame Zero① Pygame Zeroの基本</title>
      <link>https://mukai-lab.info/pages/classes/programming/chapter8/</link>
      <pubDate>Sun, 10 Apr 2022 17:48:35 +0900</pubDate>
      
      <guid>https://mukai-lab.info/pages/classes/programming/chapter8/</guid>
      <description>Pygame Zero  Pygame ZeroはPythonでゲームを開発するためのライブラリです． 利用可能なAPIやイベントループなどの仕組みが簡略化されており，初学者が教育目的でゲームを開発するには適しています． 美麗なグラフィックの3Dゲームなどの開発は困難ですが，シューティングやパズルなどの2Dゲームの開発を目標に頑張りましょう（3Dゲームの開発にはUnityがオススメ）．
準備  Muエディタを起動したら，Pygame Zero モードを選択しましょう． これまでとは異なり，保存用のフォルダを作成し，ソースファイルをフォルダ内に保存します． 「chapter8」という名前でフォルダを作成した後で，ツールバーにある「保存」をクリックして，「game.py」という名前でフォルダ内にスクリプトを保存します．
ウィンドウの初期化  ゲームを表示するためのウィンドウを作成しましょう． ウィンドウの幅と高さを設定するにはWIDTH，HEIGHTという変数に代入します． ここでは，幅を640px，高さを480pxに設定しています． また，draw()という関数を定義し，関数内でscreen.fill()を実行します． screen.fill()は，ゲームを描画するスクリーンの背景色を設定する関数です． 引数に，色名を表す文字列や，RGB（赤・緑・青）のタプルを指定します．
WIDTH = 640 # ウィンドウの幅 HEIGHT = 480 # ウィンドウの高さ def draw(): # 背景色が白のスクリーン screen.fill(&amp;#34;white&amp;#34;) # screen.fill((255, 255, 255))でもOK 
図形やテキストの描画  図形の描画 スクリーンに直線，正方形，円などの図形を描画するには，次の表に示す関数を用います． スクリーンの左上が原点(0,0)であり，右方向にX軸，下方向にY軸が伸びています． このため，スクリーンの四隅の座標は，右上が(640, 0)，右下が(640, 480)，左下が(0, 480)となります．
   関数 説明     screen.draw.line(start, end, color) 直線を描く   screen.draw.rect(rect, color) 正方形を描く   screen.</description>
    </item>
    
    <item>
      <title>Turtleグラフィックス⑥ フラクタル図形</title>
      <link>https://mukai-lab.info/pages/classes/programming/chapter7/</link>
      <pubDate>Sun, 10 Apr 2022 11:30:55 +0900</pubDate>
      
      <guid>https://mukai-lab.info/pages/classes/programming/chapter7/</guid>
      <description>フラクタル図形  Turtleグラフィックスを利用して フラクタル図形 を描いてみましょう． フラクタル図形 とは，図形の一部が図形の全体と 自己相似 な関係を持つ図形のことです． 特定の処理を再帰的に繰り返して実行することで描くことができます． フラクタル図形は自然界でも観測が可能で，「シダの葉」や「雲の形」はフラクタル図形とされています． ここでは，フラクタルの性質を持つ「コッホ曲線」と「2分木」を描くことに挑戦しましょう．
準備  Muエディタを起動したら，Python3 モードを選択しましょう． ツールバーにある「保存」をクリックして，「chapter7.py」という名前でスクリプトを保存します． また，Turtleグラフィックスのライブラリ（モジュール）をインポートしておきましょう．
# Turtleグラフィックスのライブラリをインポート from turtle import * コッホ曲線  コッホ曲線は次の図に示す操作を再帰的に適用することで描くことができます． 直線を三分割し，中央の線分を底辺とした正三角形を描きます． このとき，図形全体を構成する4つの線分は同じ長さとなります． この処理を，各線分に対して再起的に適用することで， 2次，3次など高次のコッホ曲線を描くことができます．

再帰を利用しない実装 関数koch()を定義して，再帰を利用しない方法で1次のコッホ曲線を描いてみましょう．
# 1次のコッホ曲線 def koch(length): next_length = length / 3 forward(next_length) left(60) forward(next_length) right(120) forward(next_length) left(60) forward(next_length) speed(0) penup() goto(-200, 0) pendown() length = 400 # 直線の長さ koch(length) 
上記の1次のコッホ曲線の最初の辺だけ2次に変更してみましょう． 最初のforward(next_length)を，自己相似となるように，次のように置き換えます． このとき，2次のコッホ曲線の1辺の長さはlengthの1/9になります．
# 1次のコッホ曲線（最初の辺だけ2次に） def koch(length): next_length = length / 3 #---------- # 最初の辺だけ2次に変更 next_next_length = length / 3 / 3 forward(next_next_length) left(60) forward(next_next_length) right(120) forward(next_next_length) left(60) forward(next_next_length) #--------- left(60) forward(next_length) right(120) forward(next_length) left(60) forward(next_length)</description>
    </item>
    
    <item>
      <title>Turtleグラフィックス⑤ イベントの処理</title>
      <link>https://mukai-lab.info/pages/classes/programming/chapter6/</link>
      <pubDate>Sat, 09 Apr 2022 23:11:01 +0900</pubDate>
      
      <guid>https://mukai-lab.info/pages/classes/programming/chapter6/</guid>
      <description>イベントの処理  Turtleグラフィックスのイベント処理 の仕組みに関して学習しましょう． キャンバス上でのクリック操作とキー操作を検出し，特定の処理を実行することができます． イベント処理はライブラリに依存するため，汎用的なPythonの文法ではありませんが，その特徴を理解すれば，他のライブラリへの応用も簡単です．
準備  Muエディタを起動したら，Python3 モードを選択しましょう． ツールバーにある「保存」をクリックして，「chapter6.py」という名前でスクリプトを保存します． また，Turtleグラフィックスのライブラリ（モジュール）をインポートしておきましょう．
# Turtleグラフィックスのライブラリをインポート from turtle import * クリック・イベント  Turtleグラフィックスでは，クリック・イベントを検出して，特定の処理を実行することができます．
クリック・イベントが発生したときの処理を関数mouse_event(x, y)として定義します． このとき，引数のxとyは，スクリーン上でクリックされた座標を表します． ここでは，クリックされた座標に，直径10のドット（点）を描画します． この関数mouse_event(x, y)を，関数onscreenclick()に引数として渡します． これで，クリック・イベントが発生したときに，自動的に関数mouse_event(x,y)が呼び出されます．
# クリックが発生したときの処理 def mouse_event(x, y): penup() goto(x, y) pendown() dot(10) # 関数を登録 onscreenclick(mouse_event) 
マウスのボタン（左，中央，右）を区別して関数を登録することもできます． 関数onscreenclick()の第2引数として，左ボタンは1，中央ボタンは2，右ボタンは3を設定します． ここでは，左ボタンなら赤色のドット，中央ボタンなら青色のドットを描画します．
# 左ボタンの処理 def mouse_left(x, y): penup() goto(x, y) pendown() color(&amp;#34;red&amp;#34;) dot(10) # 中央ボタンの処理 def mouse_center(x, y): penup() goto(x, y) pendown() color(&amp;#34;blue&amp;#34;) dot(10) # 左ボタンのクリックに関数を登録 onscreenclick(mouse_left, 1) # 中央ボタンのクリックに関数を登録（トラックパッドの場合は2本指でタップ） onscreenclick(mouse_center, 2)</description>
    </item>
    
    <item>
      <title>Turtleグラフィックス④ データ型と関数</title>
      <link>https://mukai-lab.info/pages/classes/programming/chapter5/</link>
      <pubDate>Sat, 09 Apr 2022 16:52:07 +0900</pubDate>
      
      <guid>https://mukai-lab.info/pages/classes/programming/chapter5/</guid>
      <description>データ型と関数  Turtleグラフィックスを利用して， データ型 と 関数 の仕組みに関して学習しましょう． データ型とは，変数に記録されたデータの型のことです． リテラルはユーザ側が表現することが可能なデータのことですが， データ型はプログラム側がデータを区別するために用いる仕組みと考えると良いでしょう． また，関数は特定の処理に名前を付けて呼び出すための機能のことです． 関数を用いることで，煩雑なコードをすっきりとまとめて表現することが可能になります．
準備  Muエディタを起動したら，Python3 モードを選択しましょう． ツールバーにある「保存」をクリックして，「chapter5.py」という名前でスクリプトを保存します． また，Turtleグラフィックスのライブラリ（モジュール）をインポートしておきましょう．
# Turtleグラフィックスのライブラリをインポート from turtle import * データ型  データ型 Pythonのデータ型を次の表にまとめます． 数値リテラルは，整数ならint型，小数ならfloat型となります． また，文字列リテラルはstr型，TrueとFalseの真理値はbool型になります．
   データ型 　説明 例     int 整数 10, -1   float 小数 -0.1, 3.14   str 文字列 &amp;ldquo;abc&amp;rdquo;, &amp;ldquo;あいう&amp;rdquo;   bool 真理値 True, False    type()を用いて，データ型を確認してみましょう．
print(type(10)) # -&amp;gt; int print(type(0.</description>
    </item>
    
    <item>
      <title>Turtleグラフィックス③ 乱数と条件分岐</title>
      <link>https://mukai-lab.info/pages/classes/programming/chapter4/</link>
      <pubDate>Sat, 09 Apr 2022 11:39:47 +0900</pubDate>
      
      <guid>https://mukai-lab.info/pages/classes/programming/chapter4/</guid>
      <description>乱数と条件分岐  Turtleグラフィックスを利用して， 乱数 と 条件分岐 の仕組みに関して学習しましょう． 乱数とはランダムに生成された数値のことであり，偶発性の表現が必要なシミュレーションやゲームにおいて利用されます． コンピュータで真の乱数を生成することは困難なため，確定的な計算手法で算出される疑似乱数が用いられます（規則性が存在する）． また，指定した条件に応じて実行するプログラムを切り替えるための制御が条件分岐です． 条件分岐は，前回学習した繰り返しと同様に，Pythonに限らず一般的なプログラミング言語においても重要な機能です．

準備  Muエディタを起動したら，Python3 モードを選択しましょう． ツールバーにある「保存」をクリックして，「chapter4.py」という名前でスクリプトを保存します． また，Turtleグラフィックスのライブラリ（モジュール）をインポートしておきましょう．
# Turtleグラフィックスのライブラリをインポート from turtle import * 乱数  乱数を生成するにはPythonの標準モジュールであるrandom をインポートします． Pythonにおいて， モジュール とはインポートされるファイル（.py）のことを指しています． 一方で，ライブラリ とは複数のモジュールをまとめてインストールできる機能のことを指します． 実際には厳密にモジュールとライブラリを区別しないことも多いので注意しましょう．
# 乱数生成のためのモジュールをインポート from random import * 0以上1未満の乱数 0以上1未満の 一様分布 に従った実数（小数）を生成するには random() を用います．
# 0以上1未満の乱数 for i in range(10): print(random()) 範囲を指定した乱数 範囲を指定して 一様分布 に従った実数（小数）を生成するには uniform(a, b)を用います．生成される値$x$は，$a \leq x &amp;lt; b$となることに注意してください．
# 1以上5未満を指定した乱数 for i in range(10): print(uniform(1, 5)) 範囲を指定した乱数（整数） 範囲を指定して 一様分布 に従った整数を生成するには randint(a, b)を用います．生成される値$x$は，$a \leq x \leq b$となることに注意してください．</description>
    </item>
    
    <item>
      <title>Turtleグラフィックス② 変数と繰り返し</title>
      <link>https://mukai-lab.info/pages/classes/programming/chapter3/</link>
      <pubDate>Wed, 06 Apr 2022 13:47:50 +0900</pubDate>
      
      <guid>https://mukai-lab.info/pages/classes/programming/chapter3/</guid>
      <description>変数と繰り返し  Turtleグラフィックスを利用して， 変数 と 繰り返し の仕組みに関して学習しましょう． 変数とは数値や文字列などのデータを一時的に保存するための箱です． 例えば，計算式によって算出された結果を保存するために用いられます． プログラムを終了すると変数に格納されたデータを参照することはできません． また，変数や配列を利用して， 繰り返し という制御が実現されます． 繰り返しは，その名前が示すように，特定の処理を複数回繰り返して実行する処理のことです． Pythonに限らず，一般的なプログラミング言語において， 変数や繰り返しは重要な機能となりますので，しっかりと身に付けましょう．

準備  Muエディタを起動したら，Python3 モードを選択しましょう． ツールバーにある「保存」をクリックして，「chapter3.py」という名前でスクリプトを保存します． また，Turtleグラフィックスのライブラリ（モジュール）をインポートしておきましょう．
# Turtleグラフィックスのライブラリをインポート from turtle import * 変数  算術演算子 変数を理解する前にPythonで利用可能な算術演算について確認しましょう． 数値を対象に加算・減算などの算術演算を行うには算術演算子を用います． 算術演算子を次の表にまとめます． print()で各算術演算子の結果を表示してみましょう．
   演算子 説明 例     + 加算 3+2 -&amp;gt; 5   - 減算 3-2 -&amp;gt; 1   * 乗算 3*2 -&amp;gt; 6   / 除算 3/2 -&amp;gt; 1.</description>
    </item>
    
    <item>
      <title>Turtleグラフィックス① Turtleグラフィックスの基本</title>
      <link>https://mukai-lab.info/pages/classes/programming/chapter2/</link>
      <pubDate>Sun, 13 Feb 2022 15:05:54 +0900</pubDate>
      
      <guid>https://mukai-lab.info/pages/classes/programming/chapter2/</guid>
      <description>Turtleグラフィックス  Turtleグラフィックスは， タートル（Turtle）と呼ばれるカーソルを動かしてベクトル・グラフィックを描画するためのライブラリ（モジュール）です． 1967年にSeymour Papert氏らが， Logoと呼ばれる教育用プログラミング言語の機能の一つとして導入しました． Turtleグラフィックスは，Pythonの標準ライブラリとしても導入されており，Pythonの初学者向けのツールとして利用されます． 標準的なTurtleグラフィックスは2次元の直交座標系（XY平面）に描画しますが， 3次元に拡張されたCheloniidae Turtle Graphicsなども存在します． 本授業ではTurtleグラフィックスを利用して，Pythonの制御構文や関数など学習していきましょう．
準備  Muエディタを起動したら，Python3 モードを選択しましょう． ツールバーにある「保存」をクリックして，「chapter2.py」という名前でスクリプトを保存します．
MuエディタでTurtleグラフィックスを利用するには， 次のように記述してライブラリ（モジュール）を インポート（import） します． インポートとは「プログラムの中で利用可能な状態にする」ことを意味しています．
# Turtleグラフィックスのライブラリをインポート from turtle import * Turtleグラフィックスの使い方  ここでは，Turtleグラフィックスの基本的な使い方を学習しましょう．
タートルの位置と向き タートルの初期状態を確認します． position()はタートルの位置を表す関数， heading()はタートルの向き（角度）を表す関数です． これらの値をprint()でコンソールに出力します． 実行すると，タートルの座標は原点の(0.00,0.00)，向きは0度（右方向）であることがわかります（上方向は90度，左方向は180度，下方向は270度）．
print(position()) # タートルの座標 -&amp;gt; (0.00,0.00) print(heading()) # タートルの向き -&amp;gt; 0.0 コンソールへの出力だけでなく，タートルの描画結果を表すスクリーン（ウィンドウ）が表示されます． タートルは矢印で表され，スクリーンの中央（原点）に，右を向いた矢印が描画されていることがわかります．

タートルの前進 タートルを進行方向に前進させるにはforward()を用います． ()の中に記述する数値が，進む距離（単位はピクセル）を表します． ここでは，進行方向（右）に200だけ前進させてみましょう． タートルの座標は(200.00,0.00)になり，矢印が右方向に動くことが確認できます．
forward(200) # 200だけ前進 print(position()) # タートルの座標 -&amp;gt; (200.00,0.00) print(heading()) # タートルの向き -&amp;gt; 0.0</description>
    </item>
    
    <item>
      <title>コードエディタ「Mu」の確認</title>
      <link>https://mukai-lab.info/pages/classes/programming/chapter1/</link>
      <pubDate>Sat, 12 Feb 2022 12:08:50 +0900</pubDate>
      
      <guid>https://mukai-lab.info/pages/classes/programming/chapter1/</guid>
      <description>Muエディタとは  Muは，プログラミング言語であるPythonのソース・エディタです． シンプルなインターフェイスが特徴で，プログラミングの初学者に適した開発環境として人気があります． WindowsやMac OSのインストーラが公開されており，手軽にインストールすることが可能です． 開発目的に合わせた複数のモードが搭載されており，標準的な Python3 に加えて， ゲーム開発のための Pygame Zero ，教育用のマイコンであるmicro:bitの開発のための BBC micro:bit に切り替えてコーディングすることができます．

Muエディタの使い方  Muエディタの基本的な使い方を学習しましょう．
モードの選択 Muエディタを起動したら，モードを選択しましょう． ここでは，標準的なPythonをコーディングするための Python3 を選択します．

スクリプトの保存 ツールバーにある「保存」をクリックして，名前を付けてスクリプト（実行可能なファイル）を保存します． ここでは，「chapter1.py」という名前で保存しましょう． Pythonのスクリプトの拡張子は .py です． 保存したらエクスプローラーなどで，chapter1.pyがPCに正しく保存されているか確認してください．
文字列の出力 それでは，次のコードを入力してみましょう． print()はコンソールに文字列を出力するための命令文であり， Pythonで利用可能な 関数 という機能の一つです． ここでは，「Hello World」という文字列をコンソールに出力しています． 出力する文字列は「&amp;quot;&amp;quot;（ダブルクオーテーション）」，または，「&#39;&#39;（シングルクオーテーション）」で囲む必要があることに注意してください．
print(&amp;#34;Hello World&amp;#34;) # print(&amp;#39;Hello World&amp;#39;)でもOK 
ツールバーにある「実行」をクリックして，スクリプトを実行します． 実行すると画面下部にコンソールが表示され，「Hello World」と出力されていることが確認できます． 実行結果を確認したら，ツールバーにある「停止」をクリックします．

計算結果の出力 次に，次のコードを入力してみましょう． ここでは，$1+2$という足し算の結果を，print()でコンソールに出力しています． 文字列ではなく数値を対象にするときは，ダブルクオーテーションやシングルクオーテーションは不要です．
print(1+2) 
ツールバーにある「実行」をクリックして，スクリプトを実行します． 実行すると画面下部にコンソールが表示され，「3」と出力されていることが確認できます． 実行結果を確認したら，ツールバーにある「停止」をクリックします．

コメント 記述したコードを一時的に無効にするには コメント を利用します． 記述されたコードの先頭に#を記述することで，コメントとしてみなされ， コードはスキップされ実行されなくなります． コメントを利用して，コードの説明文を記載しておくと，後で読み返したとき理解しやすくなるでしょう．</description>
    </item>
    
    <item>
      <title>Monacaアプリの開発⑤ Chart.jsの利用</title>
      <link>https://mukai-lab.info/pages/classes/graduation_preperation_1/chapter2_5/</link>
      <pubDate>Sat, 11 Dec 2021 18:59:56 +0900</pubDate>
      
      <guid>https://mukai-lab.info/pages/classes/graduation_preperation_1/chapter2_5/</guid>
      <description>Chart.js  Chart.jsは，グラフ（チャート）を表示するためのオープンソースのJavaScriptライブラリです． 任意のデータを用いて，線グラフ（Line Chat）や棒グラフ（Bar Chart）など，8種類のグラフを生成することができます． レスポンシブ・デザインにも対応しており，ディスプレイのサイズに合わせて自動的にグラフのサイズも調整される仕組みとなっています． Monacaで利用するには，JS/CSSコンポーネントをクリックして，chart.jsのライブラリをプロジェクトに追加します． ただし，chart.jsのバージョンは，3.xではなく，2.9.4を選択するようにしてください． このとき，次のファイルを選択してインストールします（CDNで設定しても構いません）．
 components/chart.js/dist/Chart.js  また，適切なグラフの色を自動的に設定するために，chartjs-plugin-colorschemeプラグインもプロジェクトに追加します． このとき，次のファイルを選択してインストールします（CDNで設定しても構いません）．
 components/chartjs-plugin-colorschemes/dist/chartjs-plugin-colorschemes.js  
プロジェクトの作成  新規にプロジェクトを作成します． テンプレートは前回と同じ Onsen UI V2 Vue Minimum を選択しましょう．

プロジェクト名に「Monacaでアプリ開発⑤」，説明に「Chart.jsの利用」を設定しましょう．

テンプレートの確認  クラウドIDEを起動し，テンプレートの/src/App.vueを確認します．
HTML v-ons-toolbarの次にあるdiv要素とp要素を削除しておきます．
&amp;lt;template&amp;gt; &amp;lt;v-ons-page&amp;gt; &amp;lt;v-ons-toolbar&amp;gt; &amp;lt;div class=&amp;#34;center&amp;#34;&amp;gt;{{ title }}&amp;lt;/div&amp;gt; &amp;lt;div class=&amp;#34;right&amp;#34;&amp;gt; &amp;lt;v-ons-toolbar-button&amp;gt; &amp;lt;v-ons-icon icon=&amp;#34;ion-navicon, material: md-menu&amp;#34;&amp;gt;&amp;lt;/v-ons-icon&amp;gt; &amp;lt;/v-ons-toolbar-button&amp;gt; &amp;lt;/div&amp;gt; &amp;lt;/v-ons-toolbar&amp;gt; &amp;lt;!-- 削除 --&amp;gt; &amp;lt;/v-ons-page&amp;gt; &amp;lt;/template&amp;gt; &amp;lt;script&amp;gt; /* JavaScriptのコード */ &amp;lt;/script&amp;gt; JavaScript titleを グラフアプリ に設定します． methodsオプションの内容を削除しておきます．</description>
    </item>
    
    <item>
      <title>Monacaアプリの開発④ Leafletの利用</title>
      <link>https://mukai-lab.info/pages/classes/graduation_preperation_1/chapter2_4/</link>
      <pubDate>Sun, 28 Nov 2021 20:01:21 +0900</pubDate>
      
      <guid>https://mukai-lab.info/pages/classes/graduation_preperation_1/chapter2_4/</guid>
      <description>Leaflet  Leafletは，ウェブ地図を表示するためのオープンソースのJavaScriptライブラリです． OpenStreetMapやMapboxのタイル地図を表示させることができます． Monacaで利用するには，JS/CSSコンポーネントをクリックして，Leafletのライブラリをプロジェクトに追加します． このとき，次の2つのファイルを選択してインストールします（CDNで設定しても構いません）．
 JavaScript: components/Leaflet/dist/leaflet.js CSS: components/Leaflet/dist/leaflet.css  
プロジェクトの作成  新規にプロジェクトを作成します． テンプレートは前回と同じ Onsen UI V2 Vue Minimum を選択しましょう．

プロジェクト名に「Monacaでアプリ開発④」，説明に「Leafletの利用」を設定しましょう．

テンプレートの確認  クラウドIDEを起動し，テンプレートの/src/App.vueを確認します．
HTML v-ons-toolbarの次にあるdiv要素とp要素を削除しておきます．
&amp;lt;template&amp;gt; &amp;lt;v-ons-page&amp;gt; &amp;lt;v-ons-toolbar&amp;gt; &amp;lt;div class=&amp;#34;center&amp;#34;&amp;gt;{{ title }}&amp;lt;/div&amp;gt; &amp;lt;div class=&amp;#34;right&amp;#34;&amp;gt; &amp;lt;v-ons-toolbar-button&amp;gt; &amp;lt;v-ons-icon icon=&amp;#34;ion-navicon, material: md-menu&amp;#34;&amp;gt;&amp;lt;/v-ons-icon&amp;gt; &amp;lt;/v-ons-toolbar-button&amp;gt; &amp;lt;/div&amp;gt; &amp;lt;/v-ons-toolbar&amp;gt; &amp;lt;!-- 削除 --&amp;gt; &amp;lt;/v-ons-page&amp;gt; &amp;lt;/template&amp;gt; &amp;lt;script&amp;gt; /* JavaScriptのコード */ &amp;lt;/script&amp;gt; JavaScript titleを 地図アプリ に設定します． methodsオプションの内容を削除しておきます．
export default{ data() { return { title: &amp;#39;地図アプリ&amp;#39; }; }, methods: { // 削除  } }; 地図アプリの開発  Leafletを利用した地図アプリを開発します． 地図には日進市のオープンデータを利用して， 日進市の教育機関や医療機関をマーカーとして表示します．</description>
    </item>
    
    <item>
      <title>Monacaでアプリ開発③ v-forとv-ifの利用</title>
      <link>https://mukai-lab.info/pages/classes/graduation_preperation_1/chapter2_3/</link>
      <pubDate>Sun, 28 Nov 2021 10:43:54 +0900</pubDate>
      
      <guid>https://mukai-lab.info/pages/classes/graduation_preperation_1/chapter2_3/</guid>
      <description>v-forとv-if  Vue.js には，プログラミングの制御構文によく似た機能があります．
v-forディレクティブは，リストレンダリングと呼ばれ， 配列や連想配列の要素を繰り返して処理することができます． 次の例では，配列itemsの要素を繰り返して，li要素を作成します
&amp;lt;ul&amp;gt; &amp;lt;!-- 配列itemsの要素を繰り返す --&amp;gt; &amp;lt;li v-for=&amp;#34;item in items&amp;#34;&amp;gt; {{ item }} &amp;lt;/li&amp;gt; &amp;lt;/ul&amp;gt; v-ifディレクティブは，条件付きレンダリングと呼ばれ， 条件に応じた分岐が可能です． 次の例では，変数flagがtrueのときTrueです，falseのときFalseですと表示します．
&amp;lt;!-- 変数flagがTrueのとき --&amp;gt; &amp;lt;h1 v-if=&amp;#34;flag&amp;#34;&amp;gt;Trueです&amp;lt;/h1&amp;gt; &amp;lt;!-- 変数flagがFalseのとき --&amp;gt; &amp;lt;h1 v-else&amp;gt;Falseです&amp;lt;/h1&amp;gt; プロジェクトの作成  新規にプロジェクトを作成します． テンプレートは前回と同じ Onsen UI V2 Vue Minimum を選択しましょう．

プロジェクト名に「Monacaでアプリ開発③」，説明に「v-forとv-ifの利用」を設定しましょう．

テンプレートの確認  クラウドIDEを起動し，テンプレートの/src/App.vueを確認します．
HTML v-ons-toolbarの次にあるdiv要素とp要素を削除しておきます．
&amp;lt;template&amp;gt; &amp;lt;v-ons-page&amp;gt; &amp;lt;v-ons-toolbar&amp;gt; &amp;lt;div class=&amp;#34;center&amp;#34;&amp;gt;{{ title }}&amp;lt;/div&amp;gt; &amp;lt;div class=&amp;#34;right&amp;#34;&amp;gt; &amp;lt;v-ons-toolbar-button&amp;gt; &amp;lt;v-ons-icon icon=&amp;#34;ion-navicon, material: md-menu&amp;#34;&amp;gt;&amp;lt;/v-ons-icon&amp;gt; &amp;lt;/v-ons-toolbar-button&amp;gt; &amp;lt;/div&amp;gt; &amp;lt;/v-ons-toolbar&amp;gt; &amp;lt;!-- 削除 --&amp;gt; &amp;lt;/v-ons-page&amp;gt; &amp;lt;/template&amp;gt; &amp;lt;script&amp;gt; /* JavaScriptのコード */ &amp;lt;/script&amp;gt; JavaScript titleを メモアプリ に設定します． methodsオプションの内容を削除しておきます．</description>
    </item>
    
    <item>
      <title>Monacaでアプリ開発② Onsen UIの利用</title>
      <link>https://mukai-lab.info/pages/classes/graduation_preperation_1/chapter2_2/</link>
      <pubDate>Fri, 26 Nov 2021 10:43:16 +0900</pubDate>
      
      <guid>https://mukai-lab.info/pages/classes/graduation_preperation_1/chapter2_2/</guid>
      <description>Onsen UI  Onsen UIは，ウェブアプリのためのUIコンポーネントを提供するライブラリです． UIコンポーネントには，ボタンやフォームだけでなく，タブ，サイドメニュー，ナビゲーションなどのデザインも含まれています． また，フレームワークのVue.jsに特化したコンポーネントが用意されており， サンプルを参考に実装することで，手軽にオシャレなウェブアプリを制作することができます． ここでは，下記のUIコンポーネントを利用してみます．
 v-ons-card v-ons-list v-ons-button v-ons-icon  プロジェクトの作成  新規にプロジェクトを作成します． テンプレートは前回と同じ Onsen UI V2 Vue Minimum を選択しましょう．

プロジェクト名に「Monacaでアプリ開発②」，説明に「Onsen UIの利用」を設定しましょう．

テンプレートの確認  クラウドIDEを起動し，テンプレートの/src/App.vueを確認します．
HTML v-ons-toolbarの次にあるdiv要素とp要素を削除しておきます．
&amp;lt;template&amp;gt; &amp;lt;v-ons-page&amp;gt; &amp;lt;v-ons-toolbar&amp;gt; &amp;lt;div class=&amp;#34;center&amp;#34;&amp;gt;{{ title }}&amp;lt;/div&amp;gt; &amp;lt;div class=&amp;#34;right&amp;#34;&amp;gt; &amp;lt;v-ons-toolbar-button&amp;gt; &amp;lt;v-ons-icon icon=&amp;#34;ion-navicon, material: md-menu&amp;#34;&amp;gt;&amp;lt;/v-ons-icon&amp;gt; &amp;lt;/v-ons-toolbar-button&amp;gt; &amp;lt;/div&amp;gt; &amp;lt;/v-ons-toolbar&amp;gt; &amp;lt;!-- 削除 --&amp;gt; &amp;lt;/v-ons-page&amp;gt; &amp;lt;/template&amp;gt; &amp;lt;script&amp;gt; /* JavaScriptのコード */ &amp;lt;/script&amp;gt; JavaScript titleを アルバム に設定します． methodsオプションの内容を削除しておきます．
export default{ data() { return { title: &amp;#39;アルバム&amp;#39; }; }, methods: { // 削除  } }; アルバムアプリの開発  動物を紹介するアルバムアプリを開発します． かわいいフリー素材集 いらすとやで公開されている次のイヌとネコの画像を利用します． ファイルをダウンロードして，dog.</description>
    </item>
    
    <item>
      <title>Monacaでアプリ開発① Vue.jsの利用</title>
      <link>https://mukai-lab.info/pages/classes/graduation_preperation_1/chapter2_1/</link>
      <pubDate>Thu, 25 Nov 2021 18:07:40 +0900</pubDate>
      
      <guid>https://mukai-lab.info/pages/classes/graduation_preperation_1/chapter2_1/</guid>
      <description>Monaca  Monacaは，HTML5でアプリを作成するための開発プラットフォームです． PCで動作するウェブアプリだけでなく，AndroidやiOSで動作するスマートフォン・アプリを開発することができます． クラウドベースの開発環境が利用できるため，ブラウザ（Chrome）さえあれば気軽にアプリ開発に挑戦できます． また，スマートフォンにMonaca Debuggerをインストールすることで， スマートフォン・アプリとしての動作を確認することができます． Monacaをプログラミング教育に用いるMonaca Educationのプランも提供されており， 導入校一覧に椙山女学園大学も掲載されています． Monacaを利用した開発を始める前に下記の準備をしましょう．
 Monacaのアカウントの取得（Googleアカウントでも利用可） Monaca Debuggerのスマートフォン（Android，iOS）へのインストール  Vue.js  Vue.jsは，ウェブアプリを制作するためのJavaScriptフレームワークです． JavaScriptのみでスクラッチから開発するよりも，効率的に開発が可能です． 従来はjQueryと呼ばれるJavaScriptライブラリが広く用いられてきましたが， 近年はVue.jsに代表されるJavaScriptフレームワークが採用されるようになりました． Monacaでは，Vue.jsに加え，AngularやReactなどのフレームワークが利用可能ですが， その中でもVue.jsは，初学者にとっても扱いやすいフレームワークとして人気があります． そこで，この授業ではVue.jsを利用したアプリの開発を目標とします．
プロジェクトの作成  準備が出来たら，早速，Monacaにアクセスしましょう． まず最初に，新規にプロジェクトを作成します． 下記の手順に従って，Vue.jsを利用したテンプレートで開発を始めます．
テンプレートの種類 フレームワークテンプレート を選択しましょう．

フレームワーク Vue.js を選択しましょう．

テンプレート Onsen UI V2 Vue Minimum を選択しましょう．

プロジェクトの情報 プロジェクト名 に「Monacaでアプリ開発①」， 説明 に「Vue.jsの利用」を設定しましょう．

テンプレートの確認  プロジェクトを作成したら，クラウドIDE で開きます． 最初に /src/App.vue を確認しましょう． App.vue は 単一ファイルコンポーネント（SFC: Single File Component） と呼ばれ， HTML，CSS，JavaScriptをまとめて記述することが可能なファイルです． このテンプレートでは，&amp;lt;template&amp;gt;&amp;lt;/template&amp;gt;がHTML，&amp;lt;script&amp;gt;&amp;lt;/script&amp;gt;がJavaScriptで記述されています．</description>
    </item>
    
    <item>
      <title>リッジ回帰とラッソ回帰</title>
      <link>https://mukai-lab.info/pages/classes/intelligence_information_system/chapter6/</link>
      <pubDate>Tue, 26 Oct 2021 15:46:23 +0900</pubDate>
      
      <guid>https://mukai-lab.info/pages/classes/intelligence_information_system/chapter6/</guid>
      <description>ノートブックの作成  Colabにアクセスし，新規にノートブックを作成してください． ノートブックのタイトルは chapter6 とします． また，numpy，random, matplotlib.pyplot，scipy.optimizeを導入しておいてください．
import numpy as np import random import matplotlib.pyplot as plt from scipy.optimize import minimize オーバーフィッティング（過学習）  オーバーフィッティング とは 過学習 または 過剰適合 と呼ばれることもある現象で， サンプルデータに過剰に適合してしまい， データ全体に対しての汎用的な能力を失った状態を指します． ここでは，回帰問題を例に挙げて，オーバーフィッティングを再現してみましょう．
ここでは，$x^3 - 2x$にノイズとなる乱数を加えた40点のデータを生成します．
x = np.array([-2. ,-1.9,-1.8,-1.7,-1.6,-1.5,-1.4,-1.3,-1.2,-1.1,-1. ,-0.9,-0.8,-0.7, -0.6,-0.5,-0.4,-0.3,-0.2,-0.1, 0. , 0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9, 1. , 1.1, 1.2, 1.3, 1.4, 1.5, 1.6, 1.7, 1.8, 1.9]) y = np.array([-3.75,-2.28,-1.16,-1.08,-0.89,-0.08, 0.58, 1.69, 1.</description>
    </item>
    
    <item>
      <title>Kaggle②・コンペに挑戦しよう！</title>
      <link>https://mukai-lab.info/pages/classes/intelligence_information_system/chapter15/</link>
      <pubDate>Mon, 27 Sep 2021 12:13:13 +0900</pubDate>
      
      <guid>https://mukai-lab.info/pages/classes/intelligence_information_system/chapter15/</guid>
      <description>ノートブックの作成  Colabにアクセスし，新規にノートブックを作成してください． ノートブックのタイトルは chapter15 とします．
パラメータの最適化  機械学習モデルの精度を向上させるには，パラメータの最適化（チューニング）が欠かせません． 例えば，決定木では，分割基準（gini or entropy），木の最大の深さ（max_depth）， 分割可能な最小ノード数（min_samples_split）などが挙げられます． これらのパラメータは ハイパーパラメータ と呼ばれ， 最適化することで最大のパフォーマンスを発揮することができます． ここでは，ハイパーパラメータの 自動最適化フレームワークであるOptunaを取り上げます． このフレームワークは，日本企業のPreferred Networksが開発しており， 国内外の様々なプロジェクトで導入されています．
Optunaをインストールして，必要なライブラリを導入します． ここで，mplot3dは， 散布図や曲面などを3次元空間にプロットするためのライブラリです．
!pip install optuna import optuna import matplotlib.pyplot as plt import numpy as np from mpl_toolkits.mplot3d import Axes3D Optunaで最適化する関数$f(x,y)$を定義します． この関数を最小化するパラメータ$x$と$y$を探索します．
$$ f(x, y) = x^2 + y^2 $$
# 関数f(x, y)を定義 def f(x, y): return x**2 + y**2 関数$f(x)$を3次元空間にプロットします． 図から分かるように，この問題の最適解は$x=0$，$y=0$です．
# 関数f(x, y)の可視化 x_list = np.</description>
    </item>
    
    <item>
      <title>Kaggle①・タイタニック号の生存予測</title>
      <link>https://mukai-lab.info/pages/classes/intelligence_information_system/chapter14/</link>
      <pubDate>Sun, 26 Sep 2021 11:38:16 +0900</pubDate>
      
      <guid>https://mukai-lab.info/pages/classes/intelligence_information_system/chapter14/</guid>
      <description>Kaggleとは  Kaggle はGoogle傘下のAlphabet社が手掛ける予測モデリングのコンペティションです． 「タイタニック号の予測」など様々なコンペティションが提供されており， なかには多額の賞金や景品が懸けられているコンペティションもあります． 科学者やエンジニアなど，様々な分野の人が登録しており， 機械学習やデータサイエンスなどのアプローチで問題を解くことに挑戦しています． ここでは，Kaggleの基本的な使い方を学習し，「タイタニック号の予測」に挑戦してみます． 下記のURLからKaggleにアクセスし，大学のGmailアカウントでログインしてください．
  https://www.kaggle.com/  ノートブックの作成  Colabにアクセスし，新規にノートブックを作成してください． ノートブックのタイトルは chapter14 とします． また，下記のライブラリを導入しておいてください．
!pip install japanize-matplotlib import numpy as np import pandas as pd import matplotlib.pyplot as plt import japanize_matplotlib from sklearn import tree from sklearn.tree import plot_tree タイタニック号の生存予測  「タイタニック号の生存予測（Titanic - Machine Learning from Disaster）」に挑戦してみましょう． このコンペの目的は，タイタニック号の乗客の属性（性別，年齢など）から，生存を予測することです． Kaggleの導入に最適なコンペとされています．
  https://www.kaggle.com/c/titanic  データ 上述したように，タイタニック号の乗客の属性（性別，年齢など）から，生存を予測します． ここでは，次に挙げる属性を利用します．
 PassengerId（乗客ID） Survived（1:生存，0:死亡） Pclass（チケットクラス 1:1st，2:2nd，3:3rd） Sex（性別 male:男性 female:女性） Age（年齢） SibSp（同乗している兄弟/配偶者の数） Parch（同乗している親/子供の数） Fare（料金） Embarked（出港地）  予測に用いるデータは次の3種類です． Kaggleからダウンロードしておきましょう． 決定木などの機械学習モデルを train.</description>
    </item>
    
    <item>
      <title>Pythonの基礎・フラクタル図形を描いてみよう</title>
      <link>https://mukai-lab.info/pages/classes/seminar_core_areas_learning/chapter_3_4/</link>
      <pubDate>Sat, 04 Sep 2021 10:04:02 +0900</pubDate>
      
      <guid>https://mukai-lab.info/pages/classes/seminar_core_areas_learning/chapter_3_4/</guid>
      <description>フラクタル図形  フラクタル図形 とは，図形の一部が図形の全体と 自己相似 な関係を持つ図形のことです． 特定の処理を再帰的に繰り返して実行することで描くことができます． フラクタル図形は自然界でも観測が可能で，「シダの葉」や「雲の形」はフラクタル図形とされています． ここでは，Pythonの関数の再帰を利用して，コッホ曲線を描くことに挑戦します．

Google Colaboratory  下記のリンクをクリックして，Colabにアクセスしましょう．
  Google Colaboratory  Colabにアクセスしたら，大学のGmailアカウント（@g.sugiyama-u.ac.jp）でログインしていることを確認してください． 次に，ノートブック（ファイル）を新規作成し，ノートブックの名前を chapter4.ipynb に変更しましょう．

加えて，前回と同様に，ColabTurtleとインストールしておきます． このとき，多次元配列の処理が可能なライブラリである numpy も追加しておきます．
!pip install ColabTurtle from ColabTurtle.Turtle import * import numpy as np フラクタル図形の描画  フラクタル図形の一つであるコッホ曲線を描きます． コッホ曲線は与えられた線分を3等分し，分割した2点を頂点とする正三角形を作成する手続きを繰り返すことで得られます．

コッホ曲線を描く関数はdrawKochですが，この関数の中でkochを再帰的に呼び出しています（つまりkochの中で，kochを呼び出す）． drawKochの引数は，再帰の次元数（dim），線分の両端の座標（p1とp2）です． 再帰の次元数とは，再帰を繰り返す回数であり，この値が1になるまで繰り返します． 例えば，dim=2で呼び出すと，再帰的にdim=1が4回呼び出さて終了します（4つの直線に分割されるため）．

def drawKoch(dim, p1, p2): points = [] initializeTurtle() speed(8) penup() goto(p1[0], p1[1]) right(90) koch(dim, p1, p2) def koch(dim, p1, p2): p = np.</description>
    </item>
    
    <item>
      <title>Pythonの基礎・関数で図形を描いてみよう</title>
      <link>https://mukai-lab.info/pages/classes/seminar_core_areas_learning/chapter_3_3/</link>
      <pubDate>Sat, 04 Sep 2021 10:04:02 +0900</pubDate>
      
      <guid>https://mukai-lab.info/pages/classes/seminar_core_areas_learning/chapter_3_3/</guid>
      <description>関数  関数 を定義することで，特定の処理に名前を付けて，呼び出すことができます． 関数は，あらかじめ定義されている 組み込み関数 に加え，ユーザ自身が独自に定義することも可能です． 例えば，組み込み関数には下記のような関数があります．
 print関数（コンソールに出力する） max関数（最大値を算出する） min関数（最小値を算出する） abs関数（絶対値を算出する）  
何度も繰り返して実行する処理は，関数として定義することで，スッキリと記述することができます． ここでは，関数を利用して，効率的に図形を描くことに挑戦しましょう．
Google Colaboratory  下記のリンクをクリックして，Colabにアクセスしましょう．
  Google Colaboratory  Colabにアクセスしたら，大学のGmailアカウント（@g.sugiyama-u.ac.jp）でログインしていることを確認してください． 次に，ノートブック（ファイル）を新規作成し，ノートブックの名前を chapter3.ipynb に変更しましょう．

加えて，前回と同様に，ColabTurtleとインストールしておきます． このとき，多次元配列の処理が可能なライブラリである numpy も追加しておきます．
!pip install ColabTurtle from ColabTurtle.Turtle import * import numpy as np 関数を利用した図形  関数の定義 関数を定義するには，defの位置から，字下げ して実行する処理を記述します． ここでは，ランダムにペンの色を変更して，カメを直進させる処理を，forward_random_colorという名前の関数として定義しましょう．
def 関数名（）: 実行する処理 ペンの色を指定するcolor()は，redやblueなどの色名を指定する他にも， r（赤），g（緑），b（青）の色成分を指定することができます． ここでは，np.random.randint(0, 256)を利用して，0〜255までの乱数を生成し， この乱数をペンの色成分に指定します．
def forward_random_color(): r = np.random.randint(0, 256) g = np.random.randint(0, 256) b = np.</description>
    </item>
    
    <item>
      <title>Pythonの基礎・制御構文で図形を描いてみよう</title>
      <link>https://mukai-lab.info/pages/classes/seminar_core_areas_learning/chapter_3_2/</link>
      <pubDate>Sat, 04 Sep 2021 10:03:57 +0900</pubDate>
      
      <guid>https://mukai-lab.info/pages/classes/seminar_core_areas_learning/chapter_3_2/</guid>
      <description>制御構文とは  プログラムの実装には 「繰り返し」や「条件分岐」と呼ばれる制御が用いられ， これらを記述するための命令文が 制御構文 です． Pythonでは，「繰り返し」を記述するための命令文が for文であり， 「条件分岐」を記述するための命令文が if文 です． Turtleグラフィックスに制御構文を組み合わせることで， より複雑な図形を描画することが可能です． ここでは，渦巻状の図形や円の描画に挑戦してみましょう．
Google Colaboratory  下記のリンクをクリックして，Colabにアクセスしましょう．
  Google Colaboratory  Colabにアクセスしたら，大学のGmailアカウント（@g.sugiyama-u.ac.jp）でログインしていることを確認してください． 次に，ノートブック（ファイル）を新規作成し，ノートブックの名前を chapter2.ipynb に変更しましょう．

加えて，前回と同様に，ColabTurtleとインストールしておきます． このとき，算術計算のためのライブラリである math も追加しておきます．
!pip install ColabTurtle from ColabTurtle.Turtle import * import math for文で繰り返し  for文の記述方法 for文は特定の処理を指定した回数だけ繰り返したいときに用います． このとき，繰り返しの対象となる処理は，forの位置から，字下げ する必要があります． Colabで字下げするには，キーボードの Tabキー を押します．
for i in range(繰り返す回数): 繰り返す対象となる処理 for文を利用した描画 ここでは，亀を$50$だけ直進させる処理（forward(50））を，10回繰り返します． この結果，亀は初期値の座標$(100, 250)$から$500$だけ右に移動した座標$(600, 250)$に移動します．
initializeTurtle() penup() goto(100, 250) right(90) pendown() for i in range(10): forward(50) penup()</description>
    </item>
    
    <item>
      <title>Pythonの基礎・Turtleで図形を描いてみよう</title>
      <link>https://mukai-lab.info/pages/classes/seminar_core_areas_learning/chapter_3_1/</link>
      <pubDate>Sat, 04 Sep 2021 10:03:54 +0900</pubDate>
      
      <guid>https://mukai-lab.info/pages/classes/seminar_core_areas_learning/chapter_3_1/</guid>
      <description>Turtleグラフィックス  Turtleグラフィックスは， 1967年に教育向けに設計されたプログラミング言語 LOGOで実装された コンピュータ・グラフィックスの機能です． ユーザが記述したプログラムに応じて，亀（タートル） の形をしたカーソルを操作して， 自由にコンピュータ・グラフィックスを作成することが可能です． 近年，データ分析や人工知能（AI）などの分野で採用されるプログラミング言語Pythonにも， Turtleグラフィックスが標準ライブラリとして組み込まれており， Pythonの基礎を学ぶために利用されています． ここでは，将来，授業や研究でPythonを活用するための準備として， TurtleグラフィックスでPythonの基礎を学びましょう．
Google Colaboratory  Pythonの開発環境として，Google Colaboratory（略称: Colab）を利用します． 下記のリンクをクリックして，Colabにアクセスしましょう．
  Google Colaboratory  Colabにアクセスしたら，大学のGmailアカウント（@g.sugiyama-u.ac.jp）でログインしていることを確認してください． 次に，ノートブック（ファイル）を新規作成し，ノートブックの名前を chapter1.ipynb に変更しましょう．

Colabの使い方 Colabではコードセルと呼ばれる入力フィールドにPythonのコードを入力します． コードセルを増やして，1+2，2*3，print(&amp;quot;Hello Turtle!&amp;quot;)と入力してみましょう． 入力したらコードセルの左端にある「セルを実行」をクリックします． 実行するとコードセルの実行結果である3，6，Hello Turtle!が出力されることが確認できます． printは文字を出力するためのPythonの命令文です． このように，適宜，コードセルを増やしながら，Pythonのコードを追加で記述して行きます．

ColabTurtleのインストール ColabでTurtleグラフィックスを利用するには， ColabTutrleというライブラリを利用します（Pythonの標準ライブラリとは異なるので注意）． このライブラリは MITライセンス が付与されたオープンソース・ソフトウェア（OSS）です． インストールするには下記のコードを，コードセルに入力します．
!pip install ColabTurtle from ColabTurtle.Turtle import * 図形の描画  Turtleグラフィックスを利用するための準備は整いました． 早速，様々な図形を描画して行きましょう．
正方形を描く まずは，正方形を描いてみましょう． 図形を描くときは，最初にinitializeTurtle()を実行し，カーソル（亀）の位置や向きを初期化します． 実行結果として，幅:$800$px，高さ:$500$pxのキャンバスが表示され， キャンバスの中央に上を向いた亀が表示されます． この亀を動かしながら図形を描画していきます．
initializeTurtle() 
ペンを上げたままで，亀を座標$(100, 400)$に移動し，ペンを下ろして，亀の進行方向（ここでは上方向）に$300$だけ移動させます． ペンを下ろした状態で亀を移動させると，その軌跡が線として描画されます． このとき，ペンを上げるにはpenup，亀を特定の座標に移動させるにはgoto， ペンを下ろすにはpendown，亀を進行方向に移動させるにはforwardを指示します． この結果，正方形の左側の辺が描画されます．</description>
    </item>
    
    <item>
      <title>どうせい（同姓）っちゅーの</title>
      <link>https://mukai-lab.info/posts/2021-08-05-comic_148/</link>
      <pubDate>Thu, 05 Aug 2021 19:17:56 +0900</pubDate>
      
      <guid>https://mukai-lab.info/posts/2021-08-05-comic_148/</guid>
      <description></description>
    </item>
    
    <item>
      <title>インデックス</title>
      <link>https://mukai-lab.info/pages/classes/database/chapter_extra2/</link>
      <pubDate>Fri, 25 Jun 2021 18:41:11 +0900</pubDate>
      
      <guid>https://mukai-lab.info/pages/classes/database/chapter_extra2/</guid>
      <description>インデックスとは  データベースの検索効率を向上させるために用いられるのが インデックス（索引） です． 一般にSQLiteなどのリレーショナル・データベースでは，インデックスは自動的に作成されますが， ユーザが意図してインデックスを作成するためのSQL文も用意されています． インデックスを作成する際の注意点を挙げます．
 データ量の多いデータベースにインデックス作成する（データが少ない場合はパフォーマンスが低下） カーディナリティ（属性に含まれる値のバリエーション）が高い属性でインデックスを作成する WHERE区の条件などに用いられる属性でインデックスを作成する．  ここでは，次の16のレコードを含むテーブルを例とします． ID と NAME の属性で構成され，主キーは ID です． このテーブルから Alex を検索するときのパフォーマンスを考えます．
   ID NAME     23 Chris   20 David   9 Greg   22 Allen   11 Carl   29 Rajiv   6 Jordan   4 Alex   26 Ashly   19 Nancy   2 Emily   27 Norma   18 Christine   28 Joy   12 Maria   3 Alice    インデックスはデータ構造に依存して，パフォーマンスが決まります． データベースでは，B木（B-tree） が用いられますが， ここでは比較のため 線形探索 と 2分探索木 を取り上げます．</description>
    </item>
    
    <item>
      <title>高次の正規化</title>
      <link>https://mukai-lab.info/pages/classes/database/chapter_extra1/</link>
      <pubDate>Tue, 22 Jun 2021 17:32:27 +0900</pubDate>
      
      <guid>https://mukai-lab.info/pages/classes/database/chapter_extra1/</guid>
      <description>高次の正規化  リレーショナルデータベースに関連する実際の業務では， これまでに紹介した第3正規形を満たすように情報無損失分解しておけば問題ありません． 一方で，厳密な設計が求められる場合，より高次の正規形を必要とするケースも考えられます． 高次の正規形は次に挙げる3つですが，ここでは第4正規形まで取り上げることにします．
 ボイス・コッド正規形 第4正規形 第5正規形  高次の正規形を説明する前に，第3正規形までを振り返っておきましょう．
第1正規形 第1正規形 は，ドメインがシンプルであることが条件です． ドメインが，「複数のドメインの直積」や，「あるドメインのべき集合」となっていることは認められません．
第１正規形   リレーション$R=(A_1, A_2, \cdots, A_n)$の各ドメインがシンプルであるとき第１正規形であるという．  第2正規形 第2正規形は，主キー以外の属性が，主キーに完全関数従属していることが条件です． 主キーが複数の属性で構成されているとき，主キーを構成する一部の属性に関数従属していることは認められません．
第2正規形   リレーション$R$が下記の条件を満たすとき 第2正規形 であるという．  $R$は第1正規形である． $R$の全ての非キー属性が，$R$の主キー（候補キー）に完全関数従属している．   第3正規形 第3正規形は，主キー以外の属性が，主キーに推移的に従属していないことが条件です（第2正規形は満たしているので，主キーに完全関数従属はしている）．
第3正規形   リレーション$R$が下記の条件を満たすとき 第3正規形 であるという．  $R$は第2正規形である． $R$の全ての非キー属性は，$R$の主キー（候補キー）に推移的に関数従属していない．   正規化の手順 次の【プロジェクトメンバー】を例に，第3正規形に変形してみましょう． このリレーションは，複数の企業から選抜された社員で構成されるプロジェクトのメンバーを表しています． 主キーは会社番号と社員番号のペアで構成され，社員は一つのプロジェクトに割り当てられます．
   会社番号 社員番号 氏名 業種 担当プロジェクト ターゲット     C01 E01 加藤淳 製造業 A 主婦層   C01 E02 青木健二 製造業 A 主婦層   C01 E03 鈴木由香 製造業 B 若年層   C02 E01 渡辺大樹 情報通信業 B 若年層   C02 E02 松本恭子 情報通信業 A 主婦層    【プロジェクトメンバー】</description>
    </item>
    
    <item>
      <title>人間ポナンザ</title>
      <link>https://mukai-lab.info/posts/2021-06-21-comic_147/</link>
      <pubDate>Mon, 21 Jun 2021 16:27:25 +0900</pubDate>
      
      <guid>https://mukai-lab.info/posts/2021-06-21-comic_147/</guid>
      <description></description>
    </item>
    
    <item>
      <title>探索木・ゲーム木</title>
      <link>https://mukai-lab.info/pages/classes/artificial_intelligence/chapter17/</link>
      <pubDate>Sun, 20 Jun 2021 09:08:29 +0900</pubDate>
      
      <guid>https://mukai-lab.info/pages/classes/artificial_intelligence/chapter17/</guid>
      <description>ゲーム木  これまでは8パズルやハノイの塔など1人のプレイヤーが解く問題を対象にしていました． ここでは，プレイヤーとコンピュータが対戦するオセロや将棋などの対戦形式のゲームについて考えましょう．
人間とコンピュータとの対戦 対戦形式のゲームは，従来から人工知能の研究テーマとして取り組まれています． これまでに，人間（プロ棋士）とコンピュターとの対戦がメディアにも取り上げられています． 1997年には，IBMのDeep Blueが当時のチェスのチャンピオンに勝利しました， 2013年には，山本一成氏が開発したPonanzaがプロ棋士に勝利したことが注目されました． さらに，2016年には，ディープラーニングを取り入れたDeepMindのAlphaGoがプロ棋士に勝利しました． このように，対戦形式のゲームでは，既にコンピュータ（AI）が人間を超えるようになっています．
    ゲーム 年 状況     オセロ 1980年 ムーアが世界チャンピオンの井上博に勝利   チェス 1997年 IBMのDeepBlueが世界チャンピオンのガルリ・カスパロフに勝利   将棋 2013年 山本一成が開発したPonanzaがプロ棋士の佐藤慎一に勝利   囲碁 2016年 DeepMindのAlphaGoがプロ棋士のイ・セドルに勝利    ゲーム木を利用した解の導出 対戦形式のゲームでは，プレイヤーの選択と，コンピュータの選択が交互に繰り返されます． このため，これまでの探索木では，適切な解を導出することができません． このような場合， ゲーム木（Game Tree） と呼ばれる手法が用いられます．
ゲーム木は次のような木構造で表されます． 木のルート（根）であるAはゲームの初期状態（盤面）であり，先手（黒）が手を打つ場面です． 先手が手を打つとBまたはCに遷移します． BとCは後手（白）が手を打つ場面です． 同様に，後手が手を打つと，BからD，E，F，また，CからG，H，I，のいずれかに遷移します． DからIは先手が手を打つ場面です． 最終的には，後手が手を打つ場面であるJからVに遷移します．
JからVの状態（盤面）には，先手がどれぐらい有利かを表す評価が与えられます （評価を決める評価関数はゲームによって異なり，開発者が最も頭を悩ませる部分です）． 例えば，Jは3，Kは2，Lは7となっています． 先手にとっては，A - B - D - Lと遷移すると，最も評価の高い 7 になりますが， 後手は先手の評価を下げようと手を打つため，実際はLに到達することはできません．</description>
    </item>
    
    <item>
      <title>MacOSのセットアップ</title>
      <link>https://mukai-lab.info/pages/tech/macos/macos/</link>
      <pubDate>Wed, 05 May 2021 12:55:43 +0900</pubDate>
      
      <guid>https://mukai-lab.info/pages/tech/macos/macos/</guid>
      <description>仮想デスクトップ  C - ↑でMission Control を開き，仮想デスクトップを追加する．  Dockの非表示  「Dockとメニューバー」で Dockを自動的に表示/非表示  ターミナルのテーマ  Icebergをインストール フォントは SF Mono Regular 14 がオススメ  Finderでホームディレクトリの表示  [Finder]-[環境設定]でホームディレクトリを表示  キーのリピート  キーのリピート 速い リピート入力認識までの時間 短い  HomeBrewのインストール  公式サイトからインストールする． インストール先のディレクトが /opt/homebrew/ の場合は.zshrcにPATHを設定  Gitのインストール $ brew install git  zshのターミナルにgitブランチの状態を表示 .ssh/id_rsa をコピーして配置  絶対やるべき！ターミナルでgitのブランチ名を表示&amp;amp;補完
PyEnvのインストール $ brew install pyenv $ pyenv install --list $ pyenv install 3.9.4 Hugoのインストール $ brew install hugo Gyazoのインストール  公式サイトからインストールする． 新OS Catalina にアップデートした際に、gyazoが動作しないを参考に画面収録を許可に設定する．  Tex（ptex2pdf）のインストール $ brew install --cask mactex-no-gui 環境変数PATHの設定も必要</description>
    </item>
    
    <item>
      <title>AIを活用したWebアプリ③・ハンドポーズの検出</title>
      <link>https://mukai-lab.info/pages/classes/applied_programming_wa/2020_chapter12/</link>
      <pubDate>Sun, 14 Mar 2021 13:22:18 +0900</pubDate>
      
      <guid>https://mukai-lab.info/pages/classes/applied_programming_wa/2020_chapter12/</guid>
      <description>CodePenの準備  CodePenにアクセスして，Penを作成し，タイトルを設定しましょう． Penのタイトルは「Chapter12」に設定しましょう．
 https://codepen.io/

前回と同様にp5.jsとml5.jsを導入しましょう．
https://unpkg.com/ml5@latest/dist/ml5.min.js 
ハンドポーズの検出  ml5.jsとp5.jsを 組み合わせて ハンドポーズの検出 にチャレンジします． 前回は画像から顔を検出しましたが，今回はWebカメラの映像からハンドポーズを検出します． Webカメラが利用可能なPC環境で実装してください．
HTMLに下記のコードを入力してください． 今回はp5.jsを利用するため，h1でタイトルのみを記述します．
&amp;lt;h1&amp;gt;ハンドポーズ認識&amp;lt;/h1&amp;gt; まずはWebカメラで撮影された映像を，createCapture() でキャプチャします． キャプチャされたフレームは通常の画像と同じように扱うことができます．
let video; function setup(){ createCanvas(640, 480); // ビデオのキャプチャ  video = createCapture(VIDEO); video.size(width, height); video.hide(); } function draw() { // キャプチャした画像を表示  image(video, 0, 0, width, height); } ml5.jsのハンドポーズ検出は MdiaPipe Handpose から移植されています． 手の指や関節の21点のランドマークを検出できます．
ハンドポーズ検出器を生成するには，ml5.handpose()を利用します． 第一引数は，キャプチャされたフレームvideo， 第二引数はモデルがロードされたタイミングで実行される無名関数です．
ハンドポーズのイベントはhandpose.on()で検出します． 第一引数は&amp;quot;predict&amp;quot;， 第二引数は検出結果を処理する無名関数を設定します． ここでは，検出結果が格納されたresultsを，predictionsに代入します． このpredictionsは配列であることに注意してください．
let video; let handpose; let predictions = []; function setup(){ createCanvas(640, 480); // ビデオのキャプチャ  video = createCapture(VIDEO); video.</description>
    </item>
    
    <item>
      <title>AIを活用したWebアプリ②・顔検出</title>
      <link>https://mukai-lab.info/pages/classes/applied_programming_wa/2020_chapter11/</link>
      <pubDate>Sun, 14 Mar 2021 11:18:11 +0900</pubDate>
      
      <guid>https://mukai-lab.info/pages/classes/applied_programming_wa/2020_chapter11/</guid>
      <description>p5.js  前回はml5.jsとjQueryを組み合わせた 画像分類 のWebアプリを作成しました． 今回はml5.jsで推奨されているp5.jsを組み合わせて 顔検出 のWebアプリを作成しましょう． p5.jsはプログラミング1で 取り組んだProcessingのJavaScript版です． Processingと同様にキャンバスに自由に図形やアニメーションを描画できます． 専用のオンライン・エディタもあるので， 自由に試してみると良いでしょう．
CodePenの準備  CodePenにアクセスして，Penを作成し，タイトルを設定しましょう． Penのタイトルは「Chapter11」に設定しましょう．
 https://codepen.io/

p5.jsと前回利用したml5.jsを導入しましょう． p5.jsのCDNはCodePenで検索すれば良いです．
https://unpkg.com/ml5@latest/dist/ml5.min.js 
顔検出  ml5.jsとp5.jsを 組み合わせて 顔検出 にチャレンジします． ここでは，下記の画像（face.jpg）に対して顔検出を適用してみます． 事前にダウンロードしておきましょう．

HTMLに下記のコードを入力してください． 今回はp5.jsを利用するため，h1でタイトルのみを記述します．
&amp;lt;h1&amp;gt;顔検出&amp;lt;/h1&amp;gt; ml5.jsの顔検出はface-api.jsを利用しています． ただし，表情（expression），年齢（age），性別（gender）の検出はできません．
最初に検出オプションを設定します． withLandmarksをtrueに設定すると68点のランドマークを検出します． また，withDescriptorsをtrueに設定すると128次元の特徴ベクトルを抽出します． ここでは，ランドマークのみを検出します．
ファイル選択ダイアログはcreateFileInput()で生成します． ファイルを選択するとhandleFile()が呼び出されます． 選択されたファイルのデータfile.dataから画像imgを生成します．
顔検出器を生成するにはml5.faceAPI()を利用します． 第一引数は検出オプションoptions，第二引数はモデルがロードされたタイミングで実行されるmodelReady()を設定します． 画像をimage()でキャンバスに描画した後で，顔検出をdetectSingle()で実行します． 第一引数は対象の画像img，第二引数は検出結果を処理する無名関数を設定します． 無名関数の引数は，エラーに関する情報を含むerrorと，分類結果を含むresultsです．
このresultsはJSON形式であることに注意してください． 検出された輪郭のデータはresults[&amp;quot;detection&amp;quot;]， ランドマークのデータはresults[&amp;quot;landmarks&amp;quot;]に格納されています． 輪郭はrect()でキャンバスに四角形として描画し， ランドマークはcircle()でキャンバスに円として描画します．
let input; let img; let faceapi; // 検出オプション let options = { withLandmarks: true, withDescriptors: false }; // 初期化 function setup(){ input = createFileInput(handleFile); // ファイル選択ダイアログ  createCanvas(600, 400); // キャンバス  rect(0, 0, width, height); //枠線 } // ファイル選択後の処理 function handleFile(file){ if (file.</description>
    </item>
    
    <item>
      <title>AIを活用したWebアプリ①・画像分類</title>
      <link>https://mukai-lab.info/pages/classes/applied_programming_wa/2020_chapter10/</link>
      <pubDate>Fri, 12 Mar 2021 21:18:36 +0900</pubDate>
      
      <guid>https://mukai-lab.info/pages/classes/applied_programming_wa/2020_chapter10/</guid>
      <description>ml5.js  JavaScriptの機械学習ライブラリml5.jsを利用したWebアプリを開発しましょう． ml5.jsは機械学習を教育を含む広い分野で利用してもらうことを目的として開発され， 学習済みの機械学習モデルを容易に導入することができます． 2018年から開発がスタートし，現在も積極的に更新が繰り返されています（2021年3月時点でVer.0.6.1）．
CodePenの準備  CodePenにアクセスして，Penを作成し，タイトルを設定しましょう． Penのタイトルは「Chapter10」に設定しましょう．
 https://codepen.io/

ml5.jsを導入するには，下記のURLをCDNに追加しましょう． jQueryも前回と同様に追加しておきます．
https://unpkg.com/ml5@latest/dist/ml5.min.js 
画像分類  ml5.jsを利用すると，画像認識，音声認識，自然言語処理など様々な機械学習を導入可能です． 今回は画像認識の一つである 画像分類 にチャレンジしましょう． 画像分類は，画像中にある物体が何であるかを分類する手法です． ここでは，下記の3種類の画像（dog.jpg, bus.jpg, flower.jpg）に対して画像分類を適用してみます． 事前にダウンロードしておきましょう．



HTMLに下記のコードを入力してください． ファイル選択ダイアログのinput，読み込んだ画像のプレビューを表示するimg， 分類結果を表示するdivを配置しています．
&amp;lt;h1&amp;gt;画像分類&amp;lt;/h1&amp;gt; &amp;lt;p&amp;gt;ファイルを選択してください．&amp;lt;/p&amp;gt; &amp;lt;input id=&amp;#34;image_file&amp;#34; type=&amp;#34;file&amp;#34;&amp;gt;&amp;lt;/input&amp;gt; &amp;lt;div&amp;gt; &amp;lt;img id=&amp;#34;preview&amp;#34; width=&amp;#34;400px&amp;#34;&amp;gt; &amp;lt;/div&amp;gt; &amp;lt;div id=&amp;#34;results&amp;#34;&amp;gt;&amp;lt;/div&amp;gt; JavaScriptに下記のコードを入力してください． ファイル選択ダイアログで画像ファイルが選択されたことを検知するchange()を利用しています． 選択された画像ファイルは，imgのsrc属性に設定されます．
$(function($){ // ファイル選択ダイアログの更新  $(&amp;#34;#image_file&amp;#34;).change(function(){ let image_file = $(&amp;#34;#image_file&amp;#34;)[0].files[0]; let fr = new FileReader(); fr.onload = () =&amp;gt; { // imgタグのsrc属性を設定  $(&amp;#34;#preview&amp;#34;).</description>
    </item>
    
    <item>
      <title>jQuery②・フォーム処理</title>
      <link>https://mukai-lab.info/pages/classes/applied_programming_wa/2020_chapter9/</link>
      <pubDate>Thu, 11 Mar 2021 15:51:16 +0900</pubDate>
      
      <guid>https://mukai-lab.info/pages/classes/applied_programming_wa/2020_chapter9/</guid>
      <description>CodePenの準備  CodePenにアクセスして，Penを作成し，タイトルを設定しましょう． Penのタイトルは「Chapter9」に設定しましょう．
 https://codepen.io/

今回もjQueryを導入します． CodePenの「Settings」をクリックし，「Pen Settings」を開きます． ここで，「jQuery」をキーワードに検索し，「Save &amp;amp; Close」をクリックします．

フォーム処理  テキストフィールドやラジオボタンに入力された値を処理しましょう．
テキストフィールドの処理 テキストフィールドに価格を入力し，ボタンをクリックすると消費税を計算します． HTMLに下記のコードを入力してください． テキストフィールドを作成するには，inputのtype属性をtextに設定します． pは計算結果を表示するために用います． divは複数の要素をグループとしてまとめるために用いられるブロック要素です． フォントやレイアウトを変更するような特殊な効果はありません．
&amp;lt;div&amp;gt; &amp;lt;p&amp;gt;価格を入力してください．&amp;lt;/p&amp;gt; &amp;lt;input id=&amp;#34;price&amp;#34; type=&amp;#34;text&amp;#34;&amp;gt;&amp;lt;/input&amp;gt;円 &amp;lt;button id=&amp;#34;bt_tax&amp;#34; type=&amp;#34;button&amp;#34;&amp;gt;消費税を計算&amp;lt;/button&amp;gt; &amp;lt;p id=&amp;#34;tax&amp;#34;&amp;gt;&amp;lt;/p&amp;gt; &amp;lt;/div&amp;gt; ボタンのイベント処理は前回説明したようにon()を利用します． テキストフィールドに入力された値はval()で取得することが出来ます． この値に0.1を掛け算し，消費税（税率10%）を求めます． 計算結果はtext()で設定しています．
$(&amp;#34;#bt_tax&amp;#34;).on(&amp;#34;click&amp;#34;, function(){ let price = $(&amp;#34;#price&amp;#34;).val(); let tax = price * 0.1; $(&amp;#34;#tax&amp;#34;).text(tax + &amp;#34;円&amp;#34;); }); 例えば，テキストフィールドに1000を入力すると，十分の一の100が結果として出力されます．

ラジオボタンの処理 ラジオボタンで色を選択し，ボタンをクリックすると， ページ全体の文字色を選択した色に変更します． HTMLに下記のコードを入力してください． ラジオボタンを作成するには，inputのtype属性をradioに設定します． name属性はラジオボタンのグループを表し，同一のname属性から一つを選択できます（複数選択はできない）． value属性は，後述するval()で取得される値です． checkedは初期状態で選択されている項目を表します．
&amp;lt;div&amp;gt; &amp;lt;p&amp;gt;文字の色を選択してください．&amp;lt;/p&amp;gt; &amp;lt;input type=&amp;#34;radio&amp;#34; name=&amp;#34;color&amp;#34; value=&amp;#34;black&amp;#34; checked&amp;gt;黒&amp;lt;/input&amp;gt; &amp;lt;input type=&amp;#34;radio&amp;#34; name=&amp;#34;color&amp;#34; value=&amp;#34;red&amp;#34;&amp;gt;赤&amp;lt;/input&amp;gt; &amp;lt;input type=&amp;#34;radio&amp;#34; name=&amp;#34;color&amp;#34; value=&amp;#34;blue&amp;#34;&amp;gt;青&amp;lt;/input&amp;gt; &amp;lt;button id=&amp;#34;bt_color&amp;#34; type=&amp;#34;button&amp;#34;&amp;gt;文字色を変更&amp;lt;/button&amp;gt; &amp;lt;/div&amp;gt; チェックボックスを取得するにはname属性を用いて， input[name=color]と表現します． このとき，選択されている項目だけを取得したい場合は，:checkedを末尾に付けます． val()で色を表す文字列を取得し，これをcss()で文字の色に設定します．</description>
    </item>
    
    <item>
      <title>jQuery①・DOM操作</title>
      <link>https://mukai-lab.info/pages/classes/applied_programming_wa/2020_chapter8/</link>
      <pubDate>Mon, 08 Mar 2021 21:45:27 +0900</pubDate>
      
      <guid>https://mukai-lab.info/pages/classes/applied_programming_wa/2020_chapter8/</guid>
      <description>jQuery  JavaScriptにライブラリを導入することで，様々な機能を追加することができます． JQueryは，JavaScriptのライブラリの一つであり， John Resig氏が2006年に開発したことで知られています． MITライセンスで公開されており，商用・非商用を問わず誰もが利用可能です．
近年はVue.js，AngularJSなど， JavaScriptフレームワーク と呼ばれる技術が注目され，jQueryの代替として採用されるケースが増えてきました． それでも，jQueryは簡単に導入が可能であることに加え，学習コストも低いため， フロントエンド開発の選択肢として十分に価値があります．
jQueryは主に下記を実現するために用いられます． DOMはHTMLを文書ツリーとして表現したモデルであり，jQueryで要素の作成・追加・削除が可能です（詳細は後述）． また，要素と同様にCSSの操作も可能です． さらに，ボタンやマウスのイベント処理に加え，サーバと非同期で通信する Ajax を簡潔に記述出来ます（APIの通信に用いることが多い）．
 DOMの操作 CSSの操作 ボタンやマウスのイベント処理 Ajax  DOM  DOM(Document Object Model) はHTMLの要素を木構造で表現・管理するためのモデルです（文書ツリー）． html要素が親ノード（ルートノード）になり，head要素やbody要素が子ノードとしてぶらさがっている構造です． jQueryでは，DOMの要素の生成や取得が可能であり，文書ツリーを自由に書き換えることができます．
&amp;lt;html&amp;gt; &amp;lt;head&amp;gt; &amp;lt;meta&amp;gt;&amp;lt;/meta&amp;gt; &amp;lt;title&amp;gt;&amp;lt;/title&amp;gt; &amp;lt;/head&amp;gt; &amp;lt;body&amp;gt; &amp;lt;h1&amp;gt;&amp;lt;/h1&amp;gt; &amp;lt;p&amp;gt;&amp;lt;/p&amp;gt; &amp;lt;/body&amp;gt; &amp;lt;/html&amp;gt; 
CodePenの準備  CodePenにアクセスして，Penを作成し，タイトルを設定しましょう． Penのタイトルは「Chapter8」に設定しましょう．
 https://codepen.io/

CodePenでjQueryを導入するには CDN(Content Delivery Network) を利用します． CDNはWebサイト上のコンテンツを効率的にユーザに配信する仕組みのことです． CodePenの「Settings」をクリックし，「Pen Settings」を開きます． ここで，「jQuery」をキーワードに検索し，「Save &amp;amp; Close」をクリックします． 2021年3月時点でのjQueryの最新バージョンは 3.6.0 です．

jQueryの基本  jQueryの基本的な使い方について解説します
HTMLの記述 HTMLに下記のコードを記述してください． id属性やclass属性が要素に設定されていることも確認してください．</description>
    </item>
    
    <item>
      <title>JavaScript⑤・オブジェクト指向</title>
      <link>https://mukai-lab.info/pages/classes/applied_programming_wa/chapter7/</link>
      <pubDate>Mon, 08 Mar 2021 15:26:46 +0900</pubDate>
      
      <guid>https://mukai-lab.info/pages/classes/applied_programming_wa/chapter7/</guid>
      <description>オブジェクト指向  JavaScriptはオブジェクト指向言語ですが，ES6以前は クラス という概念が存在せず， プロトタイプ と呼ばれる概念が用いられてきました． ES6では，クラス の概念が導入されるなど，オブジェクト指向の機能が大幅に改良され， JavaやC#などの他のプログラミング言語と同様なオブジェクト指向の実装が可能になりました． ここでは，ES6のオブジェクト指向に注目して解説します．
CodePenの準備  CodePenにアクセスして，Penを作成し，タイトルを設定しましょう． Penのタイトルは「Chapter7」に設定しましょう．
 https://codepen.io/

クラスの定義  オブジェクト指向は，その名が示しているように， 「もの（オブジェクト）」を基準として実装する考え方です． 一般に，オブジェクトの型となるのが，クラス とみなすことができます． ここでは，会話可能な Robot クラスを定義することを考えましょう．
クラスには，プロパティとメソッドを定義します． プロパティは，クラスに紐付けられた「変数」， メソッドは，クラスに紐付けられた「関数」のことを指します （正確にはクラスを実体化したインスタンスに紐付けられます）．
Robotクラスには，nameプロパティ，constructorメソッド，helloメソッドを定義しています． このうち，constructorは特殊なメソッドで，newを用いてRobotクラスの実体を作成するときに実行されます． 作成された実体のことを インスタンス と呼びます．

constructorでは，nameプロパティに引数で渡された値を設定しています． このとき，this.nameはクラスに紐付けられたプロパティであり， nameはメソッドに渡された引数であることに注意してください． helloでは，nameプロパティの値を引用した文字列を出力しています． プロパティであることを明確にするためにthis.nameと記述していますが， 引数として同じ名前のnameを受け取っていなければ， 単にnameと記述しても問題ありません（引数と混同を避けるためthis.nameを推奨）．
// Robotクラスを定義 class Robot{ // constructorメソッド  constructor(name){ // nameプロパティに代入  this.name = name; } // helloメソッド  hello(){ document.write(`&amp;lt;p&amp;gt;Hello, my name is ${this.name}!&amp;lt;/p&amp;gt;`); } } Robotクラスのインスタンスをnewを用いて作成します． このとき，constructorメソッドが呼び出され， 引数として渡されたRobinが，nameプロパティに代入されます．</description>
    </item>
    
    <item>
      <title>JavaScript④・関数</title>
      <link>https://mukai-lab.info/pages/classes/applied_programming_wa/chapter6/</link>
      <pubDate>Sun, 07 Mar 2021 20:34:43 +0900</pubDate>
      
      <guid>https://mukai-lab.info/pages/classes/applied_programming_wa/chapter6/</guid>
      <description>CodePenの準備  CodePenにアクセスして，Penを作成し，タイトルを設定しましょう． Penのタイトルは「Chapter6」に設定しましょう．
 https://codepen.io/

関数  与えられた入力に対して，特定の処理を実行して結果を返す仕組みが 関数 です． 複雑な処理を関数として名前を付けることで， プログラムのどこからでも関数を呼び出すことが可能になります． 関数を定義するには，下記の方法があります．
 functionで定義 アロー関数（無名関数）で定義  functionで定義 一般的な関数の定義方法です． 上述したように関数は，入力に対して，特定の処理をして，結果を返します． 入力は 引数（ひきすう），結果は 返り値（かえりち） と呼びます（返り値は 戻り値 と表現することもあります）．
関数の基本形 最初に引数や返り値を伴わないシンプルな関数の定義方法を確認しましょう． 関数名は自由に設定することができますが，先頭が小文字のキャメルケースで表現することが一般的です．
function 関数名(){ 実行する処理: } 次のisEven関数は，変数numberが偶数かどうかを判定します． 偶数かどうかは，2で割った余りが0になるかどうかで判断することが出来ます． 0である場合はtrue，0でない場合はfalseを関数の結果として返します． ここで，number=12であるため，12 % 2 = 0となり，true（偶数）になることがわかります．
// 変数numberが偶数かどうかを判定する関数 function isEven(){ let number = 12; let result = ((number % 2) == 0); document.write(`&amp;lt;p&amp;gt;result=${result}&amp;lt;/p&amp;gt;`); // -&amp;gt; result=true } // isEven関数を呼び出す isEven() 引数を利用した関数 引数は関数名の後の()の中に記述します． 複数の引数を指定したい場合は，カンマで区切って記述します．</description>
    </item>
    
    <item>
      <title>JavaScript③・条件分岐</title>
      <link>https://mukai-lab.info/pages/classes/applied_programming_wa/chapter5/</link>
      <pubDate>Sun, 07 Mar 2021 10:29:51 +0900</pubDate>
      
      <guid>https://mukai-lab.info/pages/classes/applied_programming_wa/chapter5/</guid>
      <description>CodePenの準備  CodePenにアクセスして，Penを作成し，タイトルを設定しましょう． Penのタイトルは「Chapter5」に設定しましょう．
 https://codepen.io/

条件式  前回の for文 では，繰り返しの継続条件として， 条件式 が用いられていました． 条件式は 比較演算子 や 論理演算子 で表現され， 条件式の結果は 真理値（true，false） になります．
比較演算子 比較演算子は左辺と右辺の関係を調べ，結果を真理値（true，false）で返します． == と===は左辺と右辺が一致するかどうかを調べる比較演算子ですが， 前者は値の一致を調べるのに対し，後者は値とデータ型の一致を調べます． このため，5==&amp;quot;5&amp;quot;はtrueですが，5===&amp;quot;5&amp;quot;はfalseになります．
   演算子 概要 例     == 左辺と右辺が等しい x == 5   != 左辺と右辺が異なる x != 5   &amp;gt; 左辺は右辺より大きい x &amp;gt; 3   &amp;lt; 左辺は右辺より小さい x &amp;lt; 3   &amp;gt;= 左辺は右辺以上 x &amp;gt;= 7   &amp;lt;= 左辺は右辺以下 x &amp;lt;= 7   === 左辺と右辺が等しい（データ型も） x === 5    let x = 5; document.</description>
    </item>
    
    <item>
      <title>JavaScript②・配列と繰り返し</title>
      <link>https://mukai-lab.info/pages/classes/applied_programming_wa/chapter4/</link>
      <pubDate>Sat, 06 Mar 2021 20:42:20 +0900</pubDate>
      
      <guid>https://mukai-lab.info/pages/classes/applied_programming_wa/chapter4/</guid>
      <description>CodePenの準備  CodePenにアクセスして，Penを作成し，タイトルを設定しましょう． Penのタイトルは「Chapter4」に設定しましょう．
 https://codepen.io/

配列  変数は1つの値を記憶することができますが， 複数の値を記憶するには複数の変数を用意する必要があり煩雑です． こんな場合には 配列 を利用します． 配列は，変数とは異なり，複数の値を記憶することが可能です． 配列を宣言するには，値をカンマで区切り，[]で括ります．
// 配列の宣言 let 配列名 = [値1, 値2, 値3, ...]; // 変数で3つの値を記憶 let x1 = 1; let x2 = 2; let x3 = 3; document.write(`&amp;lt;p&amp;gt;x1=${x1}&amp;lt;/p&amp;gt;`); document.write(`&amp;lt;p&amp;gt;x2=${x2}&amp;lt;/p&amp;gt;`); document.write(`&amp;lt;p&amp;gt;x3=${x3}&amp;lt;/p&amp;gt;`); // 配列で3つの値を記憶 let x = [1, 2, 3]; document.write(`&amp;lt;p&amp;gt;x=${x}&amp;lt;/p&amp;gt;`); 
配列に記憶させた1つの要素を取得するには，整数で表されるインデックス（索引）を利用します． インデックスは0から始まることに注意してください． 3つの値を記憶させたときのインデックスは0,1,2となります．
// 配列の要素にアクセス document.write(`&amp;lt;p&amp;gt;x[0]=${x[0]}&amp;lt;/p&amp;gt;`); document.write(`&amp;lt;p&amp;gt;x[1]=${x[1]}&amp;lt;/p&amp;gt;`); document.write(`&amp;lt;p&amp;gt;x[2]=${x[2]}&amp;lt;/p&amp;gt;`); 
連想配列  配列ではインデックスで要素にアクセスしますが， 文字列など任意のオブジェクトをキーにして，要素にアクセスするのが 連想配列 です （連想配列の場合は要素を プロパティ と表現する場合もある）． 連想配列は，文脈に応じて，オブジェクト，ハッシュとも呼ばれます． 連想配列を宣言するには，キーと値のペアをカンマで区切り，{}で括ります．</description>
    </item>
    
    <item>
      <title>JavaScript①・変数とデータ型</title>
      <link>https://mukai-lab.info/pages/classes/applied_programming_wa/chapter3/</link>
      <pubDate>Fri, 05 Mar 2021 16:23:56 +0900</pubDate>
      
      <guid>https://mukai-lab.info/pages/classes/applied_programming_wa/chapter3/</guid>
      <description>JavaScriptとは  JavaScript は1995年に開発されたブラウザで動作するプログラミング言語です． JavaScriptとJavaは名前が似ていますが，全く関係のないプログラミング言語なので気をつけましょう．
1990年代後半はWebページの動的なコンテンツを実装するために幅広く利用されていました． しかし，クロスブラウザの問題（ブラウザによって振る舞いが異なる問題）や， JavaScriptに関係するブラウザのセキュリティホールなどが発見された影響で，JavaScriptの人気は大きく低下してしまいます．
その後，2005年に Ajax （非同期通信でWebページを書き換える技術）が登場し，再びJavaScriptに光が当たります． 当時，Google マップがAjaxを採用したことで大きな話題になりました． 加えて，2000年代後半にはHTML5が登場し，Webページをアプリとして実装するための機能が強化されました．
この授業では，標準化団体のECMA Internationalによって， 標準化された ECMAScript 2015(ES6) を対象に解説をします． 従来のJavaScriptに比べ，ES6は便利な機能や構文が追加され，より簡潔なコーディングが可能になりました． 最新のJavaScriptを学び，Webページを自由自在に実装できるようになることを目指しましょう．
CodePenの準備  CodePenにアクセスして，Penを作成し，タイトルを設定しましょう． Penのタイトルは「Chapter3」に設定しましょう．
 https://codepen.io/

変数  変数の宣言 変数 とはデータを記憶しておく入れ物です． また，変数にデータを記憶させることを 代入 といいます． 従来はvarで変数を宣言していましたが， ES6から変数を宣言するためのletが追加されました． varと比べて，letには下記の特徴があります． より安全な利用が可能なletをこの授業では使います．
 同じ名前の変数を複数宣言できない スコープ（変数の有効範囲）が制限される  変数を宣言するには，letの後ろにスペースを空けて変数名を記述します． 行末には;を付けて，命令の区切りであることを表します． また，変数に値を代入するには，変数名の後に=と代入したい値を記述します． 値は整数，実数，文字列などを対象にすることができます．
結果を出力するためにdocument.writeを使用します． 括弧内にある+は文字列を連結する演算子です（演算子の詳細は後述）．
let 変数名; 変数名 = 代入する値; let x; //変数xを宣言 x = 2; //変数xに整数2を代入 document.write(&amp;#34;&amp;lt;p&amp;gt;x=&amp;#34; + x + &amp;#34;&amp;lt;/p&amp;gt;&amp;#34;); let y = 3; //変数yを宣言し，整数3を代入 document.</description>
    </item>
    
    <item>
      <title>老いの実感 Part 3</title>
      <link>https://mukai-lab.info/posts/2021-03-03-comic_146/</link>
      <pubDate>Wed, 03 Mar 2021 17:58:13 +0900</pubDate>
      
      <guid>https://mukai-lab.info/posts/2021-03-03-comic_146/</guid>
      <description></description>
    </item>
    
    <item>
      <title>老いの実感 Part 2</title>
      <link>https://mukai-lab.info/posts/2021-03-03-comic_145/</link>
      <pubDate>Wed, 03 Mar 2021 16:15:04 +0900</pubDate>
      
      <guid>https://mukai-lab.info/posts/2021-03-03-comic_145/</guid>
      <description></description>
    </item>
    
    <item>
      <title>老いの実感</title>
      <link>https://mukai-lab.info/posts/2021-03-03-comic_144/</link>
      <pubDate>Wed, 03 Mar 2021 15:11:14 +0900</pubDate>
      
      <guid>https://mukai-lab.info/posts/2021-03-03-comic_144/</guid>
      <description></description>
    </item>
    
    <item>
      <title>HTML&amp;CSSの基本</title>
      <link>https://mukai-lab.info/pages/classes/applied_programming_wa/chapter2/</link>
      <pubDate>Sat, 06 Feb 2021 19:59:28 +0900</pubDate>
      
      <guid>https://mukai-lab.info/pages/classes/applied_programming_wa/chapter2/</guid>
      <description>HTMLとCSS  Webページの大部分は HTML(Hypter Text Markup Language) と CSS(Cascading Style Sheet) で構成されています． HTMLはマークアップ言語の一つであり，&amp;lt;html&amp;gt;や&amp;lt;body&amp;gt;などの タグ（要素） を用いて，Webページに含まれる文字や画像などの基本構造を記述するために用いられます． 一方，CSSはスタイルシートと呼ばれ，HTMLで記述された基本構造のレイアウトやデザインを設計するために用いられます． このHTMLとCSSを組み合わせることで， 静的なコンテンツ を制作することが可能になります． Webアプリのような 動的なコンテンツ は，HTMLとCSSに加え，プログラミング言語であるJavaScriptを利用します．
 HTML Webページの基本構造を記述するための言語（文字や画像など） CSS Webページの装飾を記述するための言語（レイアウトやデザインなど） JavaScript Webページを動的に変更するための言語（アニメーションなど）  本科目の履修者は コンピュータと情報Ⅱ でHTMLとCSSを学習済みですが，今回は復習を兼ねてHTMLとCSSの基本を復習します．
CodePenの準備  CodePenにアクセスして，Penを作成し，タイトルを設定しましょう． Penのタイトルは「Chapter2」に設定しましょう．
 https://codepen.io/

HTMLの基本  タグの記述方法 HTMLにはh1やpなど様々な タグ が存在し， これを組み合わせることでWebページの構造を記述します． タグは &amp;lt;と&amp;gt;で囲み，開始タグ と 終了タグ のペアで一つの要素を表します． 終了タグには先頭に/を付けます． 例えば，h1 や p は下記のように記述することができます．
&amp;lt;!-- h1タグ --&amp;gt; &amp;lt;h1&amp;gt;プログラミング応用&amp;lt;/h1&amp;gt; &amp;lt;!-- pタグ --&amp;gt; &amp;lt;p&amp;gt;学籍番号: a20da000&amp;lt;/p&amp;gt; タグはそれぞれ用途が決まっています． 例えば，h1は見出し，pは段落を表現する際に用います． このとき，h1で括られた文字列は，大きなフォントサイズで表示されます． また，多くの場合，タグは開始タグと終了タグのペアで表されますが， 終了タグを省略して記述する場合があります． 例えば，画像を表示するための img は下記のように終了タグを省略して記述します（終了タグを記述しても問題ない）．</description>
    </item>
    
    <item>
      <title>Webアプリの開発</title>
      <link>https://mukai-lab.info/pages/classes/applied_programming_wa/chapter1/</link>
      <pubDate>Sat, 06 Feb 2021 12:53:07 +0900</pubDate>
      
      <guid>https://mukai-lab.info/pages/classes/applied_programming_wa/chapter1/</guid>
      <description>Webアプリとは  Webアプリ とは，ChromeやSafariなどWebブラウザで実行可能なアプリケーションのことです． 例えば，メールサービスの「Gmail」や，動画共有サービスの「YouTube」もWebアプリの一つと言えます．
一般的なWebアプリでは，ユーザはWebブラウザを介してアプリケーションを操作し，Webサーバでデータの取得や記録などの処理が実行されます． このWebブラウザ側の仕組みを フロントエンド と呼びます． 一方，Webサーバ側の仕組みを バックエンド と呼びます．
 フロントエンド ユーザが文字を入力するためのインターフェースなど，Webブラウザ側で実行するプログラムのこと． バックエンド データを記録するためのデータベースの処理など，Webサーバ側で実行するプログラムのこと．  この授業では，主にフロントエンドに注目し，フロントエンドの開発に必要なHTML，CSS，JavaScriptなどの技術の習得を目的とします（バックエンドの開発には，Python，Ruby，JavaScriptなど様々なプログラミング言語が用いられます）． また，開発はソーシャル開発環境のCodePenを採用することで，効果的な学習を促し，成果の共有を容易にします． 授業の最後には，オリジナルのWebアプリの開発に挑戦します．
CodePenとは  CodePenはソーシャル開発環境（Social Development Environment）であり，Webブラウザ上でソースコードを入力し，その実行結果を確認できるサービスです．提供されるソースコード・エディタは，HTML，CSS，JavaScriptの開発に特化しており，初学者にとっては最適な開発環境です．開発できるプロジェクト数やアセット（画像などの素材）の利用に制限はあるものの，基本機能は無料で利用可能であり，教育目的としても幅広く利用されています．それでは，下記のURLからCodePenにアクセスしてみましょう．
 https://codepen.io/
CodePenのアカウント作成 CodePenで作成したWebアプリを共有・公開するにはフリー・アカウントが必要です（有料のプロ・アカウントは必要ない）． Eメールだけでなく，Twitter，GitHub，Facebookのアカウントを利用してサインアップが可能です． 各自，都合の良い方法でサインアップしてください．

CodePenの開発方法 CodePenでは，Pen とProject の2種類の開発方法があります． Penは，HTML，CSS，JavaScriptの3つのファイルで構成されるシンプルなWebアプリを開発できます． また，Projectは，複数のファイル（無料アカウントでは10ファイルまで）で構成されるWebアプリを開発できます． Collections はPenとProjectをまとめたグループのことです． この授業では，主にPenを利用します． それでは，Penをクリックしましょう．

Penの開発環境は，HTML，CSS，JavaScriptを入力する3つのエディタで構成されています． このエディタに入力した結果が，画面の下部に表示されます． Change View から好みのレイアウトに変更することも可能です．

タイトルの設定 画面の上部で，Penのタイトルを設定することができます． Penのタイトルを「Chapter1」に設定しましょう．

HTMLの入力 HTMLのコードを入力してみましょう． 学籍番号は自分自身の番号に置き換えてください． h1タグは見出し（Header）， pタグは段落（Paragraph）を表しています．
&amp;lt;h1&amp;gt;プログラミング応用&amp;lt;/h1&amp;gt; &amp;lt;p&amp;gt;学籍番号: a20da000&amp;lt;/p&amp;gt; 
CSSの入力 CSSのコードを入力してみましょう． h1タグの文字色を白，背景色を緑に設定しています． また，pタグのマージン（余白）を20ピクセルに設定しています．
h1{ color: white; background-color: green; } p{ margin: 20px; }</description>
    </item>
    
    <item>
      <title>Githubの基本的な使い方</title>
      <link>https://mukai-lab.info/pages/tech/github/github-usage/</link>
      <pubDate>Mon, 11 Jan 2021 12:22:29 +0900</pubDate>
      
      <guid>https://mukai-lab.info/pages/tech/github/github-usage/</guid>
      <description>GitHubとは GitHubはバージョン管理システムGitのホスティングサービスです．GitHubでソースコードを管理・共有することで，他の開発者と一緒にコーディングをすることが可能になります．オープンソースのプロジェクトなどはGitHubを利用して開発されることが殆どです．ここでは，GitHubの基本的な使い方を解説します．
GitHubを利用する準備 アカウントの作成 公式サイトでGitHubのアカウントを作成してください．一般の無料アカウントでは，誰もが閲覧可能な パブリック・レポジトリ しか作成できませんが，学生や教員はGitHub Educationに登録が可能で，無料で プライベート・レポジトリ を作成できます．下記の記事を参考にGitHub Educationに登録しておきましょう．
【学割】GitHub Educationの申請とPrivateリポジトリを無料で使う方法
GitHub Desktopのインストール GitHubの操作にはクライアント・ソフトウェアを利用します．どのソフトウェアを利用しても構いませんが，GitHub公式のGitHub Desktopがオススメです．向はCUIのGit for Windowsを利用しています．
 GitHub Desktop Sourcetree Git for Windows GitKraken  GitHub Dektopをインストールしたら，GitHubのアカウントでサインインします．

パブリック・レポジトリの作成 GitHubのウェブサイトにアクセスし，ウェブ上にパブリック・レポジトリを作成します．

レポジトリの名前は TestRepository とします． レポジトリで管理するファイルなどの説明を記述するための README ファイルの作成もチェックしておきます．

レポジトリの基本操作 レポジトリをローカルPCにクローン GitHub Desktopで，ウェブ上に作成したレポジトリをローカルPCに Clone（クローン） します． クローンとはファイルをコピーして複製するという意味です． レポジトリのクローンを保存するためのフォルダをローカルPCに作成してください． フォルダ名はレポジトリと同じ TestRepository としておきましょう．



READMEを上書き レポジトリをクローンしたフォルダに README.md が存在しています． このファイルは作成したレポジトリの説明書であり，ウェブサイトのトップ画面に自動的に表示されます． 開発するソフトウェアの名称や使い方などを記述する目的で用いられます． メモ帳などのエディタでファイルを開き，下記のように作成者を追加して保存してください（公開されてしまうので ニックネーム でOK）． 拡張子は md となっており，手軽にウェブページを記述できるMarkdown（マークダウン）記法で記述することを表しています． マークダウン記法はとても便利なので使いこなせるようにしておきましょう．
# TestRepository テスト用のレポジトリです． ## 作成者 向 直人 README.</description>
    </item>
    
    <item>
      <title>そして誰もいなくなった</title>
      <link>https://mukai-lab.info/posts/2020-07-09-comic_143/</link>
      <pubDate>Thu, 09 Jul 2020 11:55:04 +0900</pubDate>
      
      <guid>https://mukai-lab.info/posts/2020-07-09-comic_143/</guid>
      <description></description>
    </item>
    
    <item>
      <title>技術者だけに</title>
      <link>https://mukai-lab.info/posts/2020-07-06-comic_142/</link>
      <pubDate>Wed, 08 Jul 2020 15:48:06 +0900</pubDate>
      
      <guid>https://mukai-lab.info/posts/2020-07-06-comic_142/</guid>
      <description></description>
    </item>
    
    <item>
      <title>深層学習のデータセット</title>
      <link>https://mukai-lab.info/pages/classes/advanced_studies_seminar_1/chapter7/</link>
      <pubDate>Tue, 07 Jul 2020 13:04:55 +0900</pubDate>
      
      <guid>https://mukai-lab.info/pages/classes/advanced_studies_seminar_1/chapter7/</guid>
      <description>データセットの紹介  TorchvisionにはCIFAR-10以外にも様々なデータセットが用意されています． ここでは，MNIST ，Fashion-MNIST ，KMNIST ，COCO ， Cityscapes を取り上げて紹介します．
import torchvision import matplotlib.pyplot as plt MNIST MNISTは 手書きの数字文字 のデータセットです． グレースケール画像で，サイズは$28 \times 28$です．
dataset = torchvision.datasets.MNIST(root=&amp;#34;./data&amp;#34;, download=True) image, label = dataset[0] print(label) plt.imshow(image, cmap=&amp;#34;gray&amp;#34;) 
Fashion-MNIST Fashion-MNISTは 衣服などの ファッション のデータセットです． グレースケール画像で，サイズは$28 \times 28$です．
dataset = torchvision.datasets.FashionMNIST(root=&amp;#34;./data&amp;#34;, download=True) image, label = dataset[0] print(label) plt.imshow(image, cmap=&amp;#34;gray&amp;#34;) 
KMNIST KMNISTは くずし字（ひらがなや漢字） のデータセットです． グレースケール画像で，サイズは$28 \times 28$です．
dataset = torchvision.datasets.KMNIST(root=&amp;#34;./data&amp;#34;, download=True) image, label = dataset[0] print(label) plt.</description>
    </item>
    
    <item>
      <title>畳み込みニューラルネットワーク</title>
      <link>https://mukai-lab.info/pages/classes/advanced_studies_seminar_1/chapter6/</link>
      <pubDate>Sun, 05 Jul 2020 12:55:03 +0900</pubDate>
      
      <guid>https://mukai-lab.info/pages/classes/advanced_studies_seminar_1/chapter6/</guid>
      <description>畳み込みニューラルネットワーク  畳み込みニューラルネットワーク(Convolutional Neural Network: CNN) は， 画像や動画の分類に用いられる特殊なニューラルネットワークです． CNNは， 畳み込み層(Convolutional Layer) ， プーリング層(Pooling Layer) ， 全結合層(Full Connected Layer) の3種類で構成されます．
入力画像は，畳み込み層に入力され，プーリング層を経て， 全結合層で集約され，最終的に画像の分類を出力します． この畳み込み層とプーリング層の処理は，複数回繰り返されることがあります． 畳み込み層では複数のフィルタを用いて画像の特徴量を抽出します． プーリング層では特徴を失わないように画像サイズを縮小します（ダウンサンプリング）． 全結合層は多層パーセプトロンで用いられる一般的な層と同じです．

畳み込み層 畳み込み層の仕組みを確認しましょう． 畳み込み層の目的は入力された複数の画像の特徴量をフィルタを利用して抽出することです． 下図は$4 \times 4$の入力画像に，$2 \times 2$のフィルタを適用した様子です． 入力画像からフィルタと同じ$2 \times 2$の画素を取り出し，フィルタの値と掛け合わせることで特徴量となります． この操作を1ピクセルだけずらしながら画像全体に適用すると$3 \times 3$の画像に変換されます． フィルタの値を変えることで，垂直方向の輪郭線や，水平方向の輪郭線を強調することが出来ます．

それでは，この畳み込み層の振る舞いを再現してみましょう．
ノートブックを作成し，ノートブックのタイトルをchapter6 に設定します． まずは，ライブラリのインストールとインポートを行います． ここでは，画像処理ライブラリのPillowと 数値計算ライブラリのScipyも追加します．
!pip install torch !pip install torchvision import torch import torch.nn as nn import torch.nn.functional as F import torch.optim as optim import torchvision import torchvision.</description>
    </item>
    
    <item>
      <title>物体画像（CIFAR-10）の分類</title>
      <link>https://mukai-lab.info/pages/classes/advanced_studies_seminar_1/chapter5/</link>
      <pubDate>Fri, 03 Jul 2020 14:14:15 +0900</pubDate>
      
      <guid>https://mukai-lab.info/pages/classes/advanced_studies_seminar_1/chapter5/</guid>
      <description>物体画像(CIFAR-10)  CIFAR-10データセットを利用した物体画像の認識に挑戦しましょう． 60000枚のカラー画像（RGB）を含むデータセットであり， 各画像は$32 \times 32$ピクセルで構成されています． また，各画像は，airplane，automobile，birdなど10のカテゴリに分類されており， 前回学習した多層パーセプトロンを利用して分類を実現します．
ノートブックを作成し，ノートブックのタイトルをchapter5 に設定します． まずはPyTorch，Numpy，Matplotlibに加えて， データセットを提供するTorchvisionをインポートします． CIFAR-10も提供されるデータセットの一つです．
!pip install torch !pip install torchvision import torch import torch.nn as nn import torch.optim as optim import torchvision import torchvision.transforms as transforms import numpy as np import matplotlib.pyplot as plt それでは，CIFAR10のデータセットを読み込みます． 初回のみはローカルへのダウンロードが発生します． 今回は学習用に用いられる50000枚のデータを利用します．
dataset = torchvision.datasets.CIFAR10(root=&amp;#34;./data&amp;#34;, download=True) print(dataset) #出力 Extracting ./data/cifar-10-python.tar.gz to ./data Dataset CIFAR10 Number of datapoints: 50000 Root location: ./data Split: Train データセットには，正解のラベルを表す番号が含まれていますが， ラベルの名前（例，airplane）などは含まれていません． そこで，ラベルの名前を含むリストを作成しておきます． リストの要素番号とラベルの番号が一致していることに注意してください．</description>
    </item>
    
    <item>
      <title>多層パーセプトロン</title>
      <link>https://mukai-lab.info/pages/classes/advanced_studies_seminar_1/chapter4/</link>
      <pubDate>Thu, 02 Jul 2020 14:57:58 +0900</pubDate>
      
      <guid>https://mukai-lab.info/pages/classes/advanced_studies_seminar_1/chapter4/</guid>
      <description>多層パーセプトロン  前回，単純パーセプトロンは分類問題に適用できることを確認しました． しかし，線形分離不可能問題（非線形な決定境界） を解くことが出来ないことが知られています． まずは，線形分離不可能問題（非線形な決定境界）について考えましょう．
ノートブックを作成し，ノートブックのタイトルをchapter4 に設定します． 前回と同様にPyTorchをインストールし，PyTorch，Numpy，Matplotlibをインポートします．
!pip install torch !pip install torchvision import torch import torch.nn as nn import torch.optim as optim import numpy as np import matplotlib.pyplot as plt import itertools サンプル$x=(x_1, x_2)$を2つのカテゴリに分類します． 下記が今回の学習データであり， 決定境界を 直線 で引くことができないことが分かります． このような分類問題は単純パーセプトロンでは解くことが出来ません．
x1 = torch.tensor([0.28, 0.35, 0.36, 0.37, 0.62, 0.66, 0.78, 0.81, 0.89, 0.94], dtype=torch.float) x2 = torch.tensor([0.34, 0.21, 0.65, 0.87, 0.73, 0.23, 0.87, 0.34, 0.76, 0.91], dtype=torch.float) x = torch.</description>
    </item>
    
    <item>
      <title>パーセプトロンの学習</title>
      <link>https://mukai-lab.info/pages/classes/advanced_studies_seminar_1/chapter3/</link>
      <pubDate>Tue, 30 Jun 2020 22:05:29 +0900</pubDate>
      
      <guid>https://mukai-lab.info/pages/classes/advanced_studies_seminar_1/chapter3/</guid>
      <description>自動微分  PyTorchでは 自動微分 という機能が実装されており， テンソルで作成した式（ 計算グラフ と呼ぶ）の傾き（勾配）が保持されます． この自動微分はパーセプトロンの重みやバイアスの学習に欠かせない機能です．
ノートブックを作成し，ノートブックのタイトルをchapter3 に設定します． まずは，PyTorchをインストールし，PyTorch，Numpy，Matplotlibをインポートします．
!pip install torch !pip install torchvision import torch import torch.nn as nn import numpy as np import matplotlib.pyplot as plt テンソルxを2.0で初期化します． このxを自動微分の対象とするためrequires_grad=Trueをオプションとして設定します．
x = torch.tensor([2.0], requires_grad=True) # x=2 print(x) #出力 tensor([2.], requires_grad=True) 定義したxを用いて計算グラフyを定義します． ここで，$x=2$であるため，$y=9$となります．
$$ y = x^2 + 2x + 1 $$
y = x * x + 2 * x + 1 print(y) #出力 tensor([9.], grad_fn=&amp;lt;AddBackward0&amp;gt;) yをxで微分します． 計算グラフが複数のテンソルで構成される場合は， 全てのテンソルに対する偏微分が計算されます． ここで，$x=2$であるため，$\frac{dy}{dx}=6$となります．</description>
    </item>
    
    <item>
      <title>ssh-Agentでパスフレーズの省略</title>
      <link>https://mukai-lab.info/pages/tech/github/ssh-agent/</link>
      <pubDate>Sun, 28 Jun 2020 11:17:00 +0900</pubDate>
      
      <guid>https://mukai-lab.info/pages/tech/github/ssh-agent/</guid>
      <description>Git for Windowsで， pullやpushするときに毎回パスワードを入力する手間を省略する方法です．
ホームディレクトリに~/.bashrcを作成し，下記のコマンドを入力します． この.bashrcはGit for Windowsのデフォルトのシェルである bash が起動時に 自動で読み込むファイルです．
eval `ssh-agent` ssh-add ここで，evalコマンドは引数の文字列をコマンドとして実行します． また，ssh-agentを起動しておき，ssh-addでパスフレーズを登録します．</description>
    </item>
    
    <item>
      <title>単純パーセプトロン</title>
      <link>https://mukai-lab.info/pages/classes/advanced_studies_seminar_1/chapter2/</link>
      <pubDate>Fri, 26 Jun 2020 18:13:38 +0900</pubDate>
      
      <guid>https://mukai-lab.info/pages/classes/advanced_studies_seminar_1/chapter2/</guid>
      <description>単純パーセプトロン  パーセプトロン とは，動物の神経細胞（ニューロン）の発火現象を数理的に表現したモデルのことです． ウォーレン・マカロック氏とウォルター・ピッツ氏が提案した 形式ニューロン を2層のネットワーク状に接続したものは 単純パーセプトロン と呼ばれます． 単純パーセプトロンの1層目のニューロンは，入力データを伝えるだけの役割であるため，実質的には1つの形式ニューロンと考えることができます．

ここでは，2入力，1出力の単純パーセプトロンを考えます． 下記の式に従って，入力された$x_1$と$x_2$から，中間出力$y$を得ます． ここで，$w_1$と$w_2$は入力に対する 重み です． また，$w_0$は バイアス と呼ばれ，出力の閾値として用いられます．
$$ y = w_1 \times x_1 + w_2 \times x_2 + w_0 $$
この中間出力$y$に対して，活性化関数 $f$と呼ばれる特殊な関数を適用して， 得られた値を最終的なニューロンの出力$z$とします．
$$ z = f(y) $$
一般に$n$入力の単純パーセプトロンは，入力${\bf x}$と重み${\bf w}$は下記のようにベクトルで表現されます． ここで，$x_0=1$はバイアス$w_0$を導入するために用いられます． パーセプトロンが多層になると，ベクトル表現が必須となりますので，慣れておきましょう．
$$ {\bf x} = (1, x_1, \cdots, x_n) \\
{\bf w} = (w_0, w_1, \cdots, w_n) \\
y = {\bf x} \cdot {\bf w} \\</description>
    </item>
    
    <item>
      <title>ニューラルネットワーク</title>
      <link>https://mukai-lab.info/pages/classes/advanced_studies_seminar_1/chapter1/</link>
      <pubDate>Thu, 25 Jun 2020 16:12:35 +0900</pubDate>
      
      <guid>https://mukai-lab.info/pages/classes/advanced_studies_seminar_1/chapter1/</guid>
      <description>ニューラルネットワークとは  ニューラルネットワーク（Neural Netowork） とは， 生物の脳を数理的に表現したモデルのことであり， 1943年に外科医であったウォーレン・マカロック（Warren McCulloch）氏と， 数学者であったウォルター・ピッツ（Walter Pitts）氏が考案した形式ニューロンが起源とされています．
1940年代~60年代の第1次AIブームに大きく注目され， 単純パーセプトロン と呼ばれるニューラルネットワークが提案されます． その後，1980年代の第2次AIブームにおいて， ニューラルネットワークの学習アルゴリズムである バックプロパゲーション（誤差逆伝播法） が確立し， 多層パーセプトロン へ発展します．
近年は第3次AIブームであり，ニューラルネットワークをさらに多層化させた ディープラーニング（深層学習） が提案され，画像認識などの分野で高い性能を示しています． 今後もディープラーニングは進化し，自動運転やロボット技術に応用され， 我々の生活を支える必要不可欠な技術になると予想されます． 本授業では，ニューラルネットワークの歴史を追いながら， Google Colaboratory（Colab） で実装することで，その技術を理解することを目標とします． また，ディープラーニングの実装には，Pytorch を採用します．
ニューロン  ニューロン（神経細胞）は，動物の神経を構成する細胞であり，電気的に情報を伝える役割を担っています． 入力部分が樹状突起，伝送路が軸索，出力が軸索末端となっており，他のニューロンからの伝わった刺激（電気パルス）を 変化させて次のニューロンに伝えるという仕組みになっています． 人間の脳は100億から1000億のニューロンが存在すると考えられており， 立体的で複雑な回路網が形成されているそうです． このニューロンの仕組みの数式モデルが 形式ニューロン であり， 後に発展するディープラーニングの基礎となっています．

Jupyter Notebookのインストール  Jupyetr Notebookをインストールします． 過去に人工知能などの授業で既にインストール済みの場合はスキップして構いません． [Python](https://www.python.org)　のインストール・パッケージをダウンロードしましよう． このとき，Pythonのバージョンは**3.x**を選択してください． インストールを始める前に，ファイルをインストールするためのフォルダを作成します． 大学で環境を構築する場合は，**Hドライブ** に，**MyPython** という名前でフォルダを作成してください． それでは，インストーラを実行しましょう． **Customize installation** を選択し， パッケージ管理システムの **pip** が同時にインストールされることを確認してください． [![Image from Gyazo](https://i.gyazo.com/e1fc572f43e771cb3901a76e927a84bd.png)](https://gyazo.com/e1fc572f43e771cb3901a76e927a84bd) [![Image from Gyazo](https://i.gyazo.com/294b8b48f53df91303d1c26bfaf7ada8.png)](https://gyazo.com/294b8b48f53df91303d1c26bfaf7ada8) このとき，インストールするフォルダは，上記で作成した**H:\MyPython**とすることに注意してください． [!</description>
    </item>
    
    <item>
      <title>展開演習1</title>
      <link>https://mukai-lab.info/pages/classes/advanced_studies_seminar_1/</link>
      <pubDate>Thu, 25 Jun 2020 16:12:29 +0900</pubDate>
      
      <guid>https://mukai-lab.info/pages/classes/advanced_studies_seminar_1/</guid>
      <description>授業科目区分： 専門教育科目
単位数: 1単位
開講学科: 文化情報学科
学年: 2年次
関連科目: 人工知能，知能情報システム
授業テーマ: ニューラルネットワークと深層学習の基礎
授業内容 近年注目される機械学習手法の一つが深層学習（ディープラーニング）である． 人工知能の発展を支える中心的な役割を担う技術であり， 物体検出や自然言語処理など様々な分野で高い実績を上げている． 本授業では深層学習をPythonで実装するためのPyTorchというフレームワークを利用して， 深層学習の基礎となるニューラルネットワークを実装することから始め， 物体画像（CIFAR-10）の分類に挑戦する．
授業計画  ニューラルネットワーク 単純パーセプトロン パーセプトロンの学習 多層パーセプトロン 物体画像(CIFAR-10)の分類 畳み込みニューラルネットワーク 深層学習のデータセット  参考書籍</description>
    </item>
    
    <item>
      <title>Vue.jsを利用した地図アプリ（後編）</title>
      <link>https://mukai-lab.info/pages/tech/vue/vue4/</link>
      <pubDate>Wed, 24 Jun 2020 16:03:21 +0900</pubDate>
      
      <guid>https://mukai-lab.info/pages/tech/vue/vue4/</guid>
      <description>親子コンポーネントのイベント処理  地図アプリに配置した上下左右のボタンのイベント処理を実装します． このアプリは3つのコンポーネントで構成されています． 親コンポーネントは main.vue ，子コンポーネントは vmap.vue と vcontroller.vue です． 親子コンポーネント間でメソッドを呼び出したり，データを受け渡すには幾つか方法がありますが， 子から親 ，親から子 ではその方法が異なります． 今回の地図アプリでは下記の流れでイベント処理を行います．
 vcontroller.vue（子） のボタンをクリックすると，main.vue（親） のmoveメソッドを呼び出す（子から親）． main.vue（親） のmoveメソッドが呼び出されると，vmap.vue（子） のmoveメソッドを呼び出す（親から子）．  
子から親のメソッドを実行  子コンポーネントから親コンポーネントのメソッドを呼び出すには$emitを利用します．
main.vue（親） 親コンポーネントで moveメソッドを定義します． このmoveメソッドはアラートを表示するだけです． このメソッドを v-onディレクティブを利用して，vcontorllerタグの属性として指定します． このとき，move-eventという属性名になっていることに注意してください．
&amp;lt;template&amp;gt; &amp;lt;div&amp;gt; &amp;lt;h1&amp;gt;Vue.jsで地図アプリ&amp;lt;/h1&amp;gt; &amp;lt;vmap&amp;gt;&amp;lt;/vmap&amp;gt; &amp;lt;vcontroller v-on:move-event=&amp;#34;move&amp;#34;&amp;gt;&amp;lt;/vcontroller&amp;gt; &amp;lt;/div&amp;gt; &amp;lt;/template&amp;gt; &amp;lt;script&amp;gt; import vmap from &amp;#34;./vmap&amp;#34; import vcontroller from &amp;#34;./vcontroller&amp;#34; export default{ components:{ vmap, vcontroller }, methods:{ move(direction){ // アラートを表示  alert(direction); } } } &amp;lt;/script&amp;gt; vcontroller.vue（子） 子コンポーネントでも moveメソッドを定義しています． このmoveメソッドは，$emitを利用してmove-eventとして登録されている親コンポーネントの moveメソッドを呼び出します． また，moveメソッドは，v-onディレクティブを利用して，ボタンのクリックがトリガーとなっています． このとき，メソッドの引数としてleft, up, right, downのいずれかの文字列が渡されることに注意してください．</description>
    </item>
    
    <item>
      <title>Vue.jsを利用した地図アプリ（前編）</title>
      <link>https://mukai-lab.info/pages/tech/vue/vue3/</link>
      <pubDate>Wed, 24 Jun 2020 16:03:19 +0900</pubDate>
      
      <guid>https://mukai-lab.info/pages/tech/vue/vue3/</guid>
      <description>Vue CLIとは  Vue.jsを利用した本格的なアプリ開発のためのツールとしてVue CLIが公開されています． Vue CLIはNode.jsにおいて動作し， テンプレートを利用したプロジェクトの作成や，プラグインによる拡張などが利用可能です． ここではWindows環境を想定して，Vue CLIやNode.jsのインストール方法を示します．
まずは，Node.jsをインストールしましょう． パッケージマネージャのChocolateyを利用すると簡単です． PowerShellなどを起動して下記のコマンドを入力します．
&amp;gt; choco install nodejs Node.jsをインストールしたら，次はVue CLIをインストールします． 同様にPowerShellで下記のコマンドを入力します． この-gオプションはグローバルにインストールすることを意味しており， どのディレクトリ（フォルダ）でも利用が可能になります（ローカルのnode_modulesにはインストールされない）．
&amp;gt; npm install -g @vue/cli &amp;gt; npm install -g @vue/cli-service-global Vue CLIをインストールしたら，vueコマンドを実行してみましょう． -Vオプションでバージョンを確認することができます．
&amp;gt; vue -V @vue/cli 4.4.5 Vue CLIを利用したプロジェクトのビルド（公開可能なファイルに変換する）に失敗する場合， フォルダに下記のコードを記述した vue.config.js というファイルを配置してください（ビルド方法は後述）．
module.exports = { publicPath: &amp;#39;./&amp;#39; } 単一ファイルコンポーネントとは  Vue Cliでは，これまでのように，HTMLファイル（.html），JavaScriptファイル（.js），CSSファイル（.css）にコードを記述しません． これらの代わりに，全ての機能をまとめた単一ファイルコンポーネント（.vue）にコードを記述します． 単一ファイルコンポーネントは下記の構成になっています．
 templateタグはHTMLで記述し，Vueコンポーネントのtemplateオプションとして用いられます． scriptタグはJavaScriptで記述し，Vueコンポーネントとして利用されます（外部から利用可能になる）． styleタグはCSSで記述し，scpedを指定することで，templateタグの内部に限定してスタイルが適用されます．  &amp;lt;template&amp;gt; &amp;lt;/tempalte&amp;gt; &amp;lt;script&amp;gt; export default{ } &amp;lt;/script&amp;gt; &amp;lt;style scoped&amp;gt; &amp;lt;/style&amp;gt; 単一ファイルコンポーネントは階層的に 親コンポーネントから子コンポーネントをインポートすることができます． 例えば，child1.</description>
    </item>
    
    <item>
      <title>Vue.jsを利用したクイズアプリ</title>
      <link>https://mukai-lab.info/pages/tech/vue/vue2/</link>
      <pubDate>Tue, 23 Jun 2020 15:13:21 +0900</pubDate>
      
      <guid>https://mukai-lab.info/pages/tech/vue/vue2/</guid>
      <description>ルーティングとは  ルーティング（Routing） とはVue.jsにおいて， リクエストされたURLに応じて，コンポーネントを選択して表示する仕組みのことです． シングルページアプリケーション（Single Page Application: SPA） と呼ばれる 単一のWebページで動的にコンテンツを切り替える設計方法を実現するために用いられます． Webページの遷移が発生しないため，サーバとの通信を減らし高速なコンテンツの遷移が可能になることに加え， ネイティブアプリ（JavaやSwiftで開発されたアプリ）の代替としても採用されます． 今回はこのルーティングを利用してクイズアプリを実装してみましょう．
クイズアプリ  それでは， クイズアプリ を実装して行きましょう． 下記が完成したソースコードです． 「問題」をクリックするとクイズの問題が表示され， 「解答」をクリックすると対応するクイズの解答が表示されます．
See the Pen クイズアプリ by Naoto Mukai (@nmukai)on CodePen.CDNのリンク ルーティングを実装するには，vue.js に加え， vue-route.js を導入する必要があります． CodePenのSettingsで下記のようにCDNを追加してください．

ルータの作成 それではルーティングの役割を担う VueRouter クラスのインスタンスをを作成しましょう． このルータには，2つのコンポーネント（component）を登録します． コンポーネントの実体は，変数のQuizBlockとAnsBlockで宣言しています． それぞれのコンポーネントには，pathとnameのプロパティを設定します． pathはリクエストされるURL，nameはルートの名前を表します． また，Vue クラスに router をプロパティとして登録しておきます．
var QuizBlock = { template: &amp;#34;&amp;lt;div&amp;gt; question &amp;lt;/div&amp;gt;&amp;#34; } var AnsBlock = { template: &amp;#34;&amp;lt;div&amp;gt; answer &amp;lt;/div&amp;gt;&amp;#34; } var router = new VueRouter({ routes: [ { path: &amp;#34;/quiz&amp;#34;, name: &amp;#34;quiz&amp;#34;, component: QuizBlock }, { path: &amp;#34;/answer&amp;#34;, name: &amp;#34;answer&amp;#34;, component: AnsBlock } ] }) new Vue({ el: &amp;#34;#main&amp;#34;, router }) ルーティングを利用するにはrouter-linkタグを利用します． to属性は表示したいコンポーネントのpathを指定します． router-linkタグは，リンクを表すaタグとして表示されます． また，router-viewタグは，コンポーネントを表示する領域です．</description>
    </item>
    
    <item>
      <title>Vue.jsを利用したサイコロアプリ</title>
      <link>https://mukai-lab.info/pages/tech/vue/vue1/</link>
      <pubDate>Mon, 22 Jun 2020 16:52:17 +0900</pubDate>
      
      <guid>https://mukai-lab.info/pages/tech/vue/vue1/</guid>
      <description>コンポーネントとは  コンポーネント（Component） とはVue.jsでページを構成する部品のことです． ページの部分的な機能をコンポーネントとして実装することで，ページ内に複数配置したり再利用が可能になります． 今回は サイコロの目 をコンポーネントとして実装し，1から6の目を配置します．
サイコロアプリ  それでは サイコロアプリ を実装して行きましょう． 下記が完成したソースコードです． 「サイコロを振る」というボタンをクリックすると，1から6のいずれかの目が緑色になります．
See the Pen NWxpRYa by Naoto Mukai (@nmukai)on CodePen.コンポーネントの作成 サイコロの目は divタグで実装します． まずは，divタグをデザインするための CSS を下記のように記述します． pipStyleとpipFocusの2つのクラスがあり，これをdivタグに適用します．
.pipStyle{ width: 50px; height: 50px; border: 1px solid black; text-align: center; display: table-cell; vertical-align: middle; } .pipFocus{ background: #00ff00; } div{ margin: 5px; } pip という名前でコンポーネントを実装します． この名前はHTMLでタグ名として用いられます． オプションには props と template を設定しています． props はpipタグの属性として渡されるデータを指しています． この場合，渡されたデータはflagという変数に格納されます． templateはコンポーネントをHTMLタグとして記述したときの実体であり， ここではサイコロのマス目を表すdiv要素です．</description>
    </item>
    
    <item>
      <title>Vue.jsを利用した検索アプリ</title>
      <link>https://mukai-lab.info/vue/chapter3/</link>
      <pubDate>Wed, 17 Jun 2020 15:20:50 +0900</pubDate>
      
      <guid>https://mukai-lab.info/vue/chapter3/</guid>
      <description>ジャパンサーチとは  ジャパンサーチは，国立国会図書館が運用しているデジタルアーカイブです． 様々な分野の関連機関と連携することで，約2千万件のコンテンツを管理しています（2020年6月現在）．
 https://jpsearch.go.jp/
Web APIが提供されており，指定されたURLにアクセスするだけで，コンテンツの検索ができる仕組みになっています． 例えば，「織田信長」をキーワードに検索するには，下記URLにアクセスします．
 https://jpsearch.go.jp/api/item/search/jps-cross?keyword=織田信長&amp;amp;size=3
検索結果はJSON（Javascript Object Notation）と呼ばれる形式で取得され， これを解析することでコンテンツのメタデータ（タイトル，提供者，時代など）を利用することができます． 今回はこのジャパンサーチとVue.jsを組み合わせて，ジャパンサーチの検索アプリを実装してみます．
検索アプリ  それでは， 検索アプリ を実装して行きましょう． 下記が完成したソースコードです． キーワードを入力して検索ボタンをクリックすると， コンテンツへのリンクが表示される仕組みとなっています．
See the Pen 基礎演習 第3回 by Naoto Mukai (@nmukai) on CodePen.  新規Penの作成 開発環境であるCodePenを開き，新規にPen（プロジェクト）を作成してください． Penを作成したらタイトルに 基礎演習 第3回 と入力しましょう．

次にVue.jsとHTTPリクエストを処理するためのaxiosを導入します． Vue.jsと同様に，axios で検索して，最新バージョンを選択します（2020年6月時点では0.19.2が最新）．

Vueクラスの作成 それでは，HTMLのコードを入力しましょう． 前回と同じ様にsubject，id，nameをVue.jsのデータバインディングで設定しています．
&amp;lt;div id=&amp;#34;title&amp;#34;&amp;gt; &amp;lt;h1&amp;gt;{{ subject }}&amp;lt;/h1&amp;gt; &amp;lt;p&amp;gt;学籍番号: {{ id }}&amp;lt;/p&amp;gt; &amp;lt;p&amp;gt;氏名: {{ name }}&amp;lt;/p&amp;gt; &amp;lt;/div&amp;gt; new Vue({ el: &amp;#34;#title&amp;#34;, data: { subject: &amp;#34;基礎演習 第3回&amp;#34;, id: &amp;#34;a20da000&amp;#34;, name: &amp;#34;向 直人&amp;#34; } })</description>
    </item>
    
    <item>
      <title>Vue.jsを利用したお絵かきアプリ</title>
      <link>https://mukai-lab.info/vue/chapter2/</link>
      <pubDate>Wed, 17 Jun 2020 15:20:48 +0900</pubDate>
      
      <guid>https://mukai-lab.info/vue/chapter2/</guid>
      <description>キャンバス（Canvas）とは  キャンバス（Canvas） は HTML5から導入された JavaScript でグラフィックやアニメーションを描画するための要素（タグ）です． 描画にはCanvas APIが用いられ，Canvasに関連付けられたコンテキストに対して，JavaScriptで描画を指示します． 例えば，下記のコードは，キャンバスを設置し，青色で塗りつぶした正方形を描いています． 今回はこのCanvasとVue.jsを組み合わせて，簡易なお絵かきアプリを実装してみます．
&amp;lt;canvas id=&amp;#34;canvas&amp;#34;&amp;gt;&amp;lt;/canvas&amp;gt; &amp;lt;script&amp;gt; canvas = document.getElementById(&amp;#34;canvas&amp;#34;); context = canvas.getContext(&amp;#34;2d&amp;#34;); context.fillStyle = &amp;#34;blue&amp;#34;; context.fillRect(10, 10, 150, 150); &amp;lt;/script&amp;gt; 
 canvas = document.getElementById(&#34;canvas&#34;); context = canvas.getContext(&#34;2d&#34;); context.fillStyle = &#34;blue&#34;; context.fillRect(10, 10, 150, 150);  お絵かきアプリ  それでは お絵かきアプリ を実装して行きましょう． 下記が完成したソースコードです． キャンバス上でマウスを動かすと小さな四角形が描画される仕組みとなっています．
See the Pen 基礎演習 第2回 by Naoto Mukai (@nmukai) on CodePen.  新規Penの作成 開発環境であるCodePenを開き，新規にPen（プロジェクト）を作成してください． Penを作成したらタイトルに 基礎演習 第2回 と入力しましょう．</description>
    </item>
    
    <item>
      <title>Vue.jsを利用したおみくじアプリ</title>
      <link>https://mukai-lab.info/vue/chapter1/</link>
      <pubDate>Wed, 17 Jun 2020 15:20:45 +0900</pubDate>
      
      <guid>https://mukai-lab.info/vue/chapter1/</guid>
      <description>Vue.jsとは  従来，ウェブページの制御にはjQueryと呼ばれるライブラリが広く普及していましたが， リッチなユーザインターフェースを構築するには不十分になってきました． 近年，ユーザインターフェースを伴うウェブアプリを 効率的に実装するために フレームワーク と呼ばれる技術が採用されるようになりました． 特にプログラミング言語の一つである JavaScript で記述するフレームワークが有名です． 代表的なフレームワークには， Google社が主体となって開発する AngularJS ， Facebook社が主体となって開発する React.js ， Google社から独立したEvan You氏が開発する Vue.js があります．
 AngularJS React.js Vue.js  ここでは，学習コストが低く，初学者にとって学びやすい Vue.js を取り上げます． フルスタック（必要な機能が全て含まれている）なフレームワークとは異なり， Vue.jsは軽量に設計されており，必要に応じて他のライブラリを統合することで， リッチなウェブアプリを制作することも可能になっています． ここでは，「おみくじアプリ」「お絵かきアプリ」「検索アプリ」をテーマに実装に挑戦します．
開発環境  開発環境にはCodePenを採用します． CodePenはオンラインでHTML，CSS，JavaScriptの実装・テストができる学習環境です．
 https://codepen.io/
アカウントを登録することで，実装したソースコードを保存することができますので， 事前に登録を済ませて起きましょう（登録は必須ではありません）． CodePenの画面は下記のようになっています． 画面の上部がHTML，CSS，JavaScriptのエディタ，下部がプレビューです． エディタでソースを編集して保存するとプレビューが更新されます．

下記を参考にエディタにソースコードをコピー＆ペーストで貼り付けてみましょう． プレビューに同じ結果が表示されるはずです．
&amp;lt;div id=&amp;#34;title&amp;#34;&amp;gt; &amp;lt;h1&amp;gt;基礎演習&amp;lt;/h1&amp;gt; &amp;lt;p&amp;gt;学籍番号: a20da000&amp;lt;/p&amp;gt; &amp;lt;p&amp;gt;氏名: 向 直人&amp;lt;/p&amp;gt; &amp;lt;/div&amp;gt; /* h1要素の文字列を緑色 */ h1{ color: green; } /* p要素の文字列を青色 */ p{ font-weight: bold } for(var i=0; i&amp;lt;=5; i++){ document.</description>
    </item>
    
    <item>
      <title>Linked Open Data・統計LOD</title>
      <link>https://mukai-lab.info/pages/classes/seminar_database/chapter12/</link>
      <pubDate>Thu, 11 Jun 2020 15:33:32 +0900</pubDate>
      
      <guid>https://mukai-lab.info/pages/classes/seminar_database/chapter12/</guid>
      <description>統計LODとは  統計LODとは， 政府統計の総合窓口であるe-Statの情報を Linked Open Dataの形式で提供するサービスのことです． 国勢調査，人口推計，住民基本台帳人口移動報告，経済センサスなど， 国が調査したデータが管理されており， SPARQLのエンドポイントを介してデータの検索・取得が可能です． 今回は統計LODから東海三県における国勢調査の人口データを取得してみましょう．
ウェブページの作成  SPARQLの検索結果を表示するページを作成しましょう． 最初に index.html にリンクを追加します． 検索結果を表示するページは，lod.py というファイル名のCGIプログラムで作成します．
&amp;lt;ul&amp;gt; &amp;lt;li&amp;gt;&amp;lt;a href=&amp;#34;cgi-bin/js-api.py&amp;#34;&amp;gt;ジャパンサーチ 簡易Web API&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt; &amp;lt;li&amp;gt;&amp;lt;a href=&amp;#34;cgi-bin/js-sparql.py&amp;#34;&amp;gt;ジャパンサーチ SPARQL&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt; &amp;lt;li&amp;gt;&amp;lt;a href=&amp;#34;cgi-bin/dbpedia.py&amp;#34;&amp;gt;DBPedia&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt; &amp;lt;li&amp;gt;&amp;lt;a href=&amp;#34;cgi-bin/lod.py&amp;#34;&amp;gt;統計LOD&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt; &amp;lt;/ul&amp;gt; 
SPARQLで検索  統計LODのSPARQLのエンドポイントは下記のURLです．
http://data.e-stat.go.jp/lod/sparql/alldata/query
SPARQLの検索条件は下記のように記述します． 今回取得するのは，URL，ラベル(rdfs:label)， 人口(estat-measure:population)，年(cd-dimension:timePeriod)の4つのデータです． ここで，対象のデータセットとして， 2010年の国勢調査を対象としています． また，検索結果から 愛知県， 岐阜県，三重県の文字がラベルに含まれるコンテンツだけを抽出しています．
SELECT ?url ?label ?population ?year WHERE{ ?url qb:dataSet &amp;lt;http://data.e-stat.go.jp/lod/dataset/g00200521/d0003041389&amp;gt;; g00200521-dimension-2010:area g00200521-code-2010:area-all; sdmx-dimension:refArea [ rdfs:label ?label ]; estat-measure:population ?population; cd-dimension:timePeriod ?year; cd-dimension:sex cd-code:sex-all; cd-dimension:nationality cd-code:nationality-japan; cd-dimension:age cd-code:age-all.</description>
    </item>
    
    <item>
      <title>Linked Open Data・DBPedia</title>
      <link>https://mukai-lab.info/pages/classes/seminar_database/chapter11/</link>
      <pubDate>Thu, 11 Jun 2020 15:33:30 +0900</pubDate>
      
      <guid>https://mukai-lab.info/pages/classes/seminar_database/chapter11/</guid>
      <description>DBPediaとは  DBPediaは Wikipediaから情報を抽出し， Linked Open Data(LOD) として公開するプロジェクトのことです （LODはウェブでデータを公開・共有するための仕組みのこと）． DBPediaでは，人物，地理，音楽アルバム，映画，ビデオ・ゲーム， 組織・団体，生物種，病気などのデータが多言語で管理されており， ジャパンサーチと同様にSPARQLのエンドポイントを介してデータの検索・取得が可能です． 今回はDBPediaから愛知県出身の日本のアーティストを検索してみましょう．
ウェブページの作成  SPARQLの検索結果を表示するページを作成しましょう． 最初に index.html にリンクを追加します． 検索結果を表示するページは，dbpedia.py というファイル名のCGIプログラムで作成します．
&amp;lt;ul&amp;gt; &amp;lt;li&amp;gt;&amp;lt;a href=&amp;#34;cgi-bin/js-api.py&amp;#34;&amp;gt;ジャパンサーチ 簡易Web API&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt; &amp;lt;li&amp;gt;&amp;lt;a href=&amp;#34;cgi-bin/js-sparql.py&amp;#34;&amp;gt;ジャパンサーチ SPARQL&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt; &amp;lt;li&amp;gt;&amp;lt;a href=&amp;#34;cgi-bin/dbpedia.py&amp;#34;&amp;gt;DBPedia&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt; &amp;lt;/ul&amp;gt; 
SPARQLで検索  DBPediaのSPARQLのエンドポイントは下記のURLです．
http://ja.dbpedia.org/sparql
SPARQLの検索条件は下記のように記述します． 今回取得するのは，URL，名前(foaf:name)， 概要(dbpedia-owl:abstract)，出身地(prop-ja:origin)の4つのデータです． URLはジャンル(dbpedia-owl:genre) が　J-POP(dbpedia-ja:J-POP) であることを条件としています． また，検索結果から出身地に 愛知県 の文字が含まれるコンテンツだけを抽出しています．
SELECT ?url ?name ?abstract ?origin WHERE{ ?url dbpedia-owl:genre dbpedia-ja:J-POP; foaf:name ?name; dbpedia-owl:abstract ?abstract; prop-ja:origin ?origin. FILTER(CONTAINS(str(?origin), &amp;#34;愛知県&amp;#34;)) } 新規に dbpedia.py を作成し，cgi-binフォルダに配置します（実行権限の付与が必要）． dbpedia.py には下記のコードを記述します．</description>
    </item>
    
    <item>
      <title>ジャパンサーチで検索・SPARQL</title>
      <link>https://mukai-lab.info/pages/classes/seminar_database/chapter10/</link>
      <pubDate>Thu, 11 Jun 2020 12:34:52 +0900</pubDate>
      
      <guid>https://mukai-lab.info/pages/classes/seminar_database/chapter10/</guid>
      <description>SPARQLとは  SPARQLは， W3C によって標準化されている問い合わせ言語です． RDF と呼ばれる枠組みで記述された オンラインのデータベース（Linked Open Dataなど）にアクセスすることができます． 関係データベースの問い合わせ言語であるSQLによく似た文法で記述します．
ウェブページの作成  SPARQLの検索結果を表示するページを作成しましょう． 最初に index.html にリンクを追加します． 検索結果を表示するページは，js-sparql.py というファイル名のCGIプログラムで作成します．
&amp;lt;ul&amp;gt; &amp;lt;li&amp;gt;&amp;lt;a href=&amp;#34;cgi-bin/js-api.py&amp;#34;&amp;gt;ジャパンサーチ 簡易Web API&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt; &amp;lt;li&amp;gt;&amp;lt;a href=&amp;#34;cgi-bin/js-sparql.py&amp;#34;&amp;gt;ジャパンサーチ SPARQL&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt; &amp;lt;/ul&amp;gt; 
新規に js-sparql.py を作成し，cgi-binフォルダに配置します（実行権限の付与が必要）． js-sparql.py には下記のコードを記述します．
#!/usr/bin/env python print (&amp;#34;Content-type:text/html\n\n&amp;#34;) print(&amp;#34;&amp;lt;!DOCTYPE html&amp;gt;&amp;#34;) print(&amp;#34;&amp;lt;html&amp;gt;&amp;#34;) print(&amp;#34;&amp;lt;head&amp;gt;&amp;#34;) print(&amp;#34;&amp;lt;meta charset=&amp;#39;utf-8&amp;#39;&amp;gt;&amp;#34;) print(&amp;#34;&amp;lt;title&amp;gt;ジャパンサーチ SPARQL&amp;lt;/title&amp;gt;&amp;#34;) print(&amp;#34;&amp;lt;/head&amp;gt;&amp;#34;) print(&amp;#34;&amp;lt;body&amp;gt;&amp;#34;) print(&amp;#34;&amp;lt;h1&amp;gt;ジャパンサーチ SPARQL&amp;lt;/h1&amp;gt;&amp;#34;); print(&amp;#34;&amp;lt;/body&amp;gt;&amp;#34;) print(&amp;#34;&amp;lt;/html&amp;gt;&amp;#34;) 
SPARQLで検索  ジャパンサーチのSPARQLは， エンドポイントと呼ばれるURLにアクセスすることでコンテンツのデータを取得できます．
https://jpsearch.go.jp/rdf/sparql
まずは，エンドポイントにアクセスために，SPARQLWrapper ライブラリをインストールします．
% pip install sparqlwrapper インストールしたら，js-sparql.py で SPARQLWrapper ライブラリをインポートします．
from SPARQLWrapper import SPARQLWrapper, JSON それでは，SPARQLにアクセスしてみましょう． SPARQLの検索条件は主語，述語，目的語の組み合わせで構成されるRDFトリプル で表現します． 例えば，下記の条件は，主語が?</description>
    </item>
    
    <item>
      <title>ジャパンサーチで検索・簡易Web API</title>
      <link>https://mukai-lab.info/pages/classes/seminar_database/chapter9/</link>
      <pubDate>Thu, 11 Jun 2020 10:28:50 +0900</pubDate>
      
      <guid>https://mukai-lab.info/pages/classes/seminar_database/chapter9/</guid>
      <description>ジャパンサーチとは  ジャパンサーチとは 国立国会図書館が運用しているデジタルアーカイブであり， 日本が保有する多様なコンテンツとそのメタデータを検索できる仕組みになっています． 国立科学博物館や 国立民族学博物館など様々なデータベースと連携しており， 一括して検索できることも魅力の一つです．
ジャパンサーチでの検索方法には下記の2通りがあります
 簡易Web API SPARQL API．  簡易Web API は，ブラウザで指定されたURLにアクセスするだけでコンテンツの取得が可能です． また， SPARQL API は，問い合わせ言語であるSPARQLを利用して，様々な条件で検索が可能な機能です． 今回は簡易Web APIを利用してコンテンツを取得し，ウェブページに表示してみましょう．
ウェブページの作成  簡易Web APIの検索結果を表示するページを作成しましょう． 最初に index.html にリンクを追加します． 検索結果を表示するページは， js-api.py というファイル名のCGIプログラムで作成します．
&amp;lt;!DOCTYPE html&amp;gt; &amp;lt;html&amp;gt; &amp;lt;head&amp;gt; &amp;lt;meta charset=&amp;#34;utf-8&amp;#34;&amp;gt; &amp;lt;title&amp;gt;椙天市場&amp;lt;/title&amp;gt; &amp;lt;/head&amp;gt; &amp;lt;body&amp;gt; &amp;lt;h1&amp;gt;椙天市場&amp;lt;/h1&amp;gt; &amp;lt;ul&amp;gt; &amp;lt;li&amp;gt;&amp;lt;a href=&amp;#34;cgi-bin/users.py&amp;#34;&amp;gt;ユーザ情報&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt; &amp;lt;li&amp;gt;&amp;lt;a href=&amp;#34;cgi-bin/items.py&amp;#34;&amp;gt;商品情報&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt; &amp;lt;li&amp;gt;&amp;lt;a href=&amp;#34;cgi-bin/histories.py&amp;#34;&amp;gt;購買履歴&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt; &amp;lt;/ul&amp;gt; &amp;lt;ul&amp;gt; &amp;lt;li&amp;gt;&amp;lt;a href=&amp;#34;login.html&amp;#34;&amp;gt;ログイン&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt; &amp;lt;li&amp;gt;&amp;lt;a href=&amp;#34;management.html&amp;#34;&amp;gt;商品管理&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt; &amp;lt;/ul&amp;gt; &amp;lt;ul&amp;gt; &amp;lt;li&amp;gt;&amp;lt;a href=&amp;#34;cgi-bin/js-api.py&amp;#34;&amp;gt;ジャパンサーチ 簡易Web API&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt; &amp;lt;/ul&amp;gt; &amp;lt;/body&amp;gt; &amp;lt;/html&amp;gt; 
新規にjs-api.py を作成し，cgi-binフォルダに配置します（実行権限の付与が必要）． js-api.</description>
    </item>
    
    <item>
      <title>商品管理ページの作成</title>
      <link>https://mukai-lab.info/pages/classes/seminar_database/chapter8/</link>
      <pubDate>Wed, 10 Jun 2020 15:28:10 +0900</pubDate>
      
      <guid>https://mukai-lab.info/pages/classes/seminar_database/chapter8/</guid>
      <description>商品管理ページの作成  商品情報を格納しているItemsテーブルを管理するためのページを作成しましょう． 今回は，商品情報の 更新 と 追加 の機能を実装します． 最初に index.html に商品管理ページへのリンクを追加します． 商品管理ページは management.html というファイル名で作成することにします．
&amp;lt;!DOCTYPE html&amp;gt; &amp;lt;html&amp;gt; &amp;lt;head&amp;gt; &amp;lt;meta charset=&amp;#34;utf-8&amp;#34;&amp;gt; &amp;lt;title&amp;gt;椙天市場&amp;lt;/title&amp;gt; &amp;lt;/head&amp;gt; &amp;lt;body&amp;gt; &amp;lt;h1&amp;gt;椙天市場&amp;lt;/h1&amp;gt; &amp;lt;ul&amp;gt; &amp;lt;li&amp;gt;&amp;lt;a href=&amp;#34;cgi-bin/users.py&amp;#34;&amp;gt;ユーザ情報&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt; &amp;lt;li&amp;gt;&amp;lt;a href=&amp;#34;cgi-bin/items.py&amp;#34;&amp;gt;商品情報&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt; &amp;lt;li&amp;gt;&amp;lt;a href=&amp;#34;cgi-bin/histories.py&amp;#34;&amp;gt;購買履歴&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt; &amp;lt;/ul&amp;gt; &amp;lt;ul&amp;gt; &amp;lt;li&amp;gt;&amp;lt;a href=&amp;#34;login.html&amp;#34;&amp;gt;ログイン&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt; &amp;lt;li&amp;gt;&amp;lt;a href=&amp;#34;management.html&amp;#34;&amp;gt;商品管理&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt; &amp;lt;/ul&amp;gt; &amp;lt;/body&amp;gt; &amp;lt;/html&amp;gt; 
新規に management.html を作成し，sugitenフォルダに配置します． management.html には下記のコードを記述します． formタグを利用して，商品ID，商品名，価格，在庫数を入力するためのテキストフィールドと， データ送信のためのボタンを配置しています． ボタンをクリックすると，これらの情報をCGIのプログラムである insert.py に送信する設定になっています．
&amp;lt;!DOCTYPE html&amp;gt; &amp;lt;html&amp;gt; &amp;lt;head&amp;gt; &amp;lt;meta charset=&amp;#34;utf-8&amp;#34;&amp;gt; &amp;lt;title&amp;gt;商品管理&amp;lt;/title&amp;gt; &amp;lt;/head&amp;gt; &amp;lt;body&amp;gt; &amp;lt;h1&amp;gt;商品管理&amp;lt;/h1&amp;gt; &amp;lt;form method=&amp;#34;post&amp;#34; target=&amp;#34;_blank&amp;#34; action=&amp;#34;cgi-bin/insert.py&amp;#34;&amp;gt; &amp;lt;p&amp;gt;id: &amp;lt;input type=&amp;#34;text&amp;#34; name=&amp;#34;id&amp;#34; size=&amp;#34;20&amp;#34;&amp;gt;&amp;lt;/p&amp;gt; &amp;lt;p&amp;gt;name: &amp;lt;input type=&amp;#34;text&amp;#34; name=&amp;#34;name&amp;#34; size=&amp;#34;20&amp;#34;&amp;gt;&amp;lt;/p&amp;gt; &amp;lt;p&amp;gt;price: &amp;lt;input type=&amp;#34;text&amp;#34; name=&amp;#34;price&amp;#34; size=&amp;#34;20&amp;#34;&amp;gt;&amp;lt;/p&amp;gt; &amp;lt;p&amp;gt;stock: &amp;lt;input type=&amp;#34;text&amp;#34; name=&amp;#34;stock&amp;#34; size=&amp;#34;20&amp;#34;&amp;gt;&amp;lt;/p&amp;gt; &amp;lt;p&amp;gt;&amp;lt;input type=&amp;#34;submit&amp;#34; value=&amp;#34;追加&amp;#34;&amp;gt;&amp;lt;/p&amp;gt; &amp;lt;/form&amp;gt; &amp;lt;/body&amp;gt; &amp;lt;/html&amp;gt;</description>
    </item>
    
    <item>
      <title>商品情報の更新</title>
      <link>https://mukai-lab.info/pages/classes/seminar_database/chapter7/</link>
      <pubDate>Tue, 09 Jun 2020 11:29:37 +0900</pubDate>
      
      <guid>https://mukai-lab.info/pages/classes/seminar_database/chapter7/</guid>
      <description>商品情報の表示  ログインに成功したら，商品情報を画面に表示しましょう． main.py に商品情報を表示するためのshowItems関数を定義します． この関数では，SELECT文で商品の一覧を取得します．
# 商品情報の表示 def showItems(user_id): sql = &amp;#34;SELECT * from Items;&amp;#34; records = cur.execute(sql) print(&amp;#34;&amp;lt;h2&amp;gt;商品一覧&amp;lt;/h2&amp;gt;&amp;#34;) for record in records: print(&amp;#34;&amp;lt;p&amp;gt;&amp;#34; + str(record) + &amp;#34;&amp;lt;/p&amp;gt;&amp;#34;) main.py の下記部分で，定義したshowItems関数を呼び出します．
# ユーザ情報の検索・表示 showUserInfo(form_id) # ユーザの購買履歴の検索・表示 showUserHistory(form_id) # 商品情報の表示 showItems(form_id) ID:u01 ，パスワード:X2ng でログインしてみましょう． 下記のように表示されれば正しく動作しています．

上記の方法では，pタグで表示しているだけなので読み取りにくいです． そこで，tableタグで見た目を整形しておきます． このとき，商品名(name)，価格(price)，在庫数(stock)のみを表示することにします．
# 商品情報の表示 def showItems(user_id): sql = &amp;#34;SELECT * from Items;&amp;#34; records = cur.execute(sql) print(&amp;#34;&amp;lt;h2&amp;gt;商品一覧&amp;lt;/h2&amp;gt;&amp;#34;) table = &amp;#34;&amp;lt;table border=`1``&amp;gt;&amp;#34; table += &amp;#34;&amp;lt;tr&amp;gt;&amp;#34; table += &amp;#34;&amp;lt;th&amp;gt;name&amp;lt;/th&amp;gt;&amp;#34; table += &amp;#34;&amp;lt;th&amp;gt;price&amp;lt;/th&amp;gt;&amp;#34; table += &amp;#34;&amp;lt;th&amp;gt;stock&amp;lt;/th&amp;gt;&amp;#34; table += &amp;#34;&amp;lt;/tr&amp;gt;&amp;#34; for record in records: table += &amp;#34;&amp;lt;tr&amp;gt;&amp;#34; item_id = record[0] name = record[1] price = record[2] stock = record[3] table += &amp;#34;&amp;lt;td&amp;gt;&amp;#34; table += str(name) table += &amp;#34;&amp;lt;/td&amp;gt;&amp;#34; table += &amp;#34;&amp;lt;td&amp;gt;&amp;#34; table += str(price) table += &amp;#34;&amp;lt;/td&amp;gt;&amp;#34; table += &amp;#34;&amp;lt;td&amp;gt;&amp;#34; table += str(stock) table += &amp;#34;&amp;lt;/td&amp;gt;&amp;#34; table += &amp;#34;&amp;lt;/tr&amp;gt;&amp;#34; table += &amp;#34;&amp;lt;/table&amp;gt;&amp;#34; print(table) この結果，下記のように表示されればOKです．</description>
    </item>
    
    <item>
      <title>ユーザ情報の検索</title>
      <link>https://mukai-lab.info/pages/classes/seminar_database/chapter6/</link>
      <pubDate>Mon, 08 Jun 2020 14:56:41 +0900</pubDate>
      
      <guid>https://mukai-lab.info/pages/classes/seminar_database/chapter6/</guid>
      <description>ユーザ情報の検索  ログインに成功したら， Usersテーブルからユーザの名前や電話番号などの情報を検索し， 画面に表示しましょう． main.py にユーザ情報を検索・表示するための showUserInfo関数を定義します． この関数では，SELECT文とWHERE句を利用して， 指定されたユーザIDの氏名，電話番号，メールアドレスを検索します． また，検索された情報はpタグで表示されます．
# ユーザ情報の検索・表示 def showUserInfo(id): sql = &amp;#34;SELECT name,tel,mail FROM Users WHERE id=&amp;#39;&amp;#34; + id + &amp;#34;&amp;#39;;&amp;#34; records = cur.execute(sql) record = records.fetchone() name = record[0] tel = record[1] mail = record[2] print(&amp;#34;&amp;lt;p&amp;gt;氏名: &amp;#34; + name + &amp;#34;&amp;lt;/p&amp;gt;&amp;#34;) print(&amp;#34;&amp;lt;p&amp;gt;電話番号: &amp;#34; + tel + &amp;#34;&amp;lt;/p&amp;gt;&amp;#34;) print(&amp;#34;&amp;lt;p&amp;gt;メールアドレス: &amp;#34; + mail + &amp;#34;&amp;lt;/p&amp;gt;&amp;#34;) main.py の下記部分で， 定義したshowUserInfo関数を呼び出します． ログインに成功したときだけ，ユーザの情報が表示されることに注意してください．
if pw == None: print(&amp;#34;&amp;lt;p&amp;gt;IDが存在しません&amp;lt;/p&amp;gt;&amp;#34;) print(&amp;#34;&amp;lt;p&amp;gt;&amp;lt;a href=&amp;#39;.</description>
    </item>
    
    <item>
      <title>ログインページの作成</title>
      <link>https://mukai-lab.info/pages/classes/seminar_database/chapter5/</link>
      <pubDate>Sun, 07 Jun 2020 13:23:18 +0900</pubDate>
      
      <guid>https://mukai-lab.info/pages/classes/seminar_database/chapter5/</guid>
      <description>ログインページの作成  ユーザ情報を格納しているUsersテーブルを利用して， ユーザのログインページを作成しましょう． ログインには，ユーザーのIDとパスワードを照合する機能が必要です． 最初にindex.htmlにログインページへのリンクを追加します． ログインページは login.html というファイル名で作成することにします．
&amp;lt;body&amp;gt; &amp;lt;h1&amp;gt;椙天市場&amp;lt;/h1&amp;gt; &amp;lt;ul&amp;gt; &amp;lt;li&amp;gt;&amp;lt;a href=&amp;#34;cgi-bin/users.py&amp;#34;&amp;gt;ユーザー情報&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt; &amp;lt;li&amp;gt;&amp;lt;a href=&amp;#34;cgi-bin/items.py&amp;#34;&amp;gt;商品情報&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt; &amp;lt;li&amp;gt;&amp;lt;a href=&amp;#34;cgi-bin/histories.py&amp;#34;&amp;gt;購買履歴&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt; &amp;lt;/ul&amp;gt; &amp;lt;ul&amp;gt; &amp;lt;li&amp;gt;&amp;lt;a href=&amp;#34;login.html&amp;#34;&amp;gt;ログイン&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt; &amp;lt;/ul&amp;gt; &amp;lt;/body&amp;gt; 
新規に login.html を作成し，sugitenフォルダに配置します（実行権限の付与が必要）．． login.html には下記のコードを記述します． formタグを利用して，IDとパスワードを入力するためのテキストフィールドと， データ送信のためのボタンを配置しています． ボタンをクリックすると IDとパスワードの情報をCGIのプログラムであるmain.py に送信する設定になっています．
&amp;lt;!DOCTYPE html&amp;gt; &amp;lt;html&amp;gt; &amp;lt;head&amp;gt; &amp;lt;meta charset=&amp;#34;utf-8&amp;#34;&amp;gt; &amp;lt;title&amp;gt;ログイン&amp;lt;/title&amp;gt; &amp;lt;/head&amp;gt; &amp;lt;body&amp;gt; &amp;lt;h1&amp;gt;ログイン&amp;lt;/h1&amp;gt; &amp;lt;form method=&amp;#34;post&amp;#34; action=&amp;#34;cgi-bin/main.py&amp;#34;&amp;gt; &amp;lt;p&amp;gt;id: &amp;lt;input type=&amp;#34;text&amp;#34; name=&amp;#34;id&amp;#34; size=&amp;#34;20&amp;#34;&amp;gt;&amp;lt;/p&amp;gt; &amp;lt;p&amp;gt;password: &amp;lt;input type=&amp;#34;password&amp;#34; name=&amp;#34;password&amp;#34; size=&amp;#34;20&amp;#34;&amp;gt;&amp;lt;/p&amp;gt; &amp;lt;p&amp;gt;&amp;lt;input type=&amp;#34;submit&amp;#34; value=&amp;#34;ログイン&amp;#34;&amp;gt;&amp;lt;/p&amp;gt; &amp;lt;/form&amp;gt; &amp;lt;/body&amp;gt; &amp;lt;/html&amp;gt; 
ユーザの認証  ユーザのIDとパスワードの認証機能を main.py に実装します． 新規に main.</description>
    </item>
    
    <item>
      <title>データベースの表示</title>
      <link>https://mukai-lab.info/pages/classes/seminar_database/chapter4/</link>
      <pubDate>Sun, 07 Jun 2020 10:50:18 +0900</pubDate>
      
      <guid>https://mukai-lab.info/pages/classes/seminar_database/chapter4/</guid>
      <description>SQLiteデータベースの確認  前回作成した sugiten フォルダに， SQLiteで作成したデータベースファイル sugiten.db をコピーします （cgi-binではないことに注意）． SQLite で sugiten.db を開き，保存されているテーブルを確認しましょう． ユーザの情報を保持するUsersには4件， 商品の情報を保持するItemsには6件， 購買履歴を保持するHistoriesには4件のレコードが登録されています．
sqlite&amp;gt; .open sugiten.db sqlite&amp;gt; .database main: /sugiten/sugiten.db sqlite&amp;gt; .table Histories Items Users sqlite&amp;gt; .header on sqlite&amp;gt; select * from Users; id|password|name|tel|mail u01|X2ng|中谷俊介|090-1111-1111|shunsuke@mail.jp u02|fL4m|永松克也|090-2222-2222|katsuya@mail.jp u03|hY8W|神野愛美|090-3333-3333|aimi@mail.jp u04|jY4p|大久真鈴|090-4444-4444|masuzu@mail.jp sqlite&amp;gt; select * from Items; id|name|price|stock i01|マウス|2000|10 i02|パソコン|150000|5 i03|キーボード|3000|10 i04|モニタ|40000|3 i05|ウェブカメラ|6000|5 i06|ノートパソコン|170000|3 sqlite&amp;gt; select * from Histories; id|time|user_id|item_id 1|2020-01-01 12:00:00|u01|i01 2|2020-01-02 14:00:00|u02|i02 3|2020-01-02 18:00:00|u01|i04 4|2020-01-03 12:00:00|u04|i02 データベースの表示  それではCGIを利用してデータベース sugiten.</description>
    </item>
    
    <item>
      <title>Pythonでウェブサーバの構築</title>
      <link>https://mukai-lab.info/pages/classes/seminar_database/chapter3/</link>
      <pubDate>Sat, 06 Jun 2020 10:30:31 +0900</pubDate>
      
      <guid>https://mukai-lab.info/pages/classes/seminar_database/chapter3/</guid>
      <description>Pythonのインストール  本講義ではデータベースと連携したウェブサイトを構築します． 本来は，Apacheなどのソフトウェアを利用してウェブサーバを構築する必要がありますが， ここではPythonのhttp.serverモジュールを利用してローカル環境の簡易ウェブサーバとします．
それでは，Pythonのインストール・パッケージをダウンロードしてください． このとき，Pythonのバージョンは3.xを選択してください． インストールを始める前に，ファイルをインストールするためのフォルダを作成します． 大学で環境を構築する場合は，Hドライブ に，MyPythonという名前でフォルダを作成してください （人工知能など他の授業で既にインストール済みの場合は作業は不要）．
それでは，インストーラを実行しましょう． Customize installationを選択し， パッケージ管理システムの pip が同時にインストールされることを確認してください．


このとき，インストールするフォルダは，上記で作成したH:\MyPythonとすることに注意してください．

インストールが終了すると，下記のダイアログが表示されます． Closeを選択して，ダイアログを閉じてください．

最後に，インストールしたPythonへのパスを 環境変数 に追加します． 任意のフォルダで，パワーシェルを起動して，下記コマンドが実行できれば準備OKです．
% python -V Python 3.7.4 ウェブサーバの構築  Pythonを利用してウェブサーバを構築します． 作業用の空のフォルダ sugiten を作成し， パワーシェルを起動して，下記のコマンドを実行してください．
% python -m http.server 8080 Serving HTTP on 0.0.0.0 port 8080 (http://0.0.0.0:8080/) ... これで，ローカル環境でウェブサーバが起動しています． ブラウザでhttp://0.0.0.0:8080/にアクセスしてみましょう． 下記の画面が表示されていればOKです．

次に，新規にindex.html を作成し，sugitenフォルダに配置します． index.htmlには下記のコードを記述します． タイトルやヘッダに 椙天市場 という文字列を設定しています．
&amp;lt;!DOCTYPE html&amp;gt; &amp;lt;html&amp;gt; &amp;lt;head&amp;gt; &amp;lt;meta charset=&amp;#34;utf-8&amp;#34;&amp;gt; &amp;lt;title&amp;gt;椙天市場&amp;lt;/title&amp;gt; &amp;lt;/head&amp;gt; &amp;lt;body&amp;gt; &amp;lt;h1&amp;gt;椙天市場&amp;lt;/h1&amp;gt; &amp;lt;/body&amp;gt; &amp;lt;/html&amp;gt; ブラウザでhttp://0.</description>
    </item>
    
    <item>
      <title>SQLiteデータベースの作成</title>
      <link>https://mukai-lab.info/pages/classes/seminar_database/chapter2/</link>
      <pubDate>Thu, 04 Jun 2020 17:13:43 +0900</pubDate>
      
      <guid>https://mukai-lab.info/pages/classes/seminar_database/chapter2/</guid>
      <description>SQLite  SQLiteは， データベースシステムでも利用したリレーショナルデータベース管理システム（RDBMS）の一つです． 公式サイトから Precompiled Binaries for Windows（sqlite-tools-win32-x86-xxxx.zip）をダウンロードして展開してください． 複数のパッケージが存在しますが，コマンドライン・ツール（sqlite3.exe）を含むパッケージを選択するようにしてください．
SQLiteのダウンロード
インストールが完了したら，インストールされたフォルダに含まれる コマンドライン・ツール（sqlite3.exe）をダブルクリックして起動してください． 下図のようなコマンド入力が可能なターミナルが表示されます．

データベースの作成  本講義では，架空のオンライン・ショッピングサイト 椙天市場 のサービス構築を想定して，下記の3種類のテーブルを作成します． usersは，サイトのユーザー情報を格納するテーブルです． ユーザID，パスワード，氏名，電話番号，メールアドレスの情報を管理します． itemsは，サイトで取り扱う商品の情報を格納するテーブルです． 商品ID，商品名，価格，在庫数の情報を管理します． historiesは，ユーザによる商品の購買履歴を格納するテーブルです． 取引ID，取引日，ユーザID，商品IDの情報を管理します．
 Users（ユーザの情報） Items（商品の情報） Histories（商品の購買履歴）  データベースの作成 まずはデータベースを作成します． .openコマンドで sugiten.db という名前のデータベースを作成します． .databaseコマンドでメインのデータベースがsugiten.dbになっていることを確認します．
sqlite&amp;gt; .open sugiten.db sqlite&amp;gt; .database main: /Users/naoto/sugiten.db Usersテーブルの作成 ユーザの情報を格納するUsersテーブルをCREATE文で作成します． 主キーは id であることに注意してください．
CREATE TABLE Users( id text primary key, password text, name text, tel text, mail text ); テーブルを作成したら，.tableコマンドで確認しましょう．
sqlite&amp;gt; .table Users 次にINSERT文でレコードを追加します． 今回はパスワードをそのまま平文で記録していますが， 実際のデータベースでは，ハッシュ関数を利用してパスワードは暗号化されます．</description>
    </item>
    
    <item>
      <title>データベースとウェブサイトの連携</title>
      <link>https://mukai-lab.info/pages/classes/seminar_database/chapter1/</link>
      <pubDate>Thu, 04 Jun 2020 15:02:03 +0900</pubDate>
      
      <guid>https://mukai-lab.info/pages/classes/seminar_database/chapter1/</guid>
      <description>履修者に望むこと  本講義は，データベースシステムで解説した データベースに関連する知識や技術を習得済みであることを前提としています． 特にデータベース管理システムの一つであるSQLiteと， 問い合わせ言語である SQL を中心にコンテンツは構成されていますので， データベースシステムの未履修者は，独学でこれらの技術を習得することを強く望みます．
この講義の目的は「データベースと連携したウェブサイトを構築する」ことです． この目的を達成するには，上述の知識や技術に加えて，下記の技術要素が必要となります． 複数の技術要素を組み合わせた難易度が高い講義となりますので， 毎回の予習・復習を怠らず，授業に臨んでください．
 Python（ウェブサーバの構築） HTML &amp;amp; CSS（ウェブページの記述） オープンデータ（Japan Searchや統計LODなど） SPARQL（LODへの問い合わせ）  また，この授業では，作成した環境（サーバやファイルなど）を継続して利用します． このため，欠席すると，次回からの授業についていけなくなることが予想されます． 止むを得ない事情で欠席することがあると思いますが，遅れた分は自力で取り返す努力をしてください．
ウェブサイトとの連携  本講義ではデータベース管理システムのSQLiteで， テーブルの作成・更新などの操作を行います． PythonのSQLite3モジュールを利用することで， Pythonからこれらの操作を実行することが可能です．
例えば，下記のPythonのソースコードは， データベース sample.db に接続し， SQLを用いてテーブル students のレコードを取得しています． このようにPythonからデータベースを操作することで， ウェブページに表示する情報を制御します．
import sqlite3 con = sqlite3.connect(&amp;#39;sample.db&amp;#39;) # データベースに接続 cur = con.cursor() # カーソルを取得 cur.execute(&amp;#34;SELECT * FROM students&amp;#34;) # SQL文を実行 con.close() # データベースを切断 また，Pythonにはウェブサーバを実装するための http.serverモジュールがあります． このモジュールを利用することで，ApacheやNginx などの専用のサーバソフトウェアを導入せずに，簡易なローカルのウェブサーバを構築することができます．
例えば，ターミナル（コマンドプロンプトなど）で， 下記のコマンドを実行することで，8000番ポートにウェブサーバが起動します．
% python -m http.</description>
    </item>
    
    <item>
      <title>データベース演習</title>
      <link>https://mukai-lab.info/pages/classes/seminar_database/</link>
      <pubDate>Thu, 04 Jun 2020 14:36:48 +0900</pubDate>
      
      <guid>https://mukai-lab.info/pages/classes/seminar_database/</guid>
      <description>授業科目区分： 専門教育科目
単位数: 1単位
開講学科: 文化情報学科
学年: 3年次
関連科目: データベースシステム
授業テーマ: 関係データベースを利用したウェブサイトの構築
授業内容 2年次に開講される「データベースシステム」の内容を踏まえ， 関係データベースとウェブサイトを連携して運用する方法を学ぶ．ウ ェブサーバにはPythonを採用し，CGI（Common Gate Interface）を利用してデータベースにアクセスする． また，オンライン上のデータベースにアクセス可能なSPARQLと呼ばれる問い合わせ言語についても学習する．
授業計画  データベースとウェブサイトの連携 SQLiteデータベースの作成 Pythonでウェブサーバの構築 ウェブサイトでSQL（１）・データベースの表示 ウェブサイトでSQL（２）・ログインページの作成 ウェブサイトでSQL（３）・ユーザ情報の検索 ウェブサイトでSQL（４）・商品情報の更新 ウェブサイトでSQL（５）・商品管理ページの追加 ジャパンサーチで検索（１）・簡易Web API ジャパンサーチで検索（２）・SPARQL Linked Open Data（１）・DBPedia Linked Open Data（２）・統計LOD  参考書籍</description>
    </item>
    
    <item>
      <title>マツさんの卒業式</title>
      <link>https://mukai-lab.info/posts/2020-04-01-comic_141/</link>
      <pubDate>Wed, 01 Apr 2020 18:00:00 +0900</pubDate>
      
      <guid>https://mukai-lab.info/posts/2020-04-01-comic_141/</guid>
      <description></description>
    </item>
    
    <item>
      <title>データベースシステム</title>
      <link>https://mukai-lab.info/pages/classes/database_system/</link>
      <pubDate>Wed, 18 Mar 2020 17:21:03 +0900</pubDate>
      
      <guid>https://mukai-lab.info/pages/classes/database_system/</guid>
      <description>授業科目区分： 専門教育科目
単位数: 2単位
開講学科: 文化情報学科
学年: 2年次
関連科目: データベース演習
授業テーマ: データベースの基本的な理論とSQLの習得
授業内容 データベースの中核である関係データモデルを基本に， 構造記述・意味記述，関係代数などの理論を学習する. また，データベース管理システムの１つであるSQLiteを用いて， SQLによるデータベースの検索・更新・関数などの機能について実習する. 後半は大規模データの処理に適したNoSQLと呼ばれる新しい技術に関して解説する.
授業計画  データベースとは リレーションと第1正規形 主キーと外部キー 関係代数演算 情報無損失分解と関数従属性 第2正規形と第3正規形 SQL(1)・データベースの作成 SQL(2)・データの更新 SQL(3)・データの検索 SQL(4)・関係代数演算 SQL(5)・トランザクション NoSQL(1)・Key-Valueストア型データベース NoSQL(2)・ドキュメント指向データベース データベースを利用したウェブサイトの構築  補足資料  高次の正規化 インデックス  旧資料(2020年度まで)  SQL(1)・データベースの作成(SQLite版) SQL(2)・データの更新(SQLite版) SQL(3)・データの検索(SQLite版) SQL(4)・関係代数演算(SQLite版) SQL(5)・トランザクション(SQLite版)  参考書籍</description>
    </item>
    
    <item>
      <title>Pythonの基本</title>
      <link>https://mukai-lab.info/pages/classes/artificial_intelligence/chapter2/</link>
      <pubDate>Wed, 18 Mar 2020 16:01:10 +0900</pubDate>
      
      <guid>https://mukai-lab.info/pages/classes/artificial_intelligence/chapter2/</guid>
      <description>Pythonとは  Python はオランダ出身のプログラマーGuido Van Rossum氏が1991年に開発したプログラミング言語です． C言語やJavaに比べ，文法がシンプルであり，高い可読性を持っています． 例えば，多くのプログラミング言語では，コードの固まり（ブロック）を {}（中括弧） で表現することが多くあります． 一方，Pythonでは， 字下げ（インデント） を利用して，ブロックを表現します． また，豊富なライブラリが利用可能であり，パッケージ管理ツール（pipなど）を利用して，手軽に導入可能という特徴もあります．
コーディング， 実行， デバッグ という一連のプロセスも簡単であり， 手を動かしながら学ぶには最適なプログラミング言語と言えるでしょう． 今回は，人工知能技術を学ぶ前準備として， Python の基本的な文法について学びます．
ノートブックの作成  Google Colaboratory を起動し，新規にノートブックを作成してください． ノートブックのタイトルは AI-2 とします． ノートブックの作成方法は第1回の資料を参照してください．
四則演算  一般的な四則演算が利用可能です． セルに加算（+），減算（-），乗算（*），除算（/），剰余（%），累乗（**）を入力して，結果を確認してみましょう． 乗算・除算などは，我々が通常用いている$\times$や$\div$などの演算子とは異なることに注意してください．
   演算 演算子 例     加算 + 3 + 2 -&amp;gt; 5   減算 - 3 - 2 -&amp;gt; 1   乗算 * 3 * 2 -&amp;gt; 6   除算 / 3 / 2 -&amp;gt; 1.</description>
    </item>
    
    <item>
      <title>人工知能とは</title>
      <link>https://mukai-lab.info/pages/classes/artificial_intelligence/chapter1/</link>
      <pubDate>Wed, 18 Mar 2020 16:01:09 +0900</pubDate>
      
      <guid>https://mukai-lab.info/pages/classes/artificial_intelligence/chapter1/</guid>
      <description>人工知能とは  この授業では，人工知能 の理論と実践を学びます． 近年注目される人工知能の殆どは 機械学習 と呼ばれる技術の応用であり， 顔認識や商品推薦など様々な用途に用いられるようになりました．
一方で，人工知能の歴史は，1956年のダートマス会議 から始まり， 1950年代の 第1次AIブーム，また，1980年代の 第2次AIブーム などの紆余曲折を経て， 現在の機械学習を主役とした 第3次AIブーム に繋がっています．
第1次ブームでは，探索 と 推論 と呼ばれる技術の研究が進み， パズルや迷路などの問題を人間より高速に解くことが出来るようになりました． また，第2次ブームでは， エキスパートシステム と呼ばれる 専門知識の分野を取り込んだコンピュータが開発されました．
人工知能を学ぶには，これら伝統的な知識や技術を習得することが重要です． 本講義では， パズルやゲームなどを題材に， 探索や推論の基本的なアルゴリズムを体験的に学ぶことを目標とします． また，遺伝的アルゴリズムや強化学習など， 第3次ブームに繋がる発展的な技術についても取り上げます．
アルゴリズムの実装にはPythonを採用し， Google Colaboratoryを利用してコーディングします （2020年度まではJupyter Notebookを利用）．
また，探索アルゴリズムや遺伝的アルゴリズムの実装にはSimple AI， 強化学習の実装にはOpenAI Gymなど最新のライブラリを使用します． 机上の理論で終わることなく，実用的な問題に人工知能技術を適用する術を学びましょう．


Google Colaboratory  2021年度からは，ブラウザでPythonの実装が可能なGoogle Colaboratoryを利用します． Jupyter Notebookとは異なりソフトウェアのインストールが不要であることから，PC環境を問わず利用することができます． また，ユーザ・インタフェースはJupyter Notebookと殆ど同じであり，違和感なく利用することが可能です． ただし，パッケージ（ライブラリ）のインスール方法には注意が必要です．
Jupyter Notebookではコマンド・プロンプトなどでpipコマンドを利用してインストールします．
$pip install sipleai 一方，Google Colaboratoryではpipコマンドを利用することは同じですが， pipコマンドの先頭に!を付けて実行するとインストールが可能です．
!pip install simpleai 
Jupyter Notebookのインストール  [Python](https://www.</description>
    </item>
    
    <item>
      <title>局所探索アルゴリズム・シミュレーテッドアニーリング</title>
      <link>https://mukai-lab.info/pages/classes/artificial_intelligence/chapter9/</link>
      <pubDate>Wed, 18 Mar 2020 12:19:16 +0900</pubDate>
      
      <guid>https://mukai-lab.info/pages/classes/artificial_intelligence/chapter9/</guid>
      <description>ノートブックの作成  Google Colaboratory を起動し，新規にノートブックを作成してください． ノートブックのタイトルは AI-9 とします． ノートブックの作成方法に関しては第1回の資料を参考にしてください．
最初に Simple AI をインストールします． セルで下記のコマンドを実行してください．
!pip install simpleai 最適化問題  今回も 最適化問題 を取り上げます．
最適化問題   下記の関数の値が最大となる$x$を求めよ．ただし，$x$の範囲は$0 \leq x \leq 20$とする．$$f(x) = x^3 - 30 x^2 + 275x + 50$$ 最適化問題の状態空間モデルを確認しておきます．
状態空間モデル   状態は$x(0 \leq x \leq 20)$で表す．ただし，$x$は連続値ではなく，$0.1$で刻んだ離散値とする．また，現在の状態$x$から，$\pm{\Delta x}$だけ増減することを行動と定義する．ここでは，$\Delta x=0.5$に設定し，$+0.5$，または，$-0.5$だけ増減させる．$x&#39; = x + 0.5$$x&#39; = x - 0.</description>
    </item>
    
    <item>
      <title>局所探索アルゴリズム・山登り法</title>
      <link>https://mukai-lab.info/pages/classes/artificial_intelligence/chapter8/</link>
      <pubDate>Wed, 18 Mar 2020 12:19:13 +0900</pubDate>
      
      <guid>https://mukai-lab.info/pages/classes/artificial_intelligence/chapter8/</guid>
      <description>ノートブックの作成  Google Colaboratory を起動し，新規にノートブックを作成してください． ノートブックのタイトルは AI-8 とします． ノートブックの作成方法に関しては第1回の資料を参考にしてください．
最初に Simple AI をインストールします． セルで下記のコマンドを実行してください．
!pip install simpleai 最適化問題  今回は 最適化問題 を取り上げます． 最適化問題は，対象となる関数について， その値が最大（もしくは最小）となる状態を見つけることが目的となります．
最適化問題   下記の関数の値が最大となる$x$を求めよ．ただし，$x$の範囲は$0 \leq x \leq 20$とする．$$f(x) = -(x - 10)^2$$ 最適化問題の状態空間モデルを定義します．
状態空間モデル   状態は$x(0 \leq x \leq 20)$で表す．ただし，$x$は連続値ではなく，$0.1$で刻んだ離散値とする．また，現在の状態$x$から，$\pm{\Delta x}$だけ増減することを行動と定義する．ここでは，$\Delta x=0.1$に設定し，$+0.1$，または，$-0.1$だけ増減させる．$x&#39; = x + 0.1$$x&#39; = x - 0.1$初期状態は$0 \leq x \leq 20$の範囲でランダムに選んだ値とし，目的状態は$f(x)$を最大化することである． 山登り法（Hill Climbing Method）  現在の状態の近傍の中で最も評価の高い状態を選択することを， 評価の改善がなくなるまで繰り返す手法です． 局所探索アルゴリズムの一つであり，最もシンプルでポピュラーな手法です．</description>
    </item>
    
    <item>
      <title>探索アルゴリズム・ヒューリスティック探索</title>
      <link>https://mukai-lab.info/pages/classes/artificial_intelligence/chapter7/</link>
      <pubDate>Tue, 17 Mar 2020 13:44:45 +0900</pubDate>
      
      <guid>https://mukai-lab.info/pages/classes/artificial_intelligence/chapter7/</guid>
      <description>ノートブックの作成  Google Colaboratory を起動し，新規にノートブックを作成してください． ノートブックのタイトルは AI-7 とします． ノートブックの作成方法に関しては第1回の資料を参考にしてください．
最初に Simple AI をインストールします． セルで下記のコマンドを実行してください．
!pip install simpleai 迷路問題  今回も前回と同じ 迷路問題を取り上げます．
迷路問題   初期状態$A$から目的状態$Y$に至るまでの最短経路とコスト（距離）を求めよ．ただし，隣り合う状態への移動にかかるコストは$1$とする． 迷路問題の状態空間モデルを確認しておきましょう．
状態空間モデル   $A$から$Y$までの25の状態から，冗長な状態を取り除く．例えば，$A \rightarrow B \rightarrow C \rightarrow D \rightarrow E$という経路においては，$B$，$C$，$D$に分岐は存在せず，通り抜けることしかしないため，これらの状態を省略する．この結果，$S1$から$S17$までの，17通りの状態で問題を表現する．行動は移動可能な状態のペアとして定義する．例えば，$S1$からは，$S2$と$S7$に移動可能なため，下記のように表現できる．$S1 \rightarrow S2$$S1 \rightarrow S7$同様に全ての状態について列挙すると，合わせて31通りの行動が定義できる． See the Pen 迷路問題 by Naoto Mukai (@nmukai)on CodePen.ヒューリスティック探索  前回紹介した幅優先探索と深さ優先探索は知識を用いない探索手法でした． ヒューリスティック探索とは，必ず正解に到達できるわけではないけれど， ある程度のレベルで正解に近い解を得ることが出来る知識（ヒューリスティックス） を利用した探索手法のことです．</description>
    </item>
    
    <item>
      <title>探索アルゴリズム・幅優先探索と深さ優先探索</title>
      <link>https://mukai-lab.info/pages/classes/artificial_intelligence/chapter6/</link>
      <pubDate>Mon, 16 Mar 2020 16:11:45 +0900</pubDate>
      
      <guid>https://mukai-lab.info/pages/classes/artificial_intelligence/chapter6/</guid>
      <description>ノートブックの作成  Google Colaboratory を起動し，新規にノートブックを作成してください． ノートブックのタイトルは AI-6 とします． ノートブックの作成方法は第1回の資料を参照してください．
最初に Simple AI をインストールします． セルで下記のコマンドを実行してください．
!pip install simpleai 迷路問題  今回は 迷路問題 を独自に設計します．
迷路問題   初期状態$A$から目的状態$Y$に至るまでの最短経路とコスト（距離）を求めよ．ただし，隣り合う状態への移動にかかるコストは$1$とする． この問題を 状態空間モデル で表現します．
状態空間モデル   $A$から$Y$までの25の状態から，冗長な状態を取り除く．例えば，$A \rightarrow B \rightarrow C \rightarrow D \rightarrow E$という経路においては，$B$，$C$，$D$に分岐は存在せず，通り抜けることしかしないため，これらの状態を省略する．この結果，$S1$から$S17$までの，17通りの状態で問題を表現する．行動は移動可能な状態のペアとして定義する．例えば，$S1$からは，$S2$と$S7$に移動可能なため，下記のように表現できる．$S1 \rightarrow S2$$S1 \rightarrow S7$同様に全ての状態について列挙すると，合わせて31通りの行動が定義できる． See the Pen Untitled by Naoto Mukai (@nmukai)on CodePen.</description>
    </item>
    
    <item>
      <title>遺伝的アルゴリズム・フロイド問題</title>
      <link>https://mukai-lab.info/pages/classes/artificial_intelligence/chapter10/</link>
      <pubDate>Sun, 15 Mar 2020 10:32:41 +0900</pubDate>
      
      <guid>https://mukai-lab.info/pages/classes/artificial_intelligence/chapter10/</guid>
      <description>ノートブックの作成  Google Colaboratory を起動し，新規にノートブックを作成してください． ノートブックのタイトルは AI-10 とします． ノートブックの作成方法は第1回の資料を参照してください．
最初に Simple AI をインストールします． セルで下記のコマンドを実行してください．
!pip install simpleai フロイド問題  今回は フロイド問題(Floyd Problem) を取り上げましょう．
フロイド問題   1から10までの整数を$A$と$B$の2つのグループに分ける．このとき，各グループの整数の平方根の和を求め，その差の絶対値を目的関数$g(A,B)$とする．この目的関数が最小となるグループ$A$，$B$を求めよ．例えば，グループ$A$を奇数，グループ$B$を偶数とするとき，目的関数の値は$1.24$となる．$$A=\{1, 3, 5, 7, 9\}$$$$B=\{2, 4, 6, 8, 10\}$$$$f(A) = \sqrt{1} + \sqrt{3} + \sqrt{5} + \sqrt{7} + \sqrt{9} \simeq 10.61$$$$f(B) = \sqrt{2} + \sqrt{4} + \sqrt{6} + \sqrt{8} + \sqrt{10} \simeq 11.</description>
    </item>
    
    <item>
      <title>強化学習・タクシーゲーム</title>
      <link>https://mukai-lab.info/pages/classes/artificial_intelligence/chapter16/</link>
      <pubDate>Thu, 12 Mar 2020 18:47:35 +0900</pubDate>
      
      <guid>https://mukai-lab.info/pages/classes/artificial_intelligence/chapter16/</guid>
      <description>ノートブックの作成  Jupyter Notebook を起動し，新規にノートブックを作成してください． ノートブックのタイトルは AI-16 とします． ノートブックの作成方法は第1回の資料を参照してください．
最初にOpenAI Gym をインストールします． セルで下記のコマンドを実行してください．
&amp;gt; !pip install gym また，OpenAI Gymに加え，下記のライブラリも導入しておきましょう．
import gym import numpy as np import random import time from google.colab import output from tqdm.notebook import tqdm タクシーゲーム（Taxi）  タクシーゲーム（Taxi）は，乗車地まで移動し，お客を乗せて（Pickup），降車地まで移動し，お客を降ろす（Drop off）ことを目的としたゲームです．
環境は下記のように$5\times5$で表されます． R(Red) ，G(Green) ，Y(Yellow) ，B(Blue) は， お客の乗車地，または，降車地です． また，| は壁であり，タクシーが通過することはできません．
+---------+ |R: | : :G| | : | : : | | : : : : | | | : | : | |Y| : |B: | +---------+ タクシーが観測できる情報は，タクシーの位置座標taxi_row，taxi_col，お客の乗車位置（状態）pass_loc，お客の降車位置dest_idxです．</description>
    </item>
    
    <item>
      <title>強化学習・山登りゲーム</title>
      <link>https://mukai-lab.info/pages/classes/artificial_intelligence/chapter3_2020/</link>
      <pubDate>Thu, 12 Mar 2020 18:47:35 +0900</pubDate>
      
      <guid>https://mukai-lab.info/pages/classes/artificial_intelligence/chapter3_2020/</guid>
      <description>ノートブックの作成  Jupyter Notebook を起動し，新規にノートブックを作成してください． ノートブックのタイトルは AI-3 とします． ノートブックの作成方法は第1回の資料を参照してください．
山登りゲーム（MountainCar）  山登りゲームは，車両を山の上の旗がある場所まで移動させることが目的です（旗の位置は0.5）． ユーザは，下記の状態を観測することが出来ます．
 車両の位置（-1.2 〜 0.6） 車両の速度（-0.07 〜 0.07）  また，ユーザは，車両に対し，下記のいずれかの行動をとることが出来ます．
 後方に加速（0） 加速なし（1） 前方に加速（2）  下記の条件を満たしたとき，ゲームは失敗となります．
 旗に到達できず200ステップが経過する  今回は，この山登りゲームをQ学習で解いてみましょう． 基本的には前回のバランスゲームの実装方法と同じです．
[学習前] 
[学習後] 
山登りゲームの実装  まずは必要なライブラリの導入と，山登りゲーム（MountainCar-v0）の初期化をします．
import gym import numpy as np env = gym.make(&amp;#39;MountainCar-v0&amp;#39;) # 環境の初期化 次に，200ステップに限定して，ランダムな行動選択を行なった結果を確認しましょう． 車両は谷底をウロウロするだけで，山を登ることはありません．
env.reset() # 環境のリセット for i in range(200): action = env.action_space.sample() # ランダムに行動選択 observation, reward, done, info = env.</description>
    </item>
    
    <item>
      <title>強化学習・Q学習</title>
      <link>https://mukai-lab.info/pages/classes/artificial_intelligence/chapter15/</link>
      <pubDate>Wed, 11 Mar 2020 18:33:09 +0900</pubDate>
      
      <guid>https://mukai-lab.info/pages/classes/artificial_intelligence/chapter15/</guid>
      <description>Q学習とは  Q学習 は状態$s_x$と行動$a_x$の組み合わせに対する 価値$Q(s_x,a_x)$ を学習するためのアルゴリズムです． 下記は，状態$s_x$で行動$a_x$を選択し，報酬$r$を獲得したときの更新式です． また，$Q(s_y, a_y)$は，状態$s_x$から遷移した先の状態$s_y$において，行動$a_y$を選択したときの価値を表しています． ここで，$\alpha$は学習率，$\gamma$は割引率と呼ばれるパラメータであり， $0 \leq \alpha \leq 1$，$0 \leq \gamma \leq 1$の範囲で設定します． 学習率は学習の収束に影響し，小さいとゆっくりと学習し，大きいと速く学習します（収束の安定性とトレードオフ）． また，割引率は将来得られるであろう報酬を割り引いて評価するために用います．
$$ Q&amp;rsquo;(s_x,a_x) = (1 - \alpha)Q(s_x,a_x) + \alpha(r + \gamma \max_{a_y \in A(s_y)} Q(s_y, a_y)) $$
   パラメータ 意味     $s$ 状態   $a$ 行動   $Q(s,a)$ 状態$s$で行動$a$を選択する価値   $r$ 報酬   $A(s)$ 状態$s$で選択可能な行動の集合   $\alpha$ 学習率   $\gamma$ 割引率    ノートブックの作成  Google Colaboratory を起動し，新規にノートブックを作成してください． ノートブックのタイトルは AI-15 とします． ノートブックの作成方法は第1回の資料を参照してください．</description>
    </item>
    
    <item>
      <title>強化学習・バランスゲーム</title>
      <link>https://mukai-lab.info/pages/classes/artificial_intelligence/chapter2_2020/</link>
      <pubDate>Wed, 11 Mar 2020 18:33:09 +0900</pubDate>
      
      <guid>https://mukai-lab.info/pages/classes/artificial_intelligence/chapter2_2020/</guid>
      <description>Q学習とは  Q学習 は状態$S$と行動$a$の組み合わせに対する 価値$Q(s,a)$ を学習するためのアルゴリズムです． 下記は，状態$s$で行動$a$を選択し，報酬$r$を獲得したときの更新式です． また，$Q(s&amp;rsquo;, a&amp;rsquo;)$は，状態$s$から遷移した先の状態$s&#39;$において，行動$a&#39;$を選択したときの価値を表しています． ここで，$\alpha$は学習率，$\gamma$は割引率と呼ばれるパラメータであり， $0 \leq \alpha \leq 1$，$0 \leq \gamma \leq 1$の範囲で設定します． 学習率は学習の収束に影響し，小さいとゆっくりと学習し，大きいと速く学習します（収束の安定性とトレードオフ）． また，割引率は将来得られるであろう報酬を割り引いて評価するために用います．
$$ Q&amp;rsquo;(s,a) = (1 - \alpha)Q(s,a) + \alpha(r + \gamma \max_{a&amp;rsquo; \in A(s&amp;rsquo;)} Q(s&amp;rsquo;, a&amp;rsquo;)) $$
   パラメータ 意味     $s$ 状態   $a$ 行動   $Q(s,a)$ 状態$s$で行動$a$を選択する価値   $r$ 報酬   $A(s)$ 状態$s$で選択可能な行動の集合   $\alpha$ 学習率   $\gamma$ 割引率    ノートブックの作成  Jupyter Notebook を起動し，新規にノートブックを作成してください． ノートブックのタイトルは AI-12 とします． ノートブックの作成方法は第1回の資料を参照してください．</description>
    </item>
    
    <item>
      <title>強化学習・OpenAI Gym</title>
      <link>https://mukai-lab.info/pages/classes/artificial_intelligence/chapter14/</link>
      <pubDate>Mon, 09 Mar 2020 19:31:38 +0900</pubDate>
      
      <guid>https://mukai-lab.info/pages/classes/artificial_intelligence/chapter14/</guid>
      <description>OpenAI Gymとは  OpenAI Gymは， 機械学習の一分野である 強化学習 を開発するためのツールキットです． ここでは，フローズンレイク（FrozenLake）などのゲームを題材に， 強化学習のアルゴリズムを実装することができます．
ノートブックの作成  Google Colaboratory を起動し，新規にノートブックを作成してください． ノートブックのタイトルは AI-14 とします． ノートブックの作成方法は第1回の資料を参照してください．
最初にOpenAI Gym をインストールします． セルで下記のコマンドを実行してください．
&amp;gt; !pip install gym また，OpenAI Gymに加え，下記のライブラリも導入しておきましょう．
import gym import numpy as np import random import time from google.colab import output フローズンレイク（FrozenLake）  フローズンレイク（FrozenLake）は， 凍った湖の上を，湖に落ちない様に，スタート地点からゴール地点まで進むゲームです．
湖の環境は下記のように16文字のテキストで表現されます． ここで，Sはスタート地点，Gはゴール地点，Fは凍った湖，Hは穴が空いた湖です． Sから，Hを避けて，Fだけを通り，Gに到達できればクリアです．
SFFF FHFH FFFH HFFG プレイヤーが観測できる情報は，プレイヤーの位置です． どこにHがあるかを知ることはできません． プレイヤーの位置は0〜15の数値で表され，Sは0，Gは15に対応します．
0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 また，プレイヤーは，下記のいずれかの行動をとることが出来ます．</description>
    </item>
    
    <item>
      <title>強化学習・OpenAI Gym</title>
      <link>https://mukai-lab.info/pages/classes/artificial_intelligence/chapter1_2020/</link>
      <pubDate>Mon, 09 Mar 2020 19:31:38 +0900</pubDate>
      
      <guid>https://mukai-lab.info/pages/classes/artificial_intelligence/chapter1_2020/</guid>
      <description>OpenAI Gymとは  OpenAI Gymは， 機械学習の一分野である 強化学習 を開発するためのツールキットです． バランスゲーム（CartPole）や，ドライブゲーム（MountainCar）などのゲームを題材に， 強化学習のアルゴリズムを実装し評価することができます．
最初に，OpenAI Gym をインストールします． インストールしたフォルダで，PowerShellを起動し， 下記のコマンドを実行してください（Shiftキーを押しながら右クリック）．
&amp;gt; .\Scripts\pip install gym &amp;gt; .\Scripts\pip install &amp;#34;gym[atari]&amp;#34; &amp;gt; .\Scripts\pip install &amp;#34;gym[all]&amp;#34; ノートブックの作成  Jupyter Notebook を起動し，新規にノートブックを作成してください． ノートブックのタイトルは AI-11 とします． ノートブックの作成方法は第1回の資料を参照してください．
バランスゲーム（CartPole）  バランスゲームは，カートの上に垂直に立てたポールを落とさないようにバランスをとることが目的です． ユーザは，下記の状態を観測することが出来ます．
 カートの位置（-2.4 〜 2.4） カートの速度 ポールの角度（-12度 〜 12度） ポールの速度  また，ユーザは，カートに対し，下記のいずれかの行動をとることが出来ます．
 左に向かって力を加える（0） 右に向かって力を加える（1）  下記の条件を満たしたとき，ゲームは失敗となります．
 ポールが12度以上傾く カートの位置が画面の端に到達する（中央から2.4以上離れる）  ポールを落とさずバランスを維持して200ステップが経過すれば成功となります．
[学習前] 
[学習後] 
実装  今回は強化学習は利用せず，観測した状態に応じて行動を選択するアプローチで挑戦してみましょう．
まずはライブラリを導入します． ここでは，Gym に加えて，数値計算のための Numpy も導入します．</description>
    </item>
    
    <item>
      <title>強化学習・TD学習</title>
      <link>https://mukai-lab.info/pages/classes/artificial_intelligence/chapter13/</link>
      <pubDate>Mon, 09 Mar 2020 19:31:38 +0900</pubDate>
      
      <guid>https://mukai-lab.info/pages/classes/artificial_intelligence/chapter13/</guid>
      <description>TD学習  TD学習（Temporal Difference Learning） は，強化学習の手法の一つであり， 前回紹介した「状態$s_x$における価値$V(s_x)$」の更新式を一般化したものです．
前回の更新式を振り返りましょう． 次の式は，状態$s_x$で報酬$r$を得られたときの更新式です． この式は状態の遷移を考慮していません． このため，ランダムに状態$s_x$が選択されるときに適用します．
$$ V&amp;rsquo;(s_x) = (1 - \alpha) \cdot V(s_x) + \alpha \cdot r $$
次の式は，状態$s_x$から状態$s_y$に遷移したときの更新式です． 将来の状態$s_y$の価値を基に，現在の状態$s_x$の価値を算出しています（ブートストラップ型学習）． このため，$s_x \rightarrow s_y$のように状態遷移が生じるときに適用します
$$ V&amp;rsquo;(s_x) = (1 - \alpha) \cdot V(s_x) + \alpha \cdot V(s_y) $$
一方，TD学習 は次の式で定義されます． 現在の状態$s_x$で得た報酬$r$と，将来の状態$s_y$の価値を組み合わせて， 現在の状態$s_x$の価値を算出しています． ここで，$\gamma$ は割引率と呼ばれ，将来に得られる価値を割り引いて加算するために用いられます（将来得られる価値は確実ではないため）． この式は，$s_x \rightarrow s_y \rightarrow, \cdots, \rightarrow s_z$のように状態遷移が繰り返されるときに適用します．
$$ V&amp;rsquo;(s_x) = (1 - \alpha) \cdot V(s_x) + \alpha (r + \gamma \cdot V(s_y)) $$</description>
    </item>
    
    <item>
      <title>強化学習・モンテカルロ法</title>
      <link>https://mukai-lab.info/pages/classes/artificial_intelligence/chapter12/</link>
      <pubDate>Mon, 09 Mar 2020 19:31:38 +0900</pubDate>
      
      <guid>https://mukai-lab.info/pages/classes/artificial_intelligence/chapter12/</guid>
      <description>強化学習  強化学習(Reinforcement Learning) とは，自律的に行動するプログラム（ エージェント ）がある環境において， 観測した現在の状態を基に，最適な行動を選択可能にするための学習方法です． DeepMind社が開発した囲碁プログラムの AlphaGo や， Atari社のビデオゲームをプレイする DQN(Deep Q-Network) などが強化学習の成果としてよく知られています． また，強化学習には，次に挙げるような手法が存在します．
 モンテカルロ法（Monte Carlo Methods） TD学習(Temporal Difference Learning) Q学習(Q-Learning)  ここでは，シンプルなトランプゲームを題材に強化学習の基本を学び， 最後に強化学習のツールキットであるOpenAI Gymを利用してQ学習を実装してみます．
  -- ノートブックの作成  Google Colaboratory を起動し，新規にノートブックを作成してください． ノートブックのタイトルは AI-12 とします． ノートブックの作成方法は第1回の資料を参照してください．
完成したノートブックの確認  ノートブックの確認
トランプゲーム  次に示す2つのルールを考えます． いずれのルールもゲームに勝てば100円を獲得し，負ければ100円が没収されます． ルール1には引き分けがないことに注意してください．
ルール1   同じ絵柄のトランプから2枚のカードを順に引き，カードの数字を比較する． 1枚目のカードの数字が，2枚目のカードの数字より大きいとき，報酬として100円が与えられる． 逆に小さいときは，ペナルティとして100円が没収される(同じ数字になることはない)．   ルール2   2人のプレイヤーが同じ絵柄のトランプから2枚のカードを順に引き，2枚のカードの数字を合計する． 2枚のカードの合計が，相手より大きいとき，報酬として100円が与えられ，逆に小さいときはペナルティとして100円が没収される（合計が同じ場合は引き分け）． ただし，1枚目のカードを引いた時点で，ゲームから降りることを決めることができる．   実装  乱数を生成するrandom，数値計算のためのnumpyに加え， プログレスバーを表示するtqdm.notebookをインポートします．
import random import numpy as np from tqdm.</description>
    </item>
    
    <item>
      <title>遺伝的アルゴリズム・巡回セールスマン問題</title>
      <link>https://mukai-lab.info/pages/classes/artificial_intelligence/chapter11/</link>
      <pubDate>Mon, 09 Mar 2020 19:31:38 +0900</pubDate>
      
      <guid>https://mukai-lab.info/pages/classes/artificial_intelligence/chapter11/</guid>
      <description>ノートブックの作成  Google Colaboratory を起動し，新規にノートブックを作成してください． ノートブックのタイトルは AI-11 とします． ノートブックの作成方法は第1回の資料を参照してください．
最初に Simple AI と NetworkX をインストールします． NetworkXはネットワーク分析のためのライブラリです． セルで下記のコマンドを実行してください．
!pip install simpleai !pip install network 巡回セールスマン問題  今回は 巡回セールスマン問題(Traveling Salesman Problem) を取り上げましょう．
巡回セールスマン問題   $A,B,C,D,E,F,G,H,I,J$で表される10の都市がある． 各都市の座標は次の表で与えられる．  都市ABCDEFGHIJ X17973263578310012355 Y7281597604826624977  セールスマンは，全ての都市を1回だけ訪れて，出発した都市に戻る． この条件を満たす巡回路において，経路コスト（ユークリッド距離）が最小のものを求めよ． 例えば，次の経路は条件を満たす巡回路である． この経路コストは約$558$である． $$ A \rightarrow B \rightarrow C \rightarrow D \rightarrow E \rightarrow F \rightarrow G \rightarrow H \rightarrow I \rightarrow J \rightarrow A $$ 10都市を巡る巡回路の組み合わせは$1814400$通り存在する（逆の順番で巡る経路が存在するため2で割る）． $$ \frac{10!</description>
    </item>
    
    <item>
      <title>探索木・「ハノイの塔」</title>
      <link>https://mukai-lab.info/pages/classes/artificial_intelligence/chapter5/</link>
      <pubDate>Sat, 29 Feb 2020 20:11:10 +0900</pubDate>
      
      <guid>https://mukai-lab.info/pages/classes/artificial_intelligence/chapter5/</guid>
      <description>ノートブックの作成  ノートブックのタイトルは AI-5 とします． Google Colaboratory を起動し，新規にノートブックを作成してください． ノートブックの作成方法は第1回の資料を参照してください．
最初に Simple AI をインストールします． セルで下記のコマンドを実行してください．
!pip install simpleai ハノイの塔  今回は ハノイの塔（Tower of Hanoi） を取り上げましょう．
ハノイの塔   3本の支柱（A，B，C）があり，支柱Aに3枚の円盤（小，中，大）が重なっている．円盤を他の支柱に移動させることができるが，必ず大きい円盤の上に小さい円盤が積まれる状態でなければいけない．支柱Aにある全ての円盤を支柱Cに移すにはどうすれば良いか． See the Pen Tower of Hanoi by Naoto Mukai (@nmukai)on CodePen.この問題を 状態空間モデル で表現します． ここでは，モデルAとモデルBの2種類の状態空間モデル検討してみましょう．
モデルAの状態定義   支柱に積まれている円盤の数が1枚のとき1，2枚のとき2，3枚のとき3と表す．この状態を，$(支柱A，支柱B，支柱C)$の順に並べる．例えば，初期状態は全ての円盤が支柱Aにあるため$(3, 0, 0)$と表す．同様に，目的状態は全ての円盤が支柱Cにあるため$(0, 0, 3)$と表す．$$初期状態：(3, 0, 0)$$$$目的状態：(0, 0, 3)$$ モデルBの状態定義   円盤が支柱Aにあるとき1 ，支柱Bにあるとき2，支柱Cにあるとき3と表す．この状態を，$(円盤（小）, 円盤（中）, 円盤（大）)$の順に並べる．例えば，初期状態は全ての円盤が支柱Aにあるため$(1, 1, 1)$と表す．同様に，目的状態は全ての円盤が支柱Cにあるため$(3, 3, 3)$と表す．$$初期状態：(1, 1, 1)$$$$目的状態：(3, 3, 3)$$ 上記のモデルA，モデルBのどちらが適しているでしょうか． 次の2つの状態を例に考えてみましょう． 左の状態は，円盤（小）と円盤（大）が支柱A，円盤（中）が支柱Bにあります． 右の状態は，円盤（中）と円盤（大）が支柱A，円盤（小）が支柱Bにあります． これらを，モデルAとモデルBで表現してみましょう．</description>
    </item>
    
    <item>
      <title>ビデオ会議</title>
      <link>https://mukai-lab.info/posts/2020-02-26-comic_140/</link>
      <pubDate>Wed, 26 Feb 2020 20:53:46 +0900</pubDate>
      
      <guid>https://mukai-lab.info/posts/2020-02-26-comic_140/</guid>
      <description></description>
    </item>
    
    <item>
      <title>感染予防</title>
      <link>https://mukai-lab.info/posts/2020-02-26-comic_139/</link>
      <pubDate>Wed, 26 Feb 2020 19:59:32 +0900</pubDate>
      
      <guid>https://mukai-lab.info/posts/2020-02-26-comic_139/</guid>
      <description></description>
    </item>
    
    <item>
      <title>要マスク</title>
      <link>https://mukai-lab.info/posts/2020-02-21-comic_138/</link>
      <pubDate>Fri, 21 Feb 2020 20:01:23 +0900</pubDate>
      
      <guid>https://mukai-lab.info/posts/2020-02-21-comic_138/</guid>
      <description></description>
    </item>
    
    <item>
      <title>人数合わせ</title>
      <link>https://mukai-lab.info/posts/2020-02-21-comic_137/</link>
      <pubDate>Fri, 21 Feb 2020 18:14:59 +0900</pubDate>
      
      <guid>https://mukai-lab.info/posts/2020-02-21-comic_137/</guid>
      <description></description>
    </item>
    
    <item>
      <title>大学構内禁煙</title>
      <link>https://mukai-lab.info/posts/2020-02-21-comic_136/</link>
      <pubDate>Fri, 21 Feb 2020 17:05:37 +0900</pubDate>
      
      <guid>https://mukai-lab.info/posts/2020-02-21-comic_136/</guid>
      <description></description>
    </item>
    
    <item>
      <title>データベースを利用したウェブサイトの構築</title>
      <link>https://mukai-lab.info/pages/classes/database/chapter14/</link>
      <pubDate>Tue, 21 Jan 2020 19:35:51 +0900</pubDate>
      
      <guid>https://mukai-lab.info/pages/classes/database/chapter14/</guid>
      <description>SQLiteを利用したウェブサイト  SQLiteなどデータベース管理システムの多くは， C，C++，Perl，Ruby，Pythonなど様々なプログラミング言語で利用するためのライブラリ（またはAPI） が公開されています． ライブラリを導入することで，プログラムを介したレコードの追加・削除などの操作が可能となります． 今回は，Pythonのウェブサーバ機能を用いて，ウェブサイトでSQLiteのデータベースを操作するCGI(Common Gateway Interface)を実装することを目的とします．
Pythonのインストール Windowsの場合 Windows版は，公式サイトからダウンロードしましょう． ここでは，ダウンロードするパッケージとして，embeddable zip file を選択するようにしてください．
Windows版 Pythonのダウンロード
MacOSの場合 MacOSでは，バージョン管理が容易な pyenv をインストールすると良いでしょう． pyenv のインストールはHomeBrewを利用します．
% brew install pyenv pyenv をインストールしたら，利用可能なPythonのバージョンを調べます． ここでは，最新の3.8.0をインストールします（2020年1月21日時点）．
% pyenv install --list % pyenv install 3.8.0 ソースファイルのダウンロード SQLiteを利用するためのPythonのソースファイルはGitHubで公開しています． 下記のプロジェクトページで， Download ZIP をクリックし，ダウンロードしたファイルを展開してください．
 naoto-github/WebSQLite
データベースの確認 展開したフォルダにある db/students.db が今回利用するデータベース・ファイルです． sqlite3コマンドを用いて，データベースの内容を確認しておきましょう． データベースには，テーブル students が存在し，4件のレコードが登録されています． 各レコードは，id，name，grade という3つの属性で構成され，id が主キーです．
% sqlite3 students.db sqlite&amp;gt; .table students qlite&amp;gt; .header on sqlite&amp;gt; select * from students; id|name|grade A001|Iwashiro Hayato|2 A002|Iwamura Yuu|1 B003|Sugie Hiroko|3 C004|Senba Asuka|1  id name grade  A001 Iwashiro Hayato 2  A002 Iwamura Yuu 1  B003 Sugie Hiroko 3  C004 Senba Asuka 1   【students】</description>
    </item>
    
    <item>
      <title>探索木・8パズル</title>
      <link>https://mukai-lab.info/pages/classes/artificial_intelligence/chapter4/</link>
      <pubDate>Sun, 05 Jan 2020 12:19:26 +0900</pubDate>
      
      <guid>https://mukai-lab.info/pages/classes/artificial_intelligence/chapter4/</guid>
      <description>ノートブックの作成  Google Colaboratory を起動し，新規にノートブックを作成してください． ノートブックのタイトルは AI-4 とします． ノートブックの作成方法は第1回の資料を参照してください．
最初に Simple AI をインストールします． セルで下記のコマンドを実行してください．
!pip install simpleai 8パズル  今回は 8パズル（8 Puzzle） を取り上げましょう．
8パズル   1から8の数字が書いてあるタイルが不規則に3 $\times$ 3のマス目に並べてある．タイルをスライドさせ，左上から順番に1から8まで並び替えるにはどうしたらよいか． See the Pen Tower of Hanoi by Naoto Mukai (@nmukai)on CodePen.この問題を 状態空間モデル で表現します．
状態空間モデル   タイルの数字を$x_i$で表す（$i$はタイルの位置）．例えば初期状態と目的状態を下記で与える．タイルがないマスは$b（ブランク）$と表していることに注意すること．$$初期状態: (x_1, x_2, x_3, x_4, x_5, x_6, x_7, x_8, x_9) = (3, 1, 5, b, 7, 4, 6, 8, 2)$$$$目的状態: (x_1, x_2, x_3, x_4, x_5, x_6, x_7, x_8, x_9) = (b, 1, 2, 3, 4, 5, 6, 7, 8)$$タイルに対する行動（操作）はブランクの位置に応じて決まる．例えば，ブランクが 左上（$x_1$） にあるときは，上（$x_2$）と左（$x_4$）のタイルと入れ替えることができる．A1: $(b, x_2, x_3, x_4, x_5, x_6, x_7, x_8, x_9) \rightarrow (x_2, b, x_3, x_4, x_5, x_6, x_7, x_8, x_9)$A2: $(b, x_2, x_3, x_4, x_5, x_6, x_7, x_8, x_9) \rightarrow (x_4, x_2, x_3, b, x_5, x_6, x_7, x_8, x_9)$同様に，ブランクが 上（$x_2$） にあるときは，左上（$x_1$），右上（$x_3$），中央（$x_5$）と入れ替えることができます．A3: $(x_1, b, x_3, x_4, x_5, x_6, x_7, x_8, x_9) \rightarrow (b, x_1, x_3, x_4, x_5, x_6, x_7, x_8, x_9)$A4: $(x_1, b, x_3, x_4, x_5, x_6, x_7, x_8, x_9) \rightarrow (x_1, x_3, b, x_4, x_5, x_6, x_7, x_8, x_9)$A5: $(x_1, b, x_3, x_4, x_5, x_6, x_7, x_8, x_9) \rightarrow (x_1, x_5, x_3, x_4, b, x_6, x_7, x_8, x_9)$上記に沿って全てを列挙すると24の行動が定義できる． 実装  クラスの定義 最初にライブラリをインポートします． 前回と同様に，探索問題の型 を表すSearchPrblemと 幅優先探索 を表すbreadth_firstをインポートします．</description>
    </item>
    
    <item>
      <title>探索木・Simple AI</title>
      <link>https://mukai-lab.info/pages/classes/artificial_intelligence/chapter3/</link>
      <pubDate>Sat, 04 Jan 2020 13:29:27 +0900</pubDate>
      
      <guid>https://mukai-lab.info/pages/classes/artificial_intelligence/chapter3/</guid>
      <description>Simple AIとは  Simple AIは，Stuart Russel氏とPeter Norvig氏が執筆した 「Artificial Intelligence: A Modern Approach」に掲載されている 人工知能で用いられる伝統的なアルゴリズムを提供するPythonのライブラリです． このライブラリを導入することで， 幅優先探索などの 探索アルゴリズム，遺伝的アルゴリズムなどの 進化的アルゴリズム， 決定木などの 機械学習アルゴリズム を簡単に実装することが可能です． ここでは，授業で紹介したアルゴリズムを Simple AI で実装することで， 知識を定着させ，様々な問題に応用できるようになることを目指します．
.\Scripts\pip install simpleai .\Scripts\pip install pydot .\Scripts\pip install flask```--ノートブックの作成  Google Colaboratory を起動し，新規にノートブックを作成してください． ノートブックのタイトルは AI-3 とします． ノートブックの作成方法は第1回の資料を参照してください．
最初に Simple AI をインストールします． セルで下記のコマンドを実行してください．
!pip install simpleai 水差し問題  今回は 水差し問題（Jug Problem） を取り上げましょう．
水差し問題   3リットルと4リットルのコップ（水差し）がある．4リットルのコップに正確に2リットルの水を入れるにはどうしたらよいか． この問題を 状態空間モデル で表現します． 状態空間モデルとは，探索過程の途中経過を 状態， またその状態間の遷移を 行動(操作) として表現したモデルです． 一般に，行動の結果，1通りに状態が定まるとき， 確定システム , 確率的に状態が変化するとき， 確率システム と呼ばれます． 現実世界の事象の多くは 確率システム となりますが， ここではシンプルな 確定システム のみを対象とします．</description>
    </item>
    
    <item>
      <title>人工知能</title>
      <link>https://mukai-lab.info/pages/classes/artificial_intelligence/</link>
      <pubDate>Sat, 04 Jan 2020 13:29:08 +0900</pubDate>
      
      <guid>https://mukai-lab.info/pages/classes/artificial_intelligence/</guid>
      <description>授業科目区分： 専門教育科目
単位数: 2単位
開講学科: 文化情報学科
学年: 2年次
関連科目: 知能情報システム
授業テーマ: 人工知能の基本的な理論とアルゴリズムの習得
授業内容 日常生活に自然に取り込まれている人工知能技術の理論と手法を学習する． 本授業では，コンピュータで問題解決に必要なモデルを定義し， 幅優先探索など探索アルゴリズムに関して，パズルを題材に学習する． また，自動運転車にも用いられる強化学習を取り上げ，ゲームを題材に学習する． また，実装はプログラミング言語のPythonを利用する．
授業計画  人工知能とは Pythonの基本 探索木・Simple AI 探索木・8パズル 探索木・ハノイの塔 探索アルゴリズム・幅優先探索と深さ優先探索 探索アルゴリズム・ヒューリスティック探索 局所探索アルゴリズム・山登り法 局所探索アルゴリズム・シミュレーテッドアニーリング 遺伝的アルゴリズム・フロイド問題 遺伝的アルゴリズム・巡回セールスマン問題 強化学習・モンテカルロ法 強化学習・TD学習 強化学習・OpenAI Gym 強化学習・Q学習  追加資料  強化学習・タクシーゲーム 探索木・ゲーム木  旧資料（2020年度まで）  強化学習・OpenAI Gym 強化学習・バランスゲーム 強化学習・山登りゲーム  参考書籍     </description>
    </item>
    
    <item>
      <title>ARToolkitを利用した拡張現実（動画ファイル版）</title>
      <link>https://mukai-lab.info/pages/classes/programming_1/chapter12_2/</link>
      <pubDate>Sun, 29 Dec 2019 13:35:28 +0900</pubDate>
      
      <guid>https://mukai-lab.info/pages/classes/programming_1/chapter12_2/</guid>
      <description>スケッチの作成  Processingを起動して，新規にスケッチを保存しましょう． メニューから[ファイル]-[名前を付けて保存]をクリックして，「スケッチフォルダを名前を付けて保存」を開きます． ファイル名に「Project12」を入力し，[保存]をクリックしましょう． 保存先に「Project12」という名前のフォルダが作成されていることを確認してください．

NyARToolkitの導入  ARToolkit は奈良先端科学技術大学院大学の加藤研究室によって 開発された拡張現実（Augumented Reality: AR）のためのソフトウェアです． 拡張現実とは，コンピュータを利用して，現実世界の一部に「仮想的な物体や情報」を重ねて表示することを指します． この ARToolkit のProcessing向けのライブラリが「NyARToolkit for Processing」です．
メニューから[スケッチ]-[ライブラリをインポート]-[ライブラリを追加]をクリックして， 「Contribution Manager」を開きます． ここで，nyar4psgをキーワードに検索すると， 「nyar4psg | NyARToolkit for Processing」が表示されるので， このライブラリを選択してインストールしましょう．

次に，カメラのキャリブレーション（校正）に関するファイルcamera_para.datをダウンロードし，スケッチフォルダにコピーします．
\Project12\camera_para.dat
最後に，[スケッチ]-[ライブラリをインポート]-[nyar4psg]をクリックして，NyARToolkitライブラリをインポートします． また，同様にVideoライブラリをインポートしてください． ソースコードの先頭に「import jp.nyatla.nyar4psg.*;」，「import jp.nyatla.nyar4psg.utils.*;」，「import processing.video.*;」が 表示されていることを確認してください．
動画ファイルの表示  今回はARマーカーを映した動画ファイルを利用します． 下記から動画をダウンロードしましょう．
「id001.mp4」のダウンロード
ダウンロードした動画ファイル（id001.mp4）を，スケッチフォルダにコピーします． このとき，スケッチフォルダに新しく data という名前でフォルダを作成し，そのなかに動画ファイルを配置する必要があるので注意してください．
\Project12\data\id001.mp4
Processingでの動画ファイルの再生は前回と同じ Movie クラスを利用します． 下記を参考にコードを入力したら，Runボタンをクリックしてください． 動画ファイルが再生されることを確認してください．
 
拡張現実の表示  ARToolkitを利用すると，ARマーカー と呼ばれる特定のパターンをカメラで読み取ることにより，その位置を認識し，３Dオブジェクトを配置することができます． ここでは，NYARToolkitに標準搭載されている NyID を利用します． NyIDには番号が設定されており， ここではMODEL2の1番のNyIDを利用します．
まずは，下記のように，MultiMarker クラスを利用して，利用するマーカーを設定します． MultiMarker クラスのインスタンスを作成するときは，カメラ映像の幅と高さに加え，カメラのキャリブレーション（ camera_para.</description>
    </item>
    
    <item>
      <title>オーバーフィッティングと交差検証</title>
      <link>https://mukai-lab.info/pages/classes/intelligence_information_system/chapter_extra1/</link>
      <pubDate>Tue, 17 Dec 2019 18:24:35 +0900</pubDate>
      
      <guid>https://mukai-lab.info/pages/classes/intelligence_information_system/chapter_extra1/</guid>
      <description>ノートブックの作成  Colabにアクセスし，新規にノートブックを作成してください． また，numpy，matplotlib.pyplot，random，scikit-learn を導入しておいてください．
import numpy as np import matplotlib.pyplot as plt import random from sklearn.model_selection import KFold オーバーフィッティング（過学習）  オーバーフィッティング とは 過学習 または 過剰適合 と呼ばれることもある現象で， サンプルデータに過剰に適合してしまい， データ全体に対しての汎用的な能力を失った状態を指します． ここでは，回帰問題を例に挙げて，オーバーフィッティングを再現してみましょう．
まずは，$x^3 - 2x$に従った40点のデータを生成します． これに，ノイズとなる乱数を加え，対象のデータ全体とします．
x = np.arange(-2, 2, 0.1) # 40点を生成 y = x ** 3 - 2* x r = np.random.rand(len(y)) * 2 # 乱数を生成 y = y + r # 乱数を加算 data = np.stack([x, y]) plt.scatter(data[0], data[1]) plt.</description>
    </item>
    
    <item>
      <title>混合ガウスモデル</title>
      <link>https://mukai-lab.info/pages/classes/intelligence_information_system/chapter13/</link>
      <pubDate>Mon, 16 Dec 2019 19:05:44 +0900</pubDate>
      
      <guid>https://mukai-lab.info/pages/classes/intelligence_information_system/chapter13/</guid>
      <description>ノートブックの作成  Colabにアクセスし，新規にノートブックを作成してください． ノートブックのタイトルは chapter13 とします． また，numpy，matplotlib.pyplot，scikit-learn，SciPyを導入しておいてください．
import numpy as np import matplotlib.pyplot as plt from sklearn.mixture import GaussianMixture from scipy.stats import norm ガウス分布（正規分布）  ガウス分布（正規分布）は，ドイツの数学者のガウスに由来する確率・統計において最重要な確率分布の一つです． 自然界や社会の様々な現象を表現するモデルとして知られています． Pythonでは，Numpyを利用して，正規分布に従う乱数を生成することが可能です．
例えば，平均0，標準偏差1の正規分布に従う乱数を生成してみます． 生成した乱数のヒストグラム（度数）は下図のようになります． このヒストグラムからも分かるように，正規分布には下記の特徴があります．
 平均値がピークとなる 平均値を中心として左右対称 標準偏差が小さいと尖った形状，大きいと平らな形状  x = np.random.normal(0, 1, 10000) # 10000の乱数を生成 plt.hist(x, bins=100) # 階級数を100に設定したヒストグラム plt.xlim(-5, 5) plt.xlabel(&amp;#34;x&amp;#34;) plt.ylabel(&amp;#34;Frequency&amp;#34;) 
正規分布に従う特徴量の一つに人間の身長があります． 例えば，日本人男性の平均は167.7cm，標準偏差は6.6cm， また，アメリカ人男性の平均は178.4cmで，標準偏差は7.6cmとされています． それでは，この特徴量を利用して日本人男性とアメリカ人男性の正規分布に従う乱数を生成しましょう． そして，これを重ね合わせてしまいます．
x1 = np.random.normal(167.7, 6.6, 10000) x2 = np.random.normal(178.4, 7.6, 10000) x = np.</description>
    </item>
    
    <item>
      <title>OpenCVを利用した顔検出（動画ファイル版）</title>
      <link>https://mukai-lab.info/pages/classes/programming_1/chapter11_2/</link>
      <pubDate>Sat, 23 Nov 2019 23:28:04 +0900</pubDate>
      
      <guid>https://mukai-lab.info/pages/classes/programming_1/chapter11_2/</guid>
      <description>スケッチの作成  Processingを起動して，新規にスケッチを保存しましょう． メニューから[ファイル]-[名前を付けて保存]をクリックして，「スケッチフォルダを名前を付けて保存」を開きます． ファイル名に「Project11」を入力し，[保存]をクリックしましょう． 保存先に「Project11」という名前のフォルダが作成されていることを確認してください．

OpenCVの導入  インテルが開発したオープンソースのライブラリであるOpenCVを導入することで， 画像処理・画像解析など様々な機能を利用することが可能となります． ここでは，Processing用のOpenCVを導入して，顔検出を試みてみましょう． まずは，メニューから[スケッチ]-[ライブラリをインポート]-[ライブラリを追加]をクリックして， 「Contribution Manager」を開きます． ここで，opencvをキーワードに検索すると， 「OpenCV for Processing | Computer vision with OpenCV.」が表示されるので， このライブラリを選択してインストールしましょう．

次に，[スケッチ]-[ライブラリをインポート]-[OpenCV for Processing]をクリックして，OpenCVライブラリをインポートします． また，同様にVideoライブラリをインポートしてください． ソースコードの先頭に「import gab.opencv.∗;」と「import processing.video.∗;」が 表示されていることを確認してください．
動画ファイルの表示  今回はPixabayの動画ファイルを利用します． このサイトで配布されている素材は，商用・非商用において，コピー・改変・再配布が認められています． 下記の男性が平手打ちされている動画をダウンロードしましょう．
「Slap in The Face」のダウンロード
ダウンロードした動画ファイル（face.mp4）を，スケッチフォルダにコピーします． このとき，スケッチフォルダに新しく data という名前でフォルダを作成し，そのなかに動画ファイルを配置する必要があるので注意してください．
\Project11\data\face.mp4
Processingでの動画ファイルの再生は前回と同じ Movie クラスを利用します． 下記を参考にコードを入力したら，Runボタンをクリックしてください． 動画ファイルが再生されることを確認してください．
 
顔位置の検出  顔位置の検出にはOpenCVクラスを利用して下記のように記述します． 例えば，OpenCV.CASCADE_FRONTALFACEは顔を検出することを意味します． この他にOpenCV.CASCADE_PEDESTRIANSは歩行者，OpenCV.CASCADE_EYEは目を検出することが可能です （詳細はOpenCVのドキュメントを参照してください）． 検出された顔位置はRectangleクラスとして返されます． Rectangleクラスは矩形を表しており，フィールドとしてx, y, width, heightを持ちます． x，yで左上の座標，width，heigthで幅と高さを表します．
opencv = new OpenCV(this, movie); opencv.</description>
    </item>
    
    <item>
      <title>カメラ映像の表示(動画ファイル版)</title>
      <link>https://mukai-lab.info/pages/classes/programming_1/chapter10_2/</link>
      <pubDate>Thu, 21 Nov 2019 20:10:05 +0900</pubDate>
      
      <guid>https://mukai-lab.info/pages/classes/programming_1/chapter10_2/</guid>
      <description>スケッチの作成  Processingを起動して，新規にスケッチを保存しましょう． メニューから[ファイル]-[名前を付けて保存]をクリックして，「スケッチフォルダを名前を付けて保存」を開きます． ファイル名に「Project10」を入力し，[保存]をクリックしましょう． 保存先に「Project10」という名前のフォルダが作成されていることを確認してください．

Videoライブラリの導入  Processingでは Videoライブラリ を導入することで，動画ファイルをウィンドウに表示することができるようになります． まずは，メニューから[スケッチ]-[ライブラリをインポート]-[ライブラリを追加]をクリックして，「Contribution Manager」を開きます． ここで，video をキーワードに検索すると，Video|GStreamer-based video library for Processing が表示されるので，このライブラリを選択してインストールしましょう．

次に，[スケッチ]-[ライブラリをインポート]-[Video]をクリックして， Videoライブラリをインポート（プログラムで利用可能な状態にすること）します． ソースコードの１行目に「 import processing.video.*; 」と表示されていることを確認してください．
 動画ファイルの表示  動画ファイルをProcessingに取り込み，再生する方法を確認しましょう． 動画ファイルはNHKクリエイティブ・ライブラリからダウンロードした素材を利用します． 公開されている素材は，表現・創作活動を目的として無料で利用することができます． 今回は「どーもくん　走り抜ける　白バック素材」を利用してみましょう．
「どーもくん　走り抜ける　白バック素材」のダウンロード
ダウンロードした動画ファイル（domo.mp4）を，スケッチフォルダにコピーします． このとき，スケッチフォルダに新しく data という名前でフォルダを作成し，そのなかに動画ファイルを配置する必要があるので注意してください．
\Project10\data\domo.mp4
動画ファイルを取り込んで再生するには，Movie クラスを利用します． Movieクラスのインスタンスmovieを下記のように初期化します．
movie = new Movie(this, &amp;#34;domo.mp4&amp;#34;); このままだと，動画は1回再生され，そのまま終了してしまいます． そこで，動画をループして再生するために，loop()メソッドを呼び出します．
movie.loop(); movieEvent()は動画のフレームごとに自動的に呼び出されます． read()メソッドを利用して，次のフレームを読み込んでいます．
movie.read(); 読み込まれたフレームをimageメソッドで描画します． 動画ファイルの元のサイズは 1280x720 ですが， ここでは 640x360 に縮小して表示しています．
image(movie, 0, 0, 640, 360);</description>
    </item>
    
    <item>
      <title>NoSQL(2)・ドキュメント指向データベース</title>
      <link>https://mukai-lab.info/pages/classes/database/chapter13/</link>
      <pubDate>Thu, 21 Nov 2019 09:41:27 +0900</pubDate>
      
      <guid>https://mukai-lab.info/pages/classes/database/chapter13/</guid>
      <description>ドキュメント指向データベース  ドキュメント指向データベース(Document-Oriented Database) は， ドキュメント形式のデータをそのまま格納することができるデータベースです． ここで，ドキュメント形式とは，JSON形式 や XML形式 のことを指しています． Key-Valueストア型データベースに比べて， 階層構造など柔軟なデータ構造に対応が可能です． また，Javaに代表されるオブジェクト指向のプログラミング言語では， データをオブジェクトという単位で管理することが多く， このオブジェクトをJSONに変換して， データベースに格納することができるというメリットがあります．
JSON JSON(JavaScript Object Notation) はJavaScriptのオブジェクト表現を基にしたデータ形式です． 基本的にはキー（Key）とバリュー(Value)の組み合わせでデータを列挙します． 下記の例では，キーは name，バリューは 岩村優 です． キーとバリューのいずれも，ダブルクオーテーションで括る必要があることに注意してください． また，バリューには，文字列，数値，オブジェクト，配列などを指定することができます．
{ &amp;#34;name&amp;#34;: &amp;#34;岩村優&amp;#34;, &amp;#34;age&amp;#34;: 21, &amp;#34;faculty&amp;#34;: &amp;#34;工学部&amp;#34;, &amp;#34;hobby&amp;#34;: [&amp;#34;テニス&amp;#34;,&amp;#34;読書&amp;#34;] } XML XML(Extensibile Markup Language は， ウェブページを記述するHTMLと同様の マークアップ言語 の一つです． 要素(Element)と属性(Attribute)によって構成され， 階層的に記述することが可能なデータ形式です． 下記の例では，student や name が要素であり， age は属性を表しています． 要素は，開始タグ（&amp;lt;要素名&amp;gt;）で始まり，終了タグ（&amp;lt;/要素名&amp;gt;）で終わる必要があります．
&amp;lt;student&amp;gt; &amp;lt;name age=&amp;#34;21&amp;#34;&amp;gt;岩村優&amp;lt;/name&amp;gt; &amp;lt;faculty&amp;gt;工学部&amp;lt;/faculty&amp;gt; &amp;lt;hobbies&amp;gt; &amp;lt;hobby&amp;gt;テニス&amp;lt;/hobby&amp;gt; &amp;lt;hobby&amp;gt;読書&amp;lt;/hobby&amp;gt;	&amp;lt;/hobbies&amp;gt; &amp;lt;/student&amp;gt; 代表的なドキュメント指向データベースには下記があります． ここでは，JSON形式のドキュメントを格納可能な MongoDB に着目します．
 MongoDB CouchDB BaseX  MongoDB  MongoDBのインストール Windowsの場合 Windows版は，公式サイトからダウンロードしましょう． ここで，ダウンロードするパッケージは，Community Serverです （企業用の Enterprise Server を選択しないように注意）． また，パッケージは ZIP を選択してください．</description>
    </item>
    
    <item>
      <title>NoSQL(1) Key-Valueストア型データベース</title>
      <link>https://mukai-lab.info/pages/classes/database/chapter12/</link>
      <pubDate>Fri, 25 Oct 2019 10:32:52 +0900</pubDate>
      
      <guid>https://mukai-lab.info/pages/classes/database/chapter12/</guid>
      <description>NoSQL  NoSQLとは，リレーショナルデータベース以外のデータベースの総称です． このNoSQLという用語は，2009年にEric Evans氏によって提唱されました． 当初は「特に考えることもなく名前を思いついた」と述べています． しかし， No という表現がネガティブな印象を与えることから， 現在は Not Only SQL の略と考えることが望ましいと考えられています．
NoSQLの主な用途は，リレーショナルデータベースが苦手とする ビッグデータ の処理です． ガートナーによると，ビッグデータは 「高ボリューム、高速度、高バラエティな情報資産」と定義され， 数十テラバイトから数ペタバイトまでの巨大なデータを指しています （Googleの一日に処理するデータ量は20ペタバイト以上 - GIGAZINE）． リレーショナルデータベースは， 事前にスキーマの定義が必要であることに加え， 分散処理が苦手なため， 構造化されていない大量なデータを高速に処理するのに適していません． NoSQLは，冗長な機能をそぎ落とし，対象のデータに最適化されたシンプルな構造にすることで， リレーショナルデータベースより，ビッグデータの処理において高いパフォーマンスを発揮することができます．
現在は，様々なオープンソースのNoSQLが提供されており， 主要なサービスやアプリケーションを支える技術として普及しています． NoSQLは，そのデータモデルに基づき，4種類に分類されます （KVS系NoSQLのまとめ - ＠IT）． この授業では，Key-Valueストア型データベースと， ドキュメント指向データベースを取り上げます．
 Key-Valueストア型データベース ドキュメント指向データベース カラム指向データベース グラフ指向データベース  Key-Valueストア型データベース  Key-Valueストア型データベース(Key-Value Store: KVS) は， NoSQLの中でも最もシンプルな構造のデータベースです． キー（Key）とバリュー(Value)の組み合わせだけで表現され， 高いスケーラビリティ（データの規模に合わせて拡張可能なこと）を誇ります． ここでは，果物の英単語の辞書データベースを例に考えてみましょう．
   キー バリュー     apricot アンズ   apple リンゴ   banana バナナ   cherry サクランボ   coconut ココナッツ   cranberry クランベリー    【果物の英単語】</description>
    </item>
    
    <item>
      <title>SQL(5) トランザクション</title>
      <link>https://mukai-lab.info/pages/classes/database/chapter11/</link>
      <pubDate>Fri, 25 Oct 2019 10:32:49 +0900</pubDate>
      
      <guid>https://mukai-lab.info/pages/classes/database/chapter11/</guid>
      <description>データベースの復元  前回までに作成したデータベースを読み込むには，[File]→[Open DB]をクリックし， 保存した sqlite4.db を選択します． 復元したデータベースに【学生リスト】，【学部リスト】，【テニス部】，【サッカー部】，【商品リスト】，【八百屋】，【果物屋】があることを確認しましょう．
sqlite4.db
   学籍番号 氏名 学年 学部 よみがな     A001 岩城隼人 2 工学部 いわきはやと   A002 岩村優 1 工学部 いわむらゆう   B003 杉江弘子 3 人文学部 すぎえひろこ   C004 仙波あすか 1 国際関係学部 せんばあすか   D006 山下隆 4 経営情報学部 やましたたかし    【学生リスト】
   学部 キャンパス 教員数     工学部 春日井 30   人文学部 春日井 20   国際関係学部 名古屋 25    【学部リスト】</description>
    </item>
    
    <item>
      <title>SQL(5) トランザクション</title>
      <link>https://mukai-lab.info/pages/classes/database/chapter11_sqlite/</link>
      <pubDate>Fri, 25 Oct 2019 10:32:49 +0900</pubDate>
      
      <guid>https://mukai-lab.info/pages/classes/database/chapter11_sqlite/</guid>
      <description>テーブルのレストア  前回までに作成したテーブルを .restore でレストアしましょう． また，.tableで【学生リスト】，【学部リスト】，【テニス部】，【サッカー部】，【商品リスト】，【八百屋】，【果物屋】があることを確認しましょう．
sqlite&amp;gt; .restore db4.sqlite sqlite&amp;gt; .table サッカー部 八百屋 学生リスト 果物屋 テニス部 商品リスト 学部リスト    学籍番号 氏名 学年 学部 よみがな     A001 岩城隼人 2 工学部 いわきはやと   A002 岩村優 1 工学部 いわむらゆう   B003 杉江弘子 3 人文学部 すぎえひろこ   C004 仙波あすか 1 国際関係学部 せんばあすか   D006 山下隆 4 経営情報学部 やましたたかし    【学生リスト】
   学部 キャンパス 教員数     工学部 春日井 30   人文学部 春日井 20   国際関係学部 名古屋 25    【学部リスト】</description>
    </item>
    
    <item>
      <title>ジャパンサーチからSPARQLでデータ取得</title>
      <link>https://mukai-lab.info/pages/tech/japan_search/japan_search/</link>
      <pubDate>Tue, 15 Oct 2019 19:30:30 +0900</pubDate>
      
      <guid>https://mukai-lab.info/pages/tech/japan_search/japan_search/</guid>
      <description>ジャパンサーチとは  ジャパンサーチは，様々な分野のデジタルアーカイブと連携することで， 日本が保有するコンテンツを横断的に検索することができるポータルサイトのことです（現在はベータ版が公開）． コンテンツには，作品名，分類，品質形状，時代世紀，所蔵者などのメタデータ付与されており， 地方活性化，教育研究など様々な目的で活用することが可能となっています． 2019年10月現在においては，連携データベース数は50，また， 登録されているメタデータ件数（コンテンツ数）は17,959,770となっており， 今後も登録数は増加していくと考えられます．
それでは，「名古屋城図」をキーワードに検索してみましょう． すると，国立国会図書館デジタルコレクションに所属される 名古屋城図がヒットします． このデジタル化された地図は パブリックドメイン であり，著作権による制限を受けず，自由に利用することができます． また，メタデータとして，下記に示すような情報が提供されます（一部のみを掲載）．
   項目 値     名称/タイトル 名古屋城図[1]   名称/タイトルヨミ ナゴヤジョウズ   資料種別 和古書   著作権情報 インターネット公開(保護期間満了)   件名 城郭/尾張国/名古屋   提供者のURL http://dl.ndl.go.jp/info:ndljp/pid/2589695   サムネイル画像URL http://dl.ndl.go.jp/titleThumb/info:ndljp/pid/2589695    
これらのレコード（メタデータ）を取得するには下記の2通りの方法があります．
 簡易Web API SPARQL API  簡易Web API は，登録されているレコードを検索するための簡易的な機能です． プログラミングの必要はなく，ブラウザで指定する URL に一工夫するだけで検索が可能です． 一方，SPARQL APIは，問い合わせ言語であるSPARQL（スパークル）を利用して， 様々な条件を指定してレコードを取得する機能です．</description>
    </item>
    
    <item>
      <title>SQL(4) 関係代数演算</title>
      <link>https://mukai-lab.info/pages/classes/database/chapter10/</link>
      <pubDate>Wed, 09 Oct 2019 12:29:34 +0900</pubDate>
      
      <guid>https://mukai-lab.info/pages/classes/database/chapter10/</guid>
      <description>データベースの復元  前回までに作成したデータベースを読み込むには，[File]→[Open DB]をクリックし， 保存した sqlite3.db を選択します． 復元したデータベースに【学生リスト】，【学部リスト】，【テニス部】，【サッカー部】，【商品リスト】があることを確認しましょう．
sqlite3.db
   学籍番号 氏名 学年 学部 よみがな     A001 岩城隼人 2 工学部 いわきはやと   A002 岩村優 1 工学部 いわむらゆう   B003 杉江弘子 3 人文学部 すぎえひろこ   C004 仙波あすか 1 国際関係学部 せんばあすか    【学生リスト】
   学部 キャンパス 教員数     工学部 春日井 30   人文学部 春日井 20   国際関係学部 名古屋 25    【学部リスト】</description>
    </item>
    
    <item>
      <title>SQL(4) 関係代数演算</title>
      <link>https://mukai-lab.info/pages/classes/database/chapter10_sqlite/</link>
      <pubDate>Wed, 09 Oct 2019 12:29:34 +0900</pubDate>
      
      <guid>https://mukai-lab.info/pages/classes/database/chapter10_sqlite/</guid>
      <description>テーブルのレストア  前回までに作成したテーブルを .restore でレストアしましょう． また，.tableで【学生リスト】，【学部リスト】，【テニス部】，【サッカー部】，【商品リスト】があることを確認しましょう．
sqlite&amp;gt; .restore db3.sqlite sqlite&amp;gt; .table サッカー部 商品リスト 学部リスト テニス部 学生リスト    学籍番号 氏名 学年 学部 よみがな     A001 岩城隼人 2 工学部 いわきはやと   A002 岩村優 1 工学部 いわむらゆう   B003 杉江弘子 3 人文学部 すぎえひろこ   C004 仙波あすか 1 国際関係学部 せんばあすか    【学生リスト】
   学部 キャンパス 教員数     工学部 春日井 30   人文学部 春日井 20   国際関係学部 名古屋 25    【学部リスト】</description>
    </item>
    
    <item>
      <title>SQL(3) データの検索</title>
      <link>https://mukai-lab.info/pages/classes/database/chapter9/</link>
      <pubDate>Wed, 09 Oct 2019 12:29:32 +0900</pubDate>
      
      <guid>https://mukai-lab.info/pages/classes/database/chapter9/</guid>
      <description>データベースの復元  前回までに作成したデータベースを読み込むには，[File]→[Open DB]をクリックし， 保存した sqlite2.db を選択します． 復元したデータベースに【学生リスト】，【学部リスト】，【テニス部】，【サッカー部】があることを確認しましょう．
sqlite2.db
   学籍番号 氏名 学年 学部 よみがな     A001 岩城隼人 2 工学部 いわきはやと   A002 岩村優 1 工学部 いわむらゆう   B003 杉江弘子 3 人文学部 すぎえひろこ   C004 仙波あすか 1 国際関係学部 せんばあすか    【学生リスト】
   学部 キャンパス 教員数     工学部 春日井 30   人文学部 春日井 20   国際関係学部 名古屋 25    【学部リスト】</description>
    </item>
    
    <item>
      <title>SQL(3) データの検索</title>
      <link>https://mukai-lab.info/pages/classes/database/chapter9_sqlite/</link>
      <pubDate>Wed, 09 Oct 2019 12:29:32 +0900</pubDate>
      
      <guid>https://mukai-lab.info/pages/classes/database/chapter9_sqlite/</guid>
      <description>テーブルのレストア  前回までに作成したテーブルを .restore でレストアしましょう． また，.tableで【学生リスト】，【学部リスト】，【テニス部】，【サッカー部】があることを確認しましょう．
sqlite&amp;gt; .restore db2.sqlite sqlite&amp;gt; .table サッカー部 テニス部 学生リスト 学部リスト    学籍番号 氏名 学年 学部 よみがな     A001 岩城隼人 2 工学部 いわきはやと   A002 岩村優 1 工学部 いわむらゆう   B003 杉江弘子 3 人文学部 すぎえひろこ   C004 仙波あすか 1 国際関係学部 せんばあすか    【学生リスト】
   学部 キャンパス 教員数     工学部 春日井 30   人文学部 春日井 20   国際関係学部 名古屋 25    【学部リスト】</description>
    </item>
    
    <item>
      <title>SQL(2) データの更新</title>
      <link>https://mukai-lab.info/pages/classes/database/chapter8/</link>
      <pubDate>Tue, 08 Oct 2019 16:35:22 +0900</pubDate>
      
      <guid>https://mukai-lab.info/pages/classes/database/chapter8/</guid>
      <description>データベースの復元  前回までに作成したデータベースを読み込むには，[File]→[Open DB]をクリックし， 保存した sqlite1.db を選択します． 復元したデータベースに【学生リスト】と【学部リスト】があることを確認しましょう．
sqlite1.db

   学籍番号 氏名 学年 学部     A001 岩城隼人 2 工学部   A002 岩村優 1 工学部   B003 杉江弘子 3 人文学部   C004 仙波あすか 1 国際関係学部    【学生リスト】
   学部 キャンパス 教員数     工学部 春日井 30   人文学部 春日井 20   国際関係学部 名古屋 25    【学部リスト】</description>
    </item>
    
    <item>
      <title>SQL(2) データの更新</title>
      <link>https://mukai-lab.info/pages/classes/database/chapter8_sqlite/</link>
      <pubDate>Tue, 08 Oct 2019 16:35:22 +0900</pubDate>
      
      <guid>https://mukai-lab.info/pages/classes/database/chapter8_sqlite/</guid>
      <description>テーブルのレストア  前回までに作成したテーブルを .restore でレストアしましょう． また，.tableで【学生リスト】と【学部リスト】があることを確認しましょう．
sqlite&amp;gt; .restore db1.sqlite sqlite&amp;gt; .table 学生リスト 学部リスト    学籍番号 氏名 学年 学部     A001 岩城隼人 2 工学部   A002 岩村優 1 工学部   B003 杉江弘子 3 人文学部   C004 仙波あすか 1 国際関係学部    【学生リスト】
   学部 キャンパス 教員数     工学部 春日井 30   人文学部 春日井 20   国際関係学部 名古屋 25    【学部リスト】</description>
    </item>
    
    <item>
      <title>SQL(1)・データベースの作成</title>
      <link>https://mukai-lab.info/pages/classes/database/chapter7/</link>
      <pubDate>Tue, 08 Oct 2019 12:55:11 +0900</pubDate>
      
      <guid>https://mukai-lab.info/pages/classes/database/chapter7/</guid>
      <description>SQL  SQLは，リレーショナルデータベースに対して， データの操作を行うための 問い合わせ言語 です． System Rの問い合わせ言語であった SEQUEL がルーツであり， 現在は，ISOによって国際的に標準化され，様々なRDBMSで利用可能です． 集合演算 や 関係代数演算 などのリレーションに対する基本的な演算に加え， SUM や AVG などの関数が利用できるなど， データベースの運用において，必要な機能が組み込まれています．
SQLで利用可能な問い合わせは，下記の３種類に分類されます．
 データ操作言語（DML: Data Manipulation Language） データ定義言語（DDL: Data Definition Language） データ制御言語（DCL: Data Control Language）  DMLは，データの追加（INSERT），データの検索（SELECT）， DDLは，テーブルの作成（CREATE），テーブルの削除（DROP）， DCLは，データの変更の確定（COMMIT），データの変更の取り消し（ROLLBACK）などが該当します．
SQL Online IDE  SQLは様々なDBMSで利用が可能ですが， ここではオンラインで気軽にSQLによる問い合わせが可能なSQL Online IDEを利用します． このSQL Online IDEでは，SQLite，MariaDB， PostgreSQLなど代表的なDBMSのSQLをウェブブラウザで利用可能になっています． どのDBMSを選んでも大きな差はありませんが，ここではSQLiteを採用することにします． SQLiteはパブリックドメイン（知的財産権が発生しない）のリレーショナルデータベース管理システム（RDBMS）です． 一般的なRDBMSはクライアント・サーバ型で動作しますが， SQLiteはアプリに組み込まれるなどの形で，ソフトウェア（ライブラリ）単体とファイルで動作することが特徴です． それでは下記のリンクからSQL Online IDEにアクセスしましょう．
SQL Online IDE

SQLの記述ルール  SQLには様々な命令文がありますが，共通して下記のルールを守る必要があります． このルールを満たしていなければ，エラーとなり命令は実行されません．
 SQL文の最後に「;（セミコロン）」を付ける SQL文の大文字と小文字は区別されない（データは除く） 文字列データは「&amp;quot;（ダブルクオーテーション）」で囲む 単語の区切りは半角スペースを用いる（全角スペースは絶対に用いない）  例えば，テーブルからレコード（タプル）を取り出す SELECT文や， レコードを追加する INSERT文 は下記のように記述します． このとき，「SELECT」を「select」や「Select」と記述しても問題ありません．</description>
    </item>
    
    <item>
      <title>SQL(1)・データベースの作成</title>
      <link>https://mukai-lab.info/pages/classes/database/chapter7_sqlite/</link>
      <pubDate>Tue, 08 Oct 2019 12:55:11 +0900</pubDate>
      
      <guid>https://mukai-lab.info/pages/classes/database/chapter7_sqlite/</guid>
      <description>SQL  SQLは，リレーショナルデータベースに対して， データの操作を行うための 問い合わせ言語 です． System Rの問い合わせ言語であった SEQUEL がルーツであり， 現在は，ISOによって国際的に標準化され，様々なRDBMSで利用可能です． 集合演算 や 関係代数演算 などのリレーションに対する基本的な演算に加え， SUM や AVG などの関数が利用できるなど， データベースの運用において，必要な機能が組み込まれています．
SQLで利用可能な問い合わせは，下記の３種類に分類されます．
 データ操作言語（DML: Data Manipulation Language） データ定義言語（DDL: Data Definition Language） データ制御言語（DCL: Data Control Language）  DMLは，データの追加（INSERT），データの検索（SELECT）， DDLは，テーブルの作成（CREATE），テーブルの削除（DROP）， DCLは，データの変更の確定（COMMIT），データの変更の取り消し（ROLLBACK）などが該当します．
SQLite  SQLiteは， パブリックドメイン（知的財産権が発生しない）のリレーショナルデータベース管理システム（RDBMS）の一つです． 一般的なRDBMSはクライアント・サーバ型で動作しますが， SQLiteはアプリに組み込まれるなどの形で，ソフトウェア（ライブラリ）単体とファイルで動作することが特徴です． それでは，公式サイトからインストーラ（sqlite-tools-win32-x86-xxxx.zip）をダウンロードしてインストールしましょう． コマンドライン・ツール（sqlite3.exe）を含むインストーラを選択するようにしてください．
SQLiteのダウンロード
インストールが完了したら，インストールされたフォルダに含まれる コマンドライン・ツール（sqlite3.exe）をダブルクリックして起動してください．

コマンドラインツールでは，プロンプト（sqlite&amp;gt;） に， SQL文やSQLite独自のコマンドを入力することでテーブルを操作します． SQLite独自のコマンドは先頭に「.（ドット）」が付いています． 例えば，SQLiteを終了するには，.quitと入力します．

SQLの記述ルール  SQLには様々な命令文がありますが，共通して下記のルールを守る必要があります． このルールを満たしていなければ，エラーとなり命令は実行されません．
 SQL文の最後に「;（セミコロン）」を付ける SQL文の大文字・小文字は区別されない（データは除く） 文字列データは「&amp;quot;（ダブルクオーテーション）」で囲む 単語の区切りは半角スペースを用いる（全角スペースは絶対に用いない）  例えば，テーブルからレコード（タプル）を取り出す SELECT文や， レコードを追加する INSERT文 は下記のように記述します． このとき，「SELECT」を「select」と記述しても問題ありません．</description>
    </item>
    
    <item>
      <title>第2正規形と第3正規形</title>
      <link>https://mukai-lab.info/pages/classes/database/chapter6/</link>
      <pubDate>Tue, 01 Oct 2019 19:33:51 +0900</pubDate>
      
      <guid>https://mukai-lab.info/pages/classes/database/chapter6/</guid>
      <description>本日のリレーション  今回は下記の【履修リスト】と【学生リスト】を対象に解説します． 【履修リスト】は，学籍番号，科目名，成績，教室， 【学生リスト】は，学籍番号，氏名，学年，学部，キャンパスで構成されています． また，下線は主キーを表しています．
   学籍番号 科目名 成績 教室     A001 情報処理演習 A 001   A001 プログラミング A 003   A002 情報処理演習 A 001   A002 プログラミング B 003   B003 データベース A 002   B003 プログラミング C 003    【履修リスト】
   学籍番号 氏名 学年 学部 キャンパス     A001 岩城隼人 2 工学部 春日井   A002 岩村優 1 工学部 春日井   B003 杉江弘子 3 人文学部 春日井   C004 仙波あすか 1 国際関係学部 名古屋    【学生リスト】</description>
    </item>
    
    <item>
      <title>情報無損失分解と関数従属性</title>
      <link>https://mukai-lab.info/pages/classes/database/chapter5/</link>
      <pubDate>Tue, 24 Sep 2019 11:41:41 +0900</pubDate>
      
      <guid>https://mukai-lab.info/pages/classes/database/chapter5/</guid>
      <description>本日のリレーション  今回は下記の【履修リスト】を対象に解説します． 【履修リスト】は，学籍番号，科目名，成績，教室で構成されています． また，下線は主キーを表しています．
   学籍番号 科目名 成績 教室     A001 情報処理演習 A 001   A001 プログラミング A 003   A002 情報処理演習 A 001   A002 プログラミング B 003   B003 データベース A 002   B003 プログラミング C 003    【履修リスト】
更新時異常  リレーションの設計に問題があると， タプルの挿入・削除・更新を行う際に， 更新時異常（Update Anomaly）が発生することがあります． 【履修リスト】を例に，どのような問題が発生するか考えてみましょう．
タプル挿入時異常 カリキュラムが変更され 新規の科目「画像処理論」に関する情報を【履修リスト】に追加することを考えてみます． まだ履修する学生や成績は確定していないため，下記のタプルを追加することになります． このタプルは，主キーである学籍番号が空値であり，主キー制約に牴触してしまうため，追加することができません． これが，タプル挿入時異常 です．
   学籍番号 科目名 成績 教室      画像処理論  001    タプル削除時異常 学籍番号B003の学生が退学した場合を考えてみます． この場合，下記の2つのタプルをリレーションから削除することになります． 削除は問題なく実行可能ですが，これを削除してしまうと， データベースの履修者が【履修リスト】に存在しなくなってしまい， $(データベース,002)$という情報も失われてしまいます． これが，タプル削除時異常 です．</description>
    </item>
    
    <item>
      <title>関係代数演算</title>
      <link>https://mukai-lab.info/pages/classes/database/chapter4/</link>
      <pubDate>Sun, 22 Sep 2019 08:53:03 +0900</pubDate>
      
      <guid>https://mukai-lab.info/pages/classes/database/chapter4/</guid>
      <description>本日のリレーション  今回は下記の【サッカー部】，【テニス部】，【学部リスト】を対象に解説します． 【サッカー部】と【テニス部】は，学籍番号，氏名，学年，学部，また， 【学部リスト】は，学部，キャンパス，教員数で構成されています． また，下線は主キーを表しています．
   学籍番号 氏名 学年 学部     A001 岩城隼人 2 工学部   A003 内田弘 3 工学部   B003 杉江弘子 3 人文学部    【サッカー部】
   学籍番号 氏名 学年 学部     A002 岩村優 1 工学部   B003 杉江弘子 3 人文学部   C004 仙波あすか 1 国際関係学部    【テニス部】
   学部 キャンパス 教員数     工学部 春日井 30   人文学部 春日井 20   国際関係学部 名古屋 25    【学部リスト】</description>
    </item>
    
    <item>
      <title>主キーと外部キー</title>
      <link>https://mukai-lab.info/pages/classes/database/chapter3/</link>
      <pubDate>Sat, 21 Sep 2019 10:01:12 +0900</pubDate>
      
      <guid>https://mukai-lab.info/pages/classes/database/chapter3/</guid>
      <description>本日のリレーション  今回は下記の 【学生リスト】 と 【学部リスト】 を対象に解説します． 【学生リスト】は，学籍番号，氏名，学年，学部，また， 【学部リスト】は，学部，キャンパス，教員数で構成されています．
   学籍番号 氏名 学年 学部     A001 岩城隼人 2 工学部   A002 岩村優 1 工学部   B003 杉江弘子 3 人文学部   C004 仙波あすか 1 国際関係学部    【学生リスト】
   学部 キャンパス 教員数     工学部 春日井 30   人文学部 春日井 20   国際関係学部 名古屋 25    【学部リスト】</description>
    </item>
    
    <item>
      <title>リレーションと第1正規形</title>
      <link>https://mukai-lab.info/pages/classes/database/chapter2/</link>
      <pubDate>Fri, 20 Sep 2019 17:45:42 +0900</pubDate>
      
      <guid>https://mukai-lab.info/pages/classes/database/chapter2/</guid>
      <description>リレーショナルデータベースの特徴  リレーショナルデータベースは，関係データベースやRDB（Relational Data Base）とも呼ばれ， 最も広く利用されるデータベースです． 1968年にリレーショナルデータベースのアイデアが発表され， 現在でもデータベースの主流であることから，その有用性の高さが想像できると思います． 2次元の表形式という直感的で分かりやすいデータ形式でありながらも， 数学の集合論 が基本となっており，厳密なルールで運用されます． 今回は，集合論の概念を用いながら， リレーショナルデータベースがどのように構築されるかを解説します．
リレーションとは  リレーショナルデータベースは，その名の通り， データの リレーション（関係） を記述するためのデータベースです． では，一体，リレーションとは何を表すのでしょうか． 集合論の概念を利用して考えていきましょう．
ドメイン ドメイン とは，特定の条件を満たす 要素（元） から構成される集合のことです． 例えば，名前の集合，電話番号の集合は，それぞれドメインです． 一般に，ドメインは $D_i$ で表現されます．
$$ D_1 = \left( 高谷舞衣,福岡豊樹,西村朱音 \right) $$
$$ D_2 = \left( 0786857519,0265723899,0178189244 \right) $$
この他にも，アルファベットの集合や，整数の集合もドメインと考えることができます． ここでは，有限集合のみを対象としていますが，無限集合でも問題ありません．
$$ D_3 = \left( a, b, c \right) $$
$$ D_4 = \left( 1, 2, 3, 4, 5 \right) $$
ドメインの直積 ドメインを対象として，直積 という演算が定義されます． 直積は $D_1 \times D_2$ のように表現され， 各ドメインから一つずつ要素を取り出して組にした新たなドメインになります． $D_1$と$D_2$の直積の場合，新たなドメインの要素数は$3 \times 3 = 9$ です．</description>
    </item>
    
    <item>
      <title>データベースとは</title>
      <link>https://mukai-lab.info/pages/classes/database/chapter1/</link>
      <pubDate>Fri, 20 Sep 2019 13:08:48 +0900</pubDate>
      
      <guid>https://mukai-lab.info/pages/classes/database/chapter1/</guid>
      <description>データベースとは  データベース（DB: Database） とは何でしょうか． 広義の意味では単に「データの集まり」がデータベースであると言えます． 意識したことはあまりないかもしれませんが，身の回りにデータベースは多く存在しています． 例えば，スマートフォンで管理しているアドレス帳も，氏名，電話番号, メールアドレス を管理するためのデータベースと言えます． その他にも，Amazonや楽天などのショッピングサイトは顧客情報，商品情報，また，皆さんが所属する大学は学生情報，科目情報などをデータベースとして管理しています． このように考えると，皆さんは日常的にデータベースに囲まれながら生活していると考えることができますね．
例題1   身の回りにあるデータベースを3つ挙げなさい．  -- データベースで管理されるデータとは  次にデータベースで管理されるデータについて考えてみましょう． 一般に，データベースは，何かしらの目的を持って構築されます． 例えば，スマートフォンのアドレス帳は，氏名，電話番号, メールアドレス を収集することで， 特定の相手への電話やメールでのコンタクトを可能にしています． このように，データは目的に合わせ，一定の規則に従って収集されることになります． また，これらをまとめたデータの基地（ベース）が データベース と言えます．
   氏名 電話番号 メールアドレス     高谷舞衣 0786857519 mai@mctp.tubcn.pml   福岡豊樹 0265723899 toyoki@fhixe.lg   西村朱音 0178189244 akane@dpqknirhzo.sn    データベースの管理方法  さて，このようなデータベースを管理するにはどのような方法があるでしょうか． 古くは手帳などの紙媒体で記録していましたが，現代はコンピュータを用いて管理するのが一般的です（もちろんスマートフォンも含む）． 皆さんがコンピュータでデータを管理する時はどんなソフトウェアを用いるでしょうか． 最も身近なソフトウェアは Excel ではないでしょうか． それでは，Excelで上記のアドレス帳のデータを作成してみましょう．
例題2   上記のアドレス帳のデータをExcelで作成し，xlsx形式とcsv形式で保存しなさい．  --</description>
    </item>
    
    <item>
      <title>BITalinoで筋電位センサー</title>
      <link>https://mukai-lab.info/pages/tech/bitalino/bitalino2/</link>
      <pubDate>Tue, 20 Aug 2019 16:43:49 +0900</pubDate>
      
      <guid>https://mukai-lab.info/pages/tech/bitalino/bitalino2/</guid>
      <description>筋電位センサー  今回はBITalinoの 筋電位センサー（EMG） を利用してみましょう． 筋電位センサーの電極ケーブルは3極で構成され，中央が基準電極（REF），左右が正極（+）と負極（-）を表しています． このように，2極の信号の差分を増幅して取得する方法は 作動増幅 と呼ばれ，生体センシングではよく用いられる方法です．

筋電位センサーを腕に取り付けます． 基準となる基準電極は肘の骨がある部分に配置します． また，正極と負極は筋繊維に沿って配置します．

OpenSignalsでデータを取得してみましょう． まずは，BITalinoの設定を変更します． 今回はA1に筋電位センサー（EMG）を接続しているため，EMG を指定しています．

計測を開始すると，0を平均として小さなスパイク状の波形が発生している． ここで，腕に力をいれると，波の振幅は大きくなることがわかります．

Python APIを利用した筋電位の取得  それでは，Python APIを利用して筋電位のデータを取得してみましょう． データの取得方法は光センサーのときと全く同じです． しかし，取得されるデータはBITalino独自の単位となっているため， 一般的なミリボルト（mV）を単位とするには下記の式を用いて変換が必要です （詳細は公式ドキュメント参照）．
$$ EMG(mV) = \frac{ (x / 2^n - 1 / 2) \cdot VCC \cdot 1000 }{ GAIN } $$
上記の式において，$n$は信号のビット幅であり10ビット，$VCC$は電源電圧であり3.3ボルト，$GAIN$はセンサーゲインであり1009を指定します． この変換したデータ（mV）の 平均，標準偏差，最大値 を求めてみることにします．
BITS = 10 # 信号のビット幅 VCC = 3.3 # 電源電圧 GAIN = 1009 # センサーゲイン emg = (((((data[:,5] / 2**BITS) - 1/2) * VCC) / GAIN) * 1000) # 単位変換（mV） emg = np.</description>
    </item>
    
    <item>
      <title>BITalinoで光センサー</title>
      <link>https://mukai-lab.info/pages/tech/bitalino/bitalino/</link>
      <pubDate>Tue, 20 Aug 2019 13:10:45 +0900</pubDate>
      
      <guid>https://mukai-lab.info/pages/tech/bitalino/bitalino/</guid>
      <description>BITalinoとは  BITalinoは， 医療などを目的として用いられる生体信号をリアルタイムに取得するためのハードウェア（プラットフォーム）です． BITalinoを始めるには，「Plugged Kit」「Board Kit」「Freestyle Kit」の3種類のスタータキットが存在しますが， ここでは，メインボードと各種センサーが切り離された「Plugged Kit」を用いることにします． 2019年8月現在，医療機器のオンラインショップのCreactでは34,700円で販売されています． BITalinoでは，センサーから取得した値をBluetoothを経由して，PCに送信することが可能です． このとき，提供されるAPIを利用することになりますが，Python，Java，Unityなど様々なプログラミング言語が利用可能です． ここでは，Pythonを利用してすることにしましょう．
まずは，BITalinoで何が出来るか確認してみましょう． 下記はBITalinoで筋電位を計測することで，ドローンのコントローラとして用いています． 生体信号を用いることで，これまでには存在しなかった，新しいインターフェースの開発が可能です．
  下記は，マウスの代わりに筋電位を用いてPCの決定操作を行っています． 生体信号をトリガーとして用いることで， 四肢障害を抱えた人でもPCを操作することが可能となります．
  初期設定  それでは，BITalinoの初期設定を行いましょう． まずは，メインボードにバッテリーと光センサー（LUC）を下図のように接続してください． メインボードはバッテリー以外にも，USB Type Bの端子からも給電が可能です． また，光センサーは，メインボードの A1 に接続します（アナログ入力の1番）．

次に，BITalinoのメインボードのスイッチを入れます． ボード上のLEDが白く点灯します． この状態で，PCとBluetoothで接続します． 検出されたBITalinoの追加には，PINコードが必要となりますが， これはウェブで公開されているように 1234 を入力します．


オープンシグナルズ  OpenSignalsは，BITalinoが公式に提供している取得したデータの可視化ソフトウェアです． 様々なプラグインも提供されており，OpenSignals単体だけでも，様々な分析が可能です．
OpenSignalsを起ち上げると，下記のようにBuetoothで接続されたBITalinoが検出されます． ここで，表示されるMACアドレス（ 20:16:12:21:35:82 ）は，後述のAPIでも利用しますのでメモしておきましょう． 加えて，メインボードに接続されているセンサーを設定します． ここでは，A1 に 光センサー（LUX） が接続されていることを指定します．


計測を開始すると，下図のように折れ線グラフでセンサーから取得された値が表示されます． 今回使用しているのは，光センサーであるため，通常は部屋の照明により 30% の照度となっています． このセンサーを手で覆うと，ほぼ 0% の照度となることがわかります．

Python APIを利用した照度の取得  それでは，APIを利用してBITalinoからデータを取得してみましょう． 使用するプログラミング言語は Python です． 対応するPythonのバージョンは 3.</description>
    </item>
    
    <item>
      <title>Caffe-Segnetのインストール</title>
      <link>https://mukai-lab.info/pages/tech/caffe/caffe/</link>
      <pubDate>Wed, 14 Aug 2019 13:07:59 +0900</pubDate>
      
      <guid>https://mukai-lab.info/pages/tech/caffe/caffe/</guid>
      <description>Caffe-Segnetのインストール ディープラーニングのライブラリである Caffe-Segnet をMacにインストールしたときのメモです． 基本的には公式のインストラクションに従います． このQiitaの記事や ブロクも参考にさせて頂きました．
まずは依存ライブラリをインストールします．
brew install -vd snappy leveldb gflags glog szip lmdb brew tap brewsci/science # homebrew-scienceは廃止 brew install hdf5 opencv 次に，ptofobufとboost-pythonをビルドしてインストールします． このビルドはかなりの時間を要します．
brew install --build-from-source -vd protobuf # --with-pythonは除く brew install --build-from-source -vd boost boost-python CPU_ONLY := 1 mkdir build cd build cmake .. make all make install make runtest </description>
    </item>
    
    <item>
      <title>オープンストリートマップでオリジナル地図を作成しよう</title>
      <link>https://mukai-lab.info/pages/tech/leaflet/leaflet/</link>
      <pubDate>Fri, 09 Aug 2019 14:34:10 +0900</pubDate>
      
      <guid>https://mukai-lab.info/pages/tech/leaflet/leaflet/</guid>
      <description>オープンストリートマップとは  オープンストリートマップ（OpenStreetMap: OSM）は， グーグルマップ（Google Maps）と同様のオンライン地図のサービスの一つです． グーグルマップは非営利であっても印刷物としての使用に制限がありますが， オープンストリートマップは適切にクレジットを表示すれば， 営利目的も含め，複製・再配布・改変が認められているという特徴があります（CC By-SA 2.0）．
オープンストリートマップで表示される地図は， 地図タイル と呼ばれる格子状の画像を並べることで構成されます． 地図タイルは下記の REST API と呼ばれる方法を用いて取得することが可能です． 倍率Z，座標X，座標Yを指定することで，世界の地図タイルを自由に表示できます．
https://a.tile.openstreetmap.org/{倍率:z}/{座標:X}/{座標:Y}.png 例えば，下記のように倍率Z=0，座標X=0，座標Y=0を指定してみましょう． これを表示すると，世界が一枚の地図タイルで表示されることがわかります．
 https://a.tile.openstreetmap.org/0/0/0.png
次に，倍率Z=1にして，地図タイルを取得します． 地図タイル数は $2^{2 \cdot z}$ で与えらるため， 倍率X=1のときは，4枚の地図タイルで世界を表現していることになります．
【左上】
 https://a.tile.openstreetmap.org/1/0/0.png
【左下】
 https://a.tile.openstreetmap.org/1/0/1.png
【右上】
 https://a.tile.openstreetmap.org/1/1/0.png
【右下】
 https://a.tile.openstreetmap.org/1/1/1.png
現状で，オープンストリートマップは，倍率Z=18まで利用可能となっています． このため，倍率Z=18の地図タイル数は，なんと，$2^{2 \cdot 18} = 68719476736$となっています． 今回は，このオープンストリートマップを利用して，オリジナルの地図を作成しましょう．
サンプルをダウンロードしよう  オープンストリートマップを利用して地図を作成するために， JavaScript というプログラミング言語のライブラリである Leafletを利用します． なんだかとても難しそうですが，今回はサンプル・ファイルをダウンロードして，一部を書き換えるだけなので，とっても簡単です． コンピュータが苦手な人も安心してください．
下記がサンプル・ファイル（Sample.html）です． ダウンロードしたら Chrome などのブラウザで開いてみてください．
 Sample.html
ブラウザで開くと，椙山女学園大学を中心とした地図が表示されます． マウスを使って，地図を自由に操作してみてください． マーカーをクリックすると「椙山女学園大学」や「星ヶ丘駅」と表示されます． また，地図上をクリックすると，クリックした位置の 緯度・経度 が表示されます．</description>
    </item>
    
    <item>
      <title>Carlaでセマンティック・セグメンテーション</title>
      <link>https://mukai-lab.info/pages/tech/carla/carla2/</link>
      <pubDate>Thu, 08 Aug 2019 11:28:22 +0900</pubDate>
      
      <guid>https://mukai-lab.info/pages/tech/carla/carla2/</guid>
      <description>セマンティック・セグメンテーション  セマンティック・セグメンテーション は人間の目の役割を担う技術のことであり，自動運転車の実現のために必須です． 具体的には，車両に取り付けられたカメラから取得される画像の， 各ピクセル（画素）に対し，「自動車」「人」「道路」などラベルを設定する仕組みのことです．
一般にセマンティック・セグメンテーションを実現するには，ディープラーニング が用いられます． 特にケンブリッジ大学のAlex Kendall氏が提案したSegNetが有名です． SegNetはRGB画像を入力とし，画像に存在する物体にラベルを設定することが出来ます． 下記はSegNetのデモ動画です．
  CARLA Simulatorのセマンティック・セグメンテーションはあくまで疑似センサーであり，正確なラベル付けが可能です． 各画素のラベルは，赤・緑・青（RGB）の 赤（R） の値として表現されます． 設定されるラベルは下記の13種類です．
   値 ラベル     0 なし   1 建物   2 フェンス   3 その他   4 歩行者   5 柱   6 道路線   7 道路   8 歩道   9 街路樹   10 車両   11 壁   12 信号    Pythonクライアントの実装  クライアントの初期化 それでは，セマンティック・セグメンテーションのラベルを得るためのPythonクライアントを実装しましょう． サーバーに接続するためのクライアントは with構文 を利用して生成します． このとき，サーバのIPアドレスとポート（デフォルトでは2000番）を指定します．</description>
    </item>
    
    <item>
      <title>CARLAシミュレータの導入</title>
      <link>https://mukai-lab.info/pages/tech/carla/carla/</link>
      <pubDate>Wed, 07 Aug 2019 13:57:04 +0900</pubDate>
      
      <guid>https://mukai-lab.info/pages/tech/carla/carla/</guid>
      <description>CARLA  近年，研究が急速に進む 自動運転車（Autonomous Car） のシミュレータの一つである CARLA Simulatorの導入に関して解説します． このCARLAはオープンソースとして開発されており， 自動運転車の実現に必須の，LiDAR（Light Detection and Ranging） ，多視点カメラ，深度カメラ などのセンサー群を利用することができます． この他にも，マップの自動生成や，交通シナリオの作成など，シミュレータに必要な要素も含まれています． このCARLAは，Alexey Dosovitskiy 氏らによって開発され， 2017年に Robot Learning の国際会議において，「CARLA: An Open Urban Driving Simulator」というタイトルで論文も発表されています．
CARLAの導入  CARLAの導入はとても簡単で，Githubで公開されているビルドされたパッケージをダウンロードするだけです． 現時点（2019年8月）では，最新版は 0.9.6 ですが，ここでは安定版の 0.8.2 を利用することにします．
 CARLA 0.8.2(stable)
ダウンロードしたファイルを解凍すると， CarlaUE4.exe というウィンドウズ用の実行ファイルがあります． これをダブルクリックすると，シミュレータが全画面表示されます（スタンドアロン・モード）． 画面左には，速度(Speed)やギア（Gear）などの情報が表示されていることがわかります．

この画面では，キーボードで車両を操作することができます（操作一覧も参照のこと）． キーボードで操作するのはとても難しく，ぎこちない運転になってしまうので，オートパイロット を試してみると良いです．
   キー 操作     W アクセル   A ステアリング（左）   S ブレーキ   D ステアリング（右）   Q ギアチェンジ   P オートパイロット</description>
    </item>
    
    <item>
      <title>k平均法</title>
      <link>https://mukai-lab.info/pages/classes/intelligence_information_system/chapter12/</link>
      <pubDate>Sat, 20 Jul 2019 14:30:56 +0900</pubDate>
      
      <guid>https://mukai-lab.info/pages/classes/intelligence_information_system/chapter12/</guid>
      <description>クラスタリング  これまで取り上げた手法は全て 教師あり学習 でした． 今回は，正解（教師）が与えられない 教師なし学習 に注目します． 教師なし学習の一つが クラスタリング と呼ばれる手法です． クラスタリングは，対象データの類似度を基に，グループ（クラスタ）に分けることが目的となります． 分類と混同されがちですが，正解（教師）は存在しないため， 同じクラスタに割り当てられたデータは 似ている とみなすことができますが， その割り当てが 正しい， 正しくない といった判断は出来ないことに注意してください． また，クラスタリングには，階層型手法 と 非階層型手法 に分かれますが， ここでは非階層型手法を取り上げることにします．
ノートブックの作成  Colabにアクセスし，新規にノートブックを作成してください． ノートブックのタイトルは chapter12 とします． また，numpy，matplotlib.pyplot, scikit-learn，pandas を導入しておいてください．
import numpy as np import matplotlib.pyplot as plt from sklearn.cluster import KMeans import pandas as pd データの準備  ユニセフ・世界子供白書が公開している人口統計指標のデータを用います． ここでは，世界各国の2016年度の出生率（人口1,000人に対する出生数）と死亡率（人口1,000人に対する死亡数）のデータに着目します． ウェブで公開されているデータを読み込み，pandasのデータフレームを生成します． 例えば，アフガニスタンの死亡率は7，出生率は33であることが分かります．
data = pd.read_csv(&amp;#34;http://mukai-lab.info/classes/intelligence_information_system/population2016.csv&amp;#34;) display(data.head()) #最初の5件だけ表示 
一方，日本の死亡率は11，出生率は8であり，少子高齢化が進んでいることが読み取れます．
japan = data[data[&amp;#34;国&amp;#34;] == &amp;#34;日本&amp;#34;] #日本を表示 display(japan)</description>
    </item>
    
    <item>
      <title>決定木</title>
      <link>https://mukai-lab.info/pages/classes/intelligence_information_system/chapter11/</link>
      <pubDate>Fri, 12 Jul 2019 19:14:01 +0900</pubDate>
      
      <guid>https://mukai-lab.info/pages/classes/intelligence_information_system/chapter11/</guid>
      <description>ノートブックの作成  Colabにアクセスし，新規にノートブックを作成してください． ノートブックのタイトルは chapter11 とします．
最初にグラフで日本語表示を可能とするjapanize-matplotlibをインストールします．
!pip install japanize-matplotlib また，numpy，matplotlib.pyplot ，scikit-learn に加えて， データフレームを処理するための Pandasをインポートします．
import numpy as np import matplotlib.pyplot as plt from sklearn import tree from sklearn.tree import plot_tree import pandas as pd import japanize_matplotlib データの準備  今回は，曜日（平日 or 土日） ， 時間帯（昼 or 夜） ，価格（高 or 安）， 天気（晴 or 雨） の情報を利用して， イベントの 来場者数（多 or 少） を分類（予測）してみましょう． 学習用のデータには15のサンプルが含まれています． また，学習用のデータの表現のため，データフレーム（Excelの表のようなもの）を利用します． これまでの行列とは異なり，データフレームには 属性名（列名） を設定することが可能です．
[In:]
df = pd.DataFrame( { &amp;#34;曜日&amp;#34;: [&amp;#34;平日&amp;#34;,&amp;#34;平日&amp;#34;,&amp;#34;平日&amp;#34;,&amp;#34;平日&amp;#34;,&amp;#34;平日&amp;#34;,&amp;#34;平日&amp;#34;,&amp;#34;土日&amp;#34;,&amp;#34;平日&amp;#34;,&amp;#34;平日&amp;#34;,&amp;#34;平日&amp;#34;,&amp;#34;平日&amp;#34;,&amp;#34;平日&amp;#34;,&amp;#34;平日&amp;#34;,&amp;#34;平日&amp;#34;,&amp;#34;土日&amp;#34;], &amp;#34;時間帯&amp;#34;:[&amp;#34;昼&amp;#34;,&amp;#34;夜&amp;#34;,&amp;#34;昼&amp;#34;,&amp;#34;昼&amp;#34;,&amp;#34;夜&amp;#34;,&amp;#34;昼&amp;#34;,&amp;#34;夜&amp;#34;,&amp;#34;昼&amp;#34;,&amp;#34;夜&amp;#34;,&amp;#34;昼&amp;#34;,&amp;#34;夜&amp;#34;,&amp;#34;昼&amp;#34;,&amp;#34;昼&amp;#34;,&amp;#34;夜&amp;#34;,&amp;#34;昼&amp;#34;], &amp;#34;価格&amp;#34;:[&amp;#34;安&amp;#34;,&amp;#34;安&amp;#34;,&amp;#34;高&amp;#34;,&amp;#34;高&amp;#34;,&amp;#34;高&amp;#34;,&amp;#34;高&amp;#34;,&amp;#34;安&amp;#34;,&amp;#34;高&amp;#34;,&amp;#34;安&amp;#34;,&amp;#34;高&amp;#34;,&amp;#34;高&amp;#34;,&amp;#34;安&amp;#34;,&amp;#34;安&amp;#34;,&amp;#34;高&amp;#34;,&amp;#34;安&amp;#34;], &amp;#34;天気&amp;#34;:[&amp;#34;晴&amp;#34;,&amp;#34;晴&amp;#34;,&amp;#34;晴&amp;#34;,&amp;#34;雨&amp;#34;,&amp;#34;晴&amp;#34;,&amp;#34;晴&amp;#34;,&amp;#34;雨&amp;#34;,&amp;#34;晴&amp;#34;,&amp;#34;雨&amp;#34;,&amp;#34;晴&amp;#34;,&amp;#34;晴&amp;#34;,&amp;#34;晴&amp;#34;,&amp;#34;雨&amp;#34;,&amp;#34;晴&amp;#34;,&amp;#34;晴&amp;#34;,], &amp;#34;来場者数&amp;#34;:[&amp;#34;多&amp;#34;,&amp;#34;多&amp;#34;,&amp;#34;少&amp;#34;,&amp;#34;多&amp;#34;,&amp;#34;多&amp;#34;,&amp;#34;少&amp;#34;,&amp;#34;少&amp;#34;,&amp;#34;少&amp;#34;,&amp;#34;少&amp;#34;,&amp;#34;少&amp;#34;,&amp;#34;多&amp;#34;,&amp;#34;多&amp;#34;,&amp;#34;多&amp;#34;,&amp;#34;多&amp;#34;,&amp;#34;多&amp;#34;,] } ) display(df)</description>
    </item>
    
    <item>
      <title>Tobii Eye Trackerでシューティング</title>
      <link>https://mukai-lab.info/pages/tech/unity/tobii2/</link>
      <pubDate>Thu, 11 Jul 2019 18:33:33 +0900</pubDate>
      
      <guid>https://mukai-lab.info/pages/tech/unity/tobii2/</guid>
      <description>シューティング  前回はTobii Unity SDK for Desktopを利用して， オブジェクトの注視状態を取得する方法を説明しました． 今回はスクリーン上の 注視座標 を取得することを目指します． また，この注視座標を利用して，簡単なシューティング・ゲームを制作してみたいと思います．
プロジェクトの作成  Unityでプロジェクトを新規作成します． テンプレートは 2D ， プロジェクト名は TobiiShooting に設定します． また，Tobii Unity SDK for Desktopをプロジェクトに導入してください．

アセットの導入とオブジェクトの配置  シューティングに必要なアセットを導入します． Asset Store から Fighter Interceptor をダウンロードします（無料）． このファイターの3Dモデルを自機とします．
また，背景色は黒にするため，Main Camera の背景（Background）は， 黒（#000000）に設定しておきます．
次に，シーンに下記のオブジェクトを配置します．
 方向性ライト（Directional Light） 導入したFighter Intercepterの Fighter オブジェクト  Fighterオブジェクトの，位置（Position），回転（Rotation），スケール（Scale）は下図のように設定します．

ここまでで，ゲーム画面を確認すると下記のようになります．

ミサイルのプレハブの実装  次に，自機が発射するミサイルを実装します． ミサイルは Sphere で表すことにします． シーンに追加したら Missile にリネームしてください． 位置（Position），回転（Rotation），スケール（Scale）は下図のように設定します．

また，マテリアルを Yellow に変更しておきます．</description>
    </item>
    
    <item>
      <title>Tobii Eye Trackerで視線検出</title>
      <link>https://mukai-lab.info/pages/tech/unity/tobii/</link>
      <pubDate>Wed, 10 Jul 2019 11:06:05 +0900</pubDate>
      
      <guid>https://mukai-lab.info/pages/tech/unity/tobii/</guid>
      <description>Tobii Eye Tracker  トビー・テクノロジーが開発する Tobii Pro X2や Tbii Eye Tracker 4Cなどの視線入力装置を ゲームエンジンのUnityで利用するための実装方法を解説します． これらの視線入力装置は，既に，FFXV など143のPCゲームで利用可能であり（2019年7月現在）， ゲームをより楽しむためのサポート手段として用いられています． 視線入力装置を利用したゲーム映像はTobii Gamesで公開されているので視聴してみると良いでしょう．
Unityでの開発にはTobii Unity SDK for Desktopを利用します． この開発キットは，あくまで個人利用向けであり，分析を目的として利用する場合は，別途ライセンスの購入が必要なことに注意してください（向は分析用のライセンスも所持しています）． また，システム要件として下記が挙げられています．
 バージョン 5 または 4.5 以上のUnity ウィンドウズ10，8.1，7 Core Softwareのインストール  それでは，Tobii Unity SDK for Desktopをダウンロードしてください． 2019年7月現在のバージョンは 4.04 です．
プロジェクトの作成  まずは，Unityでプロジェクトを新規作成します． テンプレートは 2D ，プロジェクト名は TobiiSample に設定します（もちろん 3D でも利用可能です）．

次に，ダウンロードした，Tobii Unity SDK for Desktopをプロジェクトに導入しましょう． [Assets] → [Import Package] → [Custom Package] をクリックし，ダウンロードしたファイルを選択します．
背景とオブジェクトの設定 背景を設定しましょう． ここでは，Main Camera の Background を白（#FFFFFF）にします（別にどんな色でも構いませんが）．</description>
    </item>
    
    <item>
      <title>分類④・k近傍法</title>
      <link>https://mukai-lab.info/pages/classes/intelligence_information_system/chapter10/</link>
      <pubDate>Sun, 07 Jul 2019 12:36:17 +0900</pubDate>
      
      <guid>https://mukai-lab.info/pages/classes/intelligence_information_system/chapter10/</guid>
      <description>ノートブックの作成  Colabにアクセスし，新規にノートブックを作成してください． ノートブックのタイトルは chapter10 とします． また，numpy，matplotlib.pyplot に加え，機械学習ライブラリのscikit-LearnとSciPyをインポートします．
import numpy as np import matplotlib.pyplot as plt from sklearn.datasets import load_iris from sklearn.neighbors import KNeighborsClassifier import scipy.stats as stats データの準備  あらかじめ用意された機械学習のための データセット を利用することができます． ここでは，scikit-learn ライブラリに収録されている アヤメ（iris） のデータセットを用います． アヤメは草地に生息している植物であり， setosa， versicolor， virginica などの種類があります（和名はよく分かりませんでした）． このデータセットには，上記３種類のアヤメの， がく片の長さ（Sepal Length） ，がく片の幅（Sepal Width） ， 花弁の長さ（Petal Length） ，花弁の幅（Petal Width） を計測したデータが含まれています．

各種類に50のサンプルがあり，例えば，最初のデータは[5.1,3.5,1.4, 0.2]となっています． これは，がく片の長さが5.1cm，がく片の幅が3.5cm，花弁の長さが1.4cm，花弁の幅が0.2cmを表しています． ラベルは0,1,2のいずれかで与えられ，それぞれsetosa，virsicolor, virginicaを表しています． 最初のサンプルのラベルは0であるため，これは setosa であることがわかります．
[In:]
iris = load_iris() print(iris.feature_names) #フィールド名 print(iris.data[0:5]) #フィールド・データ print(iris.</description>
    </item>
    
    <item>
      <title>分類③・ロジスティック回帰</title>
      <link>https://mukai-lab.info/pages/classes/intelligence_information_system/chapter9/</link>
      <pubDate>Sat, 06 Jul 2019 12:29:32 +0900</pubDate>
      
      <guid>https://mukai-lab.info/pages/classes/intelligence_information_system/chapter9/</guid>
      <description>ノートブックの作成  Colabにアクセスし，新規にノートブックを作成してください． ノートブックのタイトルは chapter9 とします． また，numpy，matplotlib.pyplot，scipy.optimize を導入しておいてください．
import numpy as np import matplotlib.pyplot as plt from scipy.optimize import minimize データの準備  これまでは，リンゴとメロンの 大きさ（$x_1$） と 重さ（$x_2$） という2次元のデータを用いていました． 今回は単純化のため，大きさ（$x$） のみに注目して分類します． また，グラフで可視化するために，リンゴを$0$，メロンを$1$と表現することにします．
x = np.array([9.5, 11.2, 10.3, 11.5, 13.4, 12.9, 14.2]) #大きさ（cm） label = np.array([0, 0, 0, 0, 1, 1, 1]) #カテゴリ x = (x - x.mean()) / x.std() #標準化 plt.scatter(x, label, c=label) plt.xlabel(&amp;#34;x&amp;#34;) 
ロジスティック回帰  今回取り上げる手法は ロジスティック回帰 です． 「回帰」という文字列が含まれますが，実際は前回の線形判別分析と同様に 分類 を目的とした手法です． 確率モデルとして用いられる ロジスティック関数（シグモイド関数） に， 対象のデータを回帰させることから，その名前が付けられています．</description>
    </item>
    
    <item>
      <title>分類②・線形判別分析</title>
      <link>https://mukai-lab.info/pages/classes/intelligence_information_system/chapter8/</link>
      <pubDate>Thu, 27 Jun 2019 20:08:35 +0900</pubDate>
      
      <guid>https://mukai-lab.info/pages/classes/intelligence_information_system/chapter8/</guid>
      <description>ノートブックの作成  Colabにアクセスし，新規にノートブックを作成してください． ノートブックのタイトルは chapter8 とします． また，numpy，matplotlib.pyplot，scipy.optimize を導入しておいてください．
import numpy as np import matplotlib.pyplot as plt from scipy.optimize import minimize データの準備  前回と同じリンゴとメロンの 大きさ（$x_1$） と 重さ（$x_2$） を用います（未知のデータ$u$をリンゴとしてデータに追加）． 各要素はベクトル${\bf x} = (x_1,x_2)$として表すことに注意してください． ここでは，あらかじめデータを標準化しておきます．
[In:]
x1 = np.array([9.5, 11.2, 10.3, 11.5, 13.4, 12.9, 14.2]) #大きさ（cm） x2 = np.array([278, 298, 382, 443, 1221, 1305, 1512]) #重さ（g） label = np.array([&amp;#34;red&amp;#34;,&amp;#34;red&amp;#34;,&amp;#34;red&amp;#34;,&amp;#34;red&amp;#34;,&amp;#34;green&amp;#34;,&amp;#34;green&amp;#34;,&amp;#34;green&amp;#34;]) #カテゴリ x1 = (x1 - x1.mean()) / x1.std() x2 = (x2 - x2.mean()) / x2.</description>
    </item>
    
    <item>
      <title>分類①・決定境界とベクトル</title>
      <link>https://mukai-lab.info/pages/classes/intelligence_information_system/chapter7/</link>
      <pubDate>Wed, 26 Jun 2019 11:46:46 +0900</pubDate>
      
      <guid>https://mukai-lab.info/pages/classes/intelligence_information_system/chapter7/</guid>
      <description>ノートブックの作成  Colabにアクセスし，新規にノートブックを作成してください． ノートブックのタイトルは chapter7 とします． また，numpy，matplotlib.pyplot，scipy.optimize を導入しておいてください．
import numpy as np import matplotlib.pyplot as plt from scipy.optimize import minimize 分類  今回からは 分類 と呼ばれる問題にチャレンジします． これまでの 回帰 では，「アイスクリームの売上」や「インフルエンザの報告数」など連続値を予測対象としましたが， 分類では「リンゴ or メロン」や「Aさんの顔 or Bさんの顔」など離散値を予測対象とします． これら目標データとなる離散値を ラベル，カテゴリ ，または，クラス と呼びます．
ここでは，下記のデータを例に考えてみましょう． このデータはリンゴとメロンの 大きさ（$x_1$） と 重さ（$x_2$） を示しています． カテゴリは色で表現されており，red はリンゴ， green はメロンを表しています． 例えば，$x_1=9.5$，$x_2=278$ はリンゴであることを意味します．
x1 = np.array([9.5, 11.2, 10.3, 13.4, 12.9, 14.2]) #大きさ（cm） x2 = np.array([278, 298, 382, 1221, 1305, 1512]) #重さ（g） label = np.</description>
    </item>
    
    <item>
      <title>Tableauのマップ機能でGoogle Fitを可視化</title>
      <link>https://mukai-lab.info/pages/tech/tableau/tableau4/</link>
      <pubDate>Fri, 14 Jun 2019 18:06:47 +0900</pubDate>
      
      <guid>https://mukai-lab.info/pages/tech/tableau/tableau4/</guid>
      <description>Tableauのマップ機能  Tableauでは 緯度・経度 の情報を利用して，地図上にデータを可視化することが出来ます． 背景には，Tableauに組み込みの簡易的な地図に加え， Mapboxを利用して独自のスタイルの地図を設定することが可能です（MapboxはOpenStreetMapを採用しています）． ここでは，Google Fitに記録された活動データ（ tcx形式 ）を，Tableauで可視化することに挑戦してみます．
Google Fit  Google Fitは，Googleが開発している日々の活動を記録するためのアプリです． iOSや Androidのアプリとして提供されており，向は毎日の行動をこのアプリで記録しています． 記録されるデータは，緯度・経度などの情報を含む tcx形式 であり，自由に自身のデータを下記リンクからエクスポート（ダウンロード）することが可能です．
https://takeout.google.com/
tcx形式 は下記のように XML で記述されています． ここで， LatitudeDegrees が緯度， LongitudeDegrees は経度， AltitudeMeters は高度を表しています．
&amp;lt;Trackpoint&amp;gt; &amp;lt;DistanceMeters&amp;gt;209.93287658691406&amp;lt;/DistanceMeters&amp;gt; &amp;lt;Time&amp;gt;2019-02-01T11:12:16.277Z&amp;lt;/Time&amp;gt; &amp;lt;Position&amp;gt; &amp;lt;LatitudeDegrees&amp;gt;35.1597349&amp;lt;/LatitudeDegrees&amp;gt; &amp;lt;LongitudeDegrees&amp;gt;136.9893828&amp;lt;/LongitudeDegrees&amp;gt; &amp;lt;/Position&amp;gt; &amp;lt;AltitudeMeters&amp;gt;126.15887451171875&amp;lt;/AltitudeMeters&amp;gt; &amp;lt;/Trackpoint&amp;gt; &amp;lt;Trackpoint&amp;gt; &amp;lt;DistanceMeters&amp;gt;209.93287658691406&amp;lt;/DistanceMeters&amp;gt; &amp;lt;Time&amp;gt;2019-02-01T11:12:17.267Z&amp;lt;/Time&amp;gt; &amp;lt;Position&amp;gt; &amp;lt;LatitudeDegrees&amp;gt;35.1597831&amp;lt;/LatitudeDegrees&amp;gt; &amp;lt;LongitudeDegrees&amp;gt;136.9894012&amp;lt;/LongitudeDegrees&amp;gt; &amp;lt;/Position&amp;gt; &amp;lt;AltitudeMeters&amp;gt;126.45513916015625&amp;lt;/AltitudeMeters&amp;gt; &amp;lt;/Trackpoint&amp;gt; 残念ながら，Tableauでは，この tcx形式 をサポートしていないため， csv形式 に変換が必要です． 変換のための様々なツールがありますが，ここでは備忘録で提供されているツールを利用します． 開発者に感謝です． ここでは，CSVに変換後に，冗長なデータを取り除き，下記のデータを用いることにします．
Number,Longitude,Latitude,Altitude1,136.9665898,35.1939918,58.84051512,136.9665682,35.1939896,59.81506353,136.9665054,35.1939806,59.03094484,136.9664823,35.1939769,58.87731935,136.9664522,35.1939796,60.033026,136.9664263,35.193978,59.54827887,136.9663482,35.1939649,60.19464118,136.9662975,35.1939603,60.5572519,136.966274,35.1939573,59.788879410,136.</description>
    </item>
    
    <item>
      <title>Tableauのダッシュボードを活用しよう</title>
      <link>https://mukai-lab.info/pages/tech/tableau/tableau3/</link>
      <pubDate>Mon, 10 Jun 2019 16:57:29 +0900</pubDate>
      
      <guid>https://mukai-lab.info/pages/tech/tableau/tableau3/</guid>
      <description>ダッシュボードでプレゼン  Tableauの真骨頂と言える ダッシュボード は，ワークシートで作成したグラフを一箇所にまとめて閲覧できる機能です． グラフ間でフィルタの共有が可能であり，リッチでダイナミックな演出が可能です． データを基にした説得力のある プレゼン を行うには最適な機能です（プレゼンターのセンスが問われる機能でもあります）． 前回作成した「男女人口」「世帯数割合」「気温と降水量」「平均気温の推移」の４つのグラフを利用します．
フィルタ  フィルタ は，その名の通り，データを絞り込む機能のことです． 「ディメンション」と「メジャー」で絞り込むことが可能です． このとき，絞り込む対象のデータの性質（文字列，数値，日付など）に応じて自動的にフィルタの機能が変化します．
まずは，町別人口のグラフを開いてみましょう． グラフの右に「男」「女」と表示されている箇所（ カード と呼びます）がありませんか？ これが フィルタ です（このフィルタは自動で追加されました）． この場合は，ディメンジョンの メジャーネーム に含まれる「男」「女」で切り替えが可能です．


数値フィルタ それでは，新しくフィルタを作成してみましょう． メジャーの 総数 をフィルタに配置します． このとき，総数 は数値（連続値）であるため，範囲を定めるフィルタになります（351~9672の範囲を選択）． 配置したら 総数 を右クリックして，「フィルターを表示」を選びましょう． すると，グラフの右にフィルタが表示されます．


ここで，フィルタの値を2000~3000に変更すると， 該当する梅森台，折戸町，浅田平子，梅森町がピックアップされて表示されます．

最後に，このフィルタをダッシュボードでも利用するため， 再度，総数 を右クリックして， 適用先ワークシート の このデータソースを利用するすべてのアイテム を選択しておきましょう．
日付フィルタ 次は，「気温と降水量」のグラフを開きましょう． ここでは，ディメンジョン 年月 でフィルタを作成します． まずは，年月 を右クリックして， データ型の変更 の 日付 を選択します（事前にデータソースのCSVファイルの年月を西暦に変更する必要有）．

後は先程と同じ操作です． まず，年月 をフィルタに配置します． このとき，年月 は日付であるため，数値と同様に範囲を定めるフィルタになります（平成21年1月~平成29年12月）． 配置したら 年月 を右クリックして，「フィルターを表示」を選びましょう． すると，グラフの右にフィルタが表示されます．</description>
    </item>
    
    <item>
      <title>Tableauで色々なグラフを作成しよう</title>
      <link>https://mukai-lab.info/pages/tech/tableau/tableau2/</link>
      <pubDate>Sat, 08 Jun 2019 11:47:14 +0900</pubDate>
      
      <guid>https://mukai-lab.info/pages/tech/tableau/tableau2/</guid>
      <description>グラフの種類  前回は棒グラフを作成しましたが，Tableauでは様々な種類のグラフが利用できます． それぞれ適した用途があり，ケース・バイ・ケースで使い分けることが重要です．
 棒グラフ（量的データを並べて比較） 折れ線グラフ（時系列データの比較） 円グラフ（割合に関するデータの比較） 積み上げ棒グラフ（量的データの内訳も比較） 散布図（説明変数と非説明変数の関係） バブルチャート（3つの指標で比較） レーダーチャート（対象の特性を比較）  ここでは，使用頻度が高い 積み上げ棒グラフ，円グラフ，散布図，折れ線グラフ に注目し， オープンデータを利用してグラフを作成してみましょう．
積み上げ棒グラフ  まずは積み上げ棒グラフを作成しましょう． データソースは前回と同じ　町別人口・世帯数　を用いて， 男と女の人口を積み上げ棒グラフで表示します．
ここでは，メジャーネーム と メジャーバリュー を利用します． これらは，複数のディメンションやメジャーを，一つにまとめて扱うときに利用します． まずは，町名 を列， メジャーバリュー を行に設定します． このときの，棒グラフの高さは，$高さ=世帯数+男+女+総数+レコード数$を表しています．

次に，メジャーバリュー にフィルタを設定します． フィルタとは特定のメジャーのみを選択する機能のことです． ここでは，男 と 女 にチェックを入れます． これで，棒グラフの高さは，$高さ=男$と$高さ=女$となり，重なって表示されます．


最後に，メジャーネーム を色に設定することで，積み上げ縦棒グラフの完成です． ワークシート名や並び替えなどグラフの表現を整えていきましょう．
 ワークシート名を 男女人口 に変更 データを 降順 で並べ替え メジャーネームをデータラベルに設定  
円グラフ  次は円グラフを作成しましょう． データソースは，今回も 町別人口・世帯数 です． 地域毎の世帯数を棒グラフで表示します．
最初にワークシートを追加しておきます． 一つのワークシートに，一つのグラフを作成するのが基本であり， 複数のワークシートをまとめるには，ダッシュボード を利用します（次回に説明します）．</description>
    </item>
    
    <item>
      <title>Tableauでオープンデータを可視化</title>
      <link>https://mukai-lab.info/pages/tech/tableau/tableau/</link>
      <pubDate>Fri, 07 Jun 2019 17:16:17 +0900</pubDate>
      
      <guid>https://mukai-lab.info/pages/tech/tableau/tableau/</guid>
      <description>データサイエンティスト  データサイエンティスト という職業をご存知でしょうか． データサイエンティストとは，企業や組織での意思決定が必要な場面において，データに基づき合理的な判断を下す人を指します． データサイエンティストには，数学，統計学，情報科学，プログラミング など高度な知識が必要であり， 一部の専門家のみがその役割を担ってきました． 一方で，大量のデータを分析するためのソフトウェア，いわゆる「 BI(Business Intelligence)ツール 」が成熟・普及することで， 専門家ではなくともデータの可視化，データの集計・分析が容易となりました． BIツールには，Tableau， Qlik Sense， Actionista，などがありますが， ここでは，IT調査企業であるGartnerが， Learders（成熟したサービスを提供する製品・企業） に選出した Tableau を採用し， データの可視化にチャレンジしてみましょう．
Tableau  Tableau（日本語ではタブローと表記）とはどんなBIツールでしょうか． このBIツールは，アメリカに本社を置く Tableau Software が開発しており， 世界で42,000社以上，また，日本で2,000社以上の企業が利用していると言われています（2016年8月現在）． 本学にも導入される予定であり，教員・学生・事務職員によるIR（Institute Research）において活用される見込みです． PC向けのソフトウェアは Tableau Desktop という名称であり，一般には年間の利用料金が必要ですが， アカデミックプログラムが別途用意されており， 教員と学生は，なんと 無料 で利用可能です（14日間の無料トライアルもある）． 組織内のデータ分析はもちろん，将来のデータサイエンティストを育てるための学習ツールとしても最適と言えるでしょう．
ここで，他のBIツールと比較したTableauの特徴をまとめます．
 プログラミングが不要（ドラッグ&amp;amp;ドロップで操作） 様々なファイル形式（xlsx，csv，etc.），サーバー（MySQL, Googleスプレッドシート, etc.）に対応 可視化のパターンが豊富（ツリーマップ，パレート図，etc.）  一般に，高度なデータ分析には R， Python と呼ばれるプログラミング言語が用いられますが， Tableauではプログラミングの知識は一切不要です． また，組織で蓄積されているであろう Excel や CSV などのファイルはもちろん， データベース・サーバーにも接続可能です． さらに，分析結果を伝えるためには不可欠な データの可視化 にもTableauは優れています． 上記の特徴から，手元にあるデータを利用して，初学者が気軽に学び始めることが出来ます．
オープンデータ  早速，Tableauでデータ分析を始めたいところですが， まずは対象とするデータを用意しなくてはいけません． ここでは，自治体が公開しているオープンデータを利用してみましょう． オープンデータとは下記条件に従って公開されているデータを指しています．</description>
    </item>
    
    <item>
      <title>回帰③・基底関数</title>
      <link>https://mukai-lab.info/pages/classes/intelligence_information_system/chapter5/</link>
      <pubDate>Tue, 04 Jun 2019 10:16:04 +0900</pubDate>
      
      <guid>https://mukai-lab.info/pages/classes/intelligence_information_system/chapter5/</guid>
      <description>基底関数  これまでは回帰式として線形関数（一次式）を採用してきました．
$$f(x) = w_0 + w_1 x $$
しかし，下記のようなデータを対象とする場合は，直線ではなく曲線を用いた方が，傾向を正しく表現できそうです． このデータは，愛知県衛生研究所が公開しているインフルエンザの発症数です． 変数$x$は 経過週 ，変数$y$は インフルエンザの報告数（定点当たり） を表しています．
x = np.array([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20]) #週 y = np.array([0.26,0.25,0.19,0.34,0.89,1.78,2.51,4.81,10.97,18.02,19.28,32.42,62.12,62.18,62.60,49.18,32.57,25.93,21.17,14.68]) #報告数 
このような場合は，基底関数 を利用します． 線形関数の$x$を，任意の$\phi(x)$という基底関数に置き換えるという方法です． 基底関数には，どんな関数を用いても良いのですが，よく用いられるのは， 多項式基底 や ガウス基底 と呼ばれる関数です． 今回は，これら 基底関数 を利用した回帰について学びます．
ノートブックの作成  Colabにアクセスし，新規にノートブックを作成してください． ノートブックのタイトルは chapter5 とします． ここでは，numpy と matplotlib.pyplotに加え， 最適化処理のためのScipyをインポートします．
import numpy as np import matplotlib.</description>
    </item>
    
    <item>
      <title>回帰②・最急降下法</title>
      <link>https://mukai-lab.info/pages/classes/intelligence_information_system/chapter4/</link>
      <pubDate>Sun, 02 Jun 2019 17:07:40 +0900</pubDate>
      
      <guid>https://mukai-lab.info/pages/classes/intelligence_information_system/chapter4/</guid>
      <description>解析解と数値解  前回は2変数の関係性を表す 回帰式 と， その回帰式の当てはまり具合を評価するための 最小二乗法 について学びました． 回帰式の形を決める傾き $a$ と切片 $b$ の最適値は， numpy の polyfit 関数を利用して求めましたが，どのように最適値を求めているのでしょうか． 今回はその秘密に迫ってみたいと思います．
回帰式のパラメータ（$a$と$b$のこと）を求める方法には２通りあり， 方程式を解くことによって得られる厳密な解を 解析解， 繰り返しの計算によって得られる近似的な解を 数値解 と呼びます． 特定の処理を繰り返すことが得意なコンピュータでは， 後者の 数値解 を求める方法が良く用いられます． ここでは，数値解を求めるための最もシンプルな方法である 最急降下法（Gradient Descent Method） について学びます．
ノートブックの作成  Colabにアクセスし，新規にノートブックを作成してください． ノートブックのタイトルは chapter4 とします． 前回と同様に，numpy と matplotlib.pyplot を導入します．
import numpy as np import matplotlib.pyplot as plt 最急降下法  最急降下法は，目的関数（2乗誤差）の傾き（勾配）を求め， 誤差が小さくなる方向へパラメータを更新するという手法です． 理解するためには 微分 が必要となりますが， 決して難しい計算ではないため，焦らず落ち着いて考えていきましょう．
データ 対象とするデータは前回と同じ，気温 と アイスクリーム のデータを用います． いずれも，numpyのndarray型でリストを作成しておきます．
x = np.array([12, 20, 13, 24, 28, 30, 31, 24, 18, 33]) # 気温 y = np.</description>
    </item>
    
    <item>
      <title>回帰①・線形回帰</title>
      <link>https://mukai-lab.info/pages/classes/intelligence_information_system/chapter3/</link>
      <pubDate>Fri, 31 May 2019 09:37:19 +0900</pubDate>
      
      <guid>https://mukai-lab.info/pages/classes/intelligence_information_system/chapter3/</guid>
      <description>機械学習の分類  機械学習は大別して３種類あるとされています．
 教師あり学習（Supervised Learning） 教師なし学習（Unsupervised Learning） 強化学習（Reinforcement Learning）  教師あり学習 は，未知のデータに対する分類や予測などの問題において， 過去のデータに対して正解（教師）が事前に与えられている学習方法です． 過去のデータの正解が分かっているため，未知のデータに対しては， 過去のデータとの類似性を基に判断することになります． 例えば，特定の顔写真をデータとして学習させると， 未知の写真に対して，一致するかどうかを判定できるようになります．
教師なし学習 は，正解（教師）が事前に与えられない学習方法です（もしくは明確な正解が存在しない）． よって，分類や予想ではなく，データに潜む傾向や特徴を抽出する目的で用いられます． データマイニングと呼ばれる研究分野にも関係が深いです． 例えば，POS（Point of Sales）データなどから， 商品売上の傾向（「おむつとビール」が有名）を明らかにすることが出来ます．
強化学習 は，ロボット（エージェント）が，環境や経験からの情報を基に， 最適な行動ルールを獲得するための学習方法です． 一般には，マルコフ決定過程（Marcov Decision Process）というプロセスに従って学習は進行します． 例えば，自動運転自動車が，他の車両や歩行者を回避するための運転操作を， 自動的に獲得することができます．
ノートブックの作成  Colabにアクセスし，新規にノートブックを作成してください． ノートブックのタイトルは chapter3 とします． グラフを作成するために，Matplotlibといライブラリを用います． ライブラリを導入するには import matplotlib as pltとします． ここで，as plt は，ライブラリのエイリアス（別名）として， plt を用いることを意味しています（省略も可能です）．
import matplotlib.pyplot as plt 同様に，高度な算術計算をサポートするnumpy というライブラリを用います． ここでは，import numpy as npでライブラリを導入し， np というエイリアス（別名）をつけています．
import numpy as np 回帰  今回は，教師あり学習に分類される回帰 に焦点を当てます． 回帰分析 とは，2変数（もしくはそれ以上）の関係性を 数式 で表すという手法です． 例えば，過去の「気温」と「アイスクリームの売上」のデータを基に， それらの関係性を表す数式を導き，将来の売上を予測することができます．</description>
    </item>
    
    <item>
      <title>Pythonの基本</title>
      <link>https://mukai-lab.info/pages/classes/intelligence_information_system/chapter2/</link>
      <pubDate>Wed, 29 May 2019 12:51:03 +0900</pubDate>
      
      <guid>https://mukai-lab.info/pages/classes/intelligence_information_system/chapter2/</guid>
      <description>Pythonとは  Python はオランダ出身のプログラマーGuido Van Rossum氏が1991年に開発したプログラミング言語です． C言語やJavaに比べ，文法がシンプルであり，高い可読性を持っています． 例えば，多くのプログラミング言語では，コードの固まり（ブロック）を {}（中括弧） で表現することが多くあります． 一方，Pythonでは， 字下げ（インデント） を利用して，ブロックを表現します． また，本授業でテーマとなっている機械学習など，豊富なライブラリが利用可能であり， パッケージ管理ツール（pipやcondaなど）を利用して，手軽に導入可能という特徴もあります． コーディング，実行 ，デバッグ という一連のプロセスも簡単であり， 手を動かしながら学ぶには最適なプログラミング言語と言えるでしょう． 今回は，強化学習を学ぶ前準備として，Python の基本的な文法について学びます．
ノートブックの作成  Colabにアクセスし，新規にノートブックを作成してください． ノートブックのタイトルは chapter2 とします．

四則演算  一般的な四則演算が利用可能です． セルに加算（+），減算（-），乗算（*），除算（/），剰余（%），累乗（**）を入力して，結果を確認してみましょう． 乗算・除算などは，我々が通常用いている$\times$や$\div$などの演算子とは異なることに注意してください．
   演算 演算子 例     加算 + 3 + 2 -&amp;gt; 5   減算 - 3 - 2 -&amp;gt; 1   乗算 * 3 * 2 -&amp;gt; 6   除算 / 3 / 2 -&amp;gt; 1.</description>
    </item>
    
    <item>
      <title>機械学習とは</title>
      <link>https://mukai-lab.info/pages/classes/intelligence_information_system/chapter1/</link>
      <pubDate>Sat, 18 May 2019 14:57:09 +0900</pubDate>
      
      <guid>https://mukai-lab.info/pages/classes/intelligence_information_system/chapter1/</guid>
      <description>機械学習とは  この授業では， 機械学習 の理論と実践を学びます． 機械学習は「データから規則性やルールを抽出する」ための手法の総称です． 近年，注目される人工知能の基礎技術として知られる ディープラーニング も機械学習の一つです． その応用範囲は幅広く，顔検出，手書き文字の認識，商品の推薦，株価の予測などに用いられています．
例えば，Facebookでは，機械学習を用いて自動的に顔を検出し，個人を識別する仕組みが導入されていることが，よく知られています． 下記のように画像をアップロードするだけで，過去の画像データから，個人を認識しラベリングがなされます．

この他にも，画像を特徴付ける単語をリストアップするClarifai， 存在しない人の顔写真を生成するThis Person does Not Exist， 音楽を自動生成するAmper Musicなど，数多くのサービスが生み出されています．
機械学習の多くは，確率分布など統計的な手法が用いられており， 数学の知識がないと理解できないことも多く，初学者にはハードルが高い分野です． 一方で，Python や R などのプログラミング言語では， 機械学習のためのライブラリが充実しており，機械学習を実装するための環境は整っています． そこで，本授業では，Python の実装が容易なGoogle Colaboratoryを活用し， 理論だけを学ぶのではなく，アルゴリズムの実装までを経験することで，機械学習を実践的に活用できるようになることを目標とします．
Jupyter Notebookのインストール（Anaconda）  Pythonの実装に用いるJupyter Notebookは， Pythonのディストリビューションである[Anaconda](https://www.anaconda.com/)にバンドルされています． そこで，Anacondaのインストーラをダウンロードし，PCにインストールしましょう． インストーラは **Python 3.x Version** の **64-Bit Graphical Installer** を選択し，ダウンロードしてください． インストールを始める前に，ファイルをインストールするためのフォルダを作成します． **Hドライブ** に， **MyAnaconda** という名前でフォルダを作成してください（本学のPC環境では個人のファイルはHドライブに保存する）． それでは，インストーラを実行しましょう． 環境によっては，インストールにかなりの時間を要しますので注意してください（本学の環境だと１時間弱かかるかも）． インストールするフォルダは，上記で作成した **H:\Anaconda** とします（3.1GBとかなり大きな容量です）． [![Image from Gyazo](https://i.gyazo.com/0b097b4957a7e49d31f049ba8d861dde.png)](https://gyazo.com/0b097b4957a7e49d31f049ba8d861dde) 次に，オプションを設定するダイアログ（Adcanved Installation Options）では， ２箇所のチェックボックスがありますが，いずれもチェックを外してください． ちなみに，上は「インストールしたAnacondaのパスの環境変数への追加」， 下は「同時にインストールされるPythonの他のアプリでの利用」の設定です． [![Image from Gyazo](https://i.</description>
    </item>
    
    <item>
      <title>知能情報システム</title>
      <link>https://mukai-lab.info/pages/classes/intelligence_information_system/</link>
      <pubDate>Sat, 18 May 2019 12:38:55 +0900</pubDate>
      
      <guid>https://mukai-lab.info/pages/classes/intelligence_information_system/</guid>
      <description>授業科目区分： 専門教育科目
単位数: 2単位
開講学科: 文化情報学科
学年: 3年次
関連科目: 人工知能
授業テーマ: 機械学習の理解と実装
授業内容 人工知能の基礎となる機械学習を学び，実践的な問題に適用するための応用力を身に付ける． 機械学習はデータから法則や傾向を抽出するための手法であり，ディープラーニングと呼ばれる画像認識技術も機械学習の一つである. 機械学習の実装には，多様なライブラリが利用可能なPython（Jupyter Notebook）を採用する．
授業計画  機械学習とは Pythonの基本 回帰①・線形回帰 回帰②・最急降下法 回帰③・基底関数 回帰④・リッジ回帰とラッソ回帰 分類①・決定境界とベクトル 分類②・線形判別分析 分類③・ロジスティック回帰 分類④・k近傍法 分類⑤・決定木 クラスタリング①・K平均法 クラスタリング②・混合ガウスモデル Kaggle①・タイタニック号の生存予測 Kaggle②・コンペに挑戦しよう！  追加資料  オーバーフィッティングと交差検証  参考書籍     </description>
    </item>
    
    <item>
      <title>ダイガクモン</title>
      <link>https://mukai-lab.info/posts/2019-05-17-comic_135/</link>
      <pubDate>Fri, 17 May 2019 17:11:03 +0900</pubDate>
      
      <guid>https://mukai-lab.info/posts/2019-05-17-comic_135/</guid>
      <description></description>
    </item>
    
    <item>
      <title>20周年記念パーティと教員</title>
      <link>https://mukai-lab.info/posts/2019-05-17-comic_134/</link>
      <pubDate>Fri, 17 May 2019 16:03:14 +0900</pubDate>
      
      <guid>https://mukai-lab.info/posts/2019-05-17-comic_134/</guid>
      <description></description>
    </item>
    
    <item>
      <title>20周年記念パーティの価値</title>
      <link>https://mukai-lab.info/posts/2019-05-16-comic_133/</link>
      <pubDate>Thu, 16 May 2019 18:10:52 +0900</pubDate>
      
      <guid>https://mukai-lab.info/posts/2019-05-16-comic_133/</guid>
      <description></description>
    </item>
    
    <item>
      <title>MacでEmacs</title>
      <link>https://mukai-lab.info/pages/tech/emacs/emacs/</link>
      <pubDate>Wed, 15 May 2019 19:50:00 +0900</pubDate>
      
      <guid>https://mukai-lab.info/pages/tech/emacs/emacs/</guid>
      <description>Atomへの乗り換えを検討しましたが，やっぱりEmacsが便利なことも多いです．そこで，MacでEmacsを利用する上で，必要最低限な設定をメモしておきます．
インストール Macにインストール可能なEmacsは複数あるが，railwaycat氏のemacs-macがしっくりくる． インストール方法は，この計算物理屋の研究備忘録を参考にした（Mojabe10.14.4の環境では，なぜかcask版は実行できなかった）．
% brew tap railwaycat/emacsmacport % brew install emacs-mac パッケージのインストール Emacsのパッケージをインストールするには，Melpaのレポジトリを登録しておく．.emacs.elに下記のように記述する（もうLispなんて忘れたわい）．
(add-to-list &amp;#39;package-archives &amp;#39;(&amp;#34;melpa-stable&amp;#34; . &amp;#34;https://stable.melpa.org/packages/&amp;#34;) t) その後で，M-x package-list-packagesをして，パッケージを選択すればOK．
emacs-neotree emacs-neotree Atomのようにファイルやフォルダをツリーで表示する． C-tでツリーの表示・非表示を切り替える．
(global-set-key &amp;#34;\C-t&amp;#34; &amp;#39;neotree-toggle) markdonw-mode マークダウン・ファイルのハイライトに用いる．
yatex Texのハイライトなど．
テーマの設定 テーマをtango-dark に設定．
(load-theme &amp;#39;tango-dark t) キーバインディングの設定 Ctr-u でUndo．
(global-set-key &amp;#34;\C-u&amp;#34; &amp;#39;undo) Meta-/ でComment．
(global-set-key &amp;#34;\M-/&amp;#34; &amp;#39;comment-line) キーバインディングの競合の解消 デフォルトのキーバインディングでは， set-mark-command にC-SPC が割り当てられていますが，マック標準のキーバインディングと競合しており動作しません． この場合，【システム環境設定】→【キーボード】→【ショートカット】→【入力ソース】で，チェックを外すと解消されます．</description>
    </item>
    
    <item>
      <title>20周年記念パーティ</title>
      <link>https://mukai-lab.info/posts/2019-05-15-comic_132/</link>
      <pubDate>Wed, 15 May 2019 13:01:17 +0900</pubDate>
      
      <guid>https://mukai-lab.info/posts/2019-05-15-comic_132/</guid>
      <description></description>
    </item>
    
    <item>
      <title>時は金なり</title>
      <link>https://mukai-lab.info/posts/2019-05-12-comic_131/</link>
      <pubDate>Sun, 12 May 2019 15:21:48 +0900</pubDate>
      
      <guid>https://mukai-lab.info/posts/2019-05-12-comic_131/</guid>
      <description></description>
    </item>
    
    <item>
      <title>Atomに必須のプラグイン紹介</title>
      <link>https://mukai-lab.info/pages/tech/atom/atom_plugin/</link>
      <pubDate>Sat, 11 May 2019 13:42:38 +0900</pubDate>
      
      <guid>https://mukai-lab.info/pages/tech/atom/atom_plugin/</guid>
      <description>GitHubが開発するオープンソスのエディタがAtomです． 様々なプラットフォームがサポートされており，WindowsやMacなどの異なる環境でも，同じ操作感覚で利用が可能です． これまで，Windows環境下では Atom，Mac環境下では emacs を採用していたのですが， キーボード・ショートカットなどの違いにウンザリして， Atom に統一することにしました． そこで，今回は，Atom を日常的にエディタとして利用するために必須のプラグインをご紹介したいと思います．
japanese-menu メニューバーやコンテキストメニューを日本語化してくれるプラグインがJapanese Menuです． 日本人であれば取り敢えず入れておいて損はないでしょう．
atomic-emacs キーボード・バインディングをemacs風に変更してくれるプラグインがAtomic Emacsです． emacsに慣れている人には必須のプラグインです． これを入れないなら素直にemacsを使います． killing &amp;amp; Yanking (コピー &amp;amp; ペースト)のバインディングも覚えておきましょう．
Ctrl + k (Kill Line) Ctrl + w (Kill Region) Ctrl + y (Yank Line) その他，よく利用するキー・バインディングです．
Ctrl + SPACE (Set Mark) Ctrl + / (Undo) Alt + ; (Toggle Comment) Alt + x (Command Palette) project-manager 複数のプロジェクトを切り替えながら作業するときに便利なプラグインがProject Managerです． プロジェクトのリストを表示するキー・バインディングは覚えておきましょう．
Alt + Shift + p (List Projects) markdown-writer 忘れがちなマークダウン記法の入力を強力にサポートしてれるプラグインがMarkdown-Writer for Atomです． 残念ながら，キーバインディングが，emacsと重複していることも多く，全ての機能をフルに活用するのは難しいのですが， チートシート（CHEATSHEET） だけでも何気に有り難いです．</description>
    </item>
    
    <item>
      <title>sedでJekyllからHugoに変換</title>
      <link>https://mukai-lab.info/pages/tech/hugo/2019-05-07-hugo_sed/</link>
      <pubDate>Tue, 07 May 2019 13:11:49 +0900</pubDate>
      
      <guid>https://mukai-lab.info/pages/tech/hugo/2019-05-07-hugo_sed/</guid>
      <description>JekyllからHugoに移行する際に，用いたsedワンライナーを記録しておきます． Hugoにはマークダウンの変換用のスクリプトが付属していますが，細かな修正はどうしても必要になります． sed を用いると効率的にテキストの置換が可能です． また，下記コマンドを実行すると結果は標準出力に流れますが， -i -e オプションを付けることでファイルを上書きします．
H1要素を独自のショートコード（title-logo）に置換 % sed &amp;#34;s/^# .*&amp;gt;\(.*\)/\{\{&amp;lt; title-logo title=\&amp;#34;\1\&amp;#34; &amp;gt;\}\}/g&amp;#34; FILE JekyllのLiquid構文をショートコード（gist）に置換 % sed &amp;#34;s/^{% gist \(.*\)\/\(.*\)%}/ /g&amp;#34; FILE インデントを削除 % sed &amp;#34;s/^ \(.*\)/\1/g&amp;#34; FILE </description>
    </item>
    
    <item>
      <title>仲良し親子</title>
      <link>https://mukai-lab.info/2019/03/22/comic_130/</link>
      <pubDate>Fri, 22 Mar 2019 04:10:07 +0000</pubDate>
      
      <guid>https://mukai-lab.info/2019/03/22/comic_130/</guid>
      <description></description>
    </item>
    
    <item>
      <title>hitoe</title>
      <link>https://mukai-lab.info/2018/10/04/comic_129/</link>
      <pubDate>Thu, 04 Oct 2018 08:43:40 +0000</pubDate>
      
      <guid>https://mukai-lab.info/2018/10/04/comic_129/</guid>
      <description></description>
    </item>
    
    <item>
      <title>郷土愛</title>
      <link>https://mukai-lab.info/2018/08/10/comic_128/</link>
      <pubDate>Fri, 10 Aug 2018 07:42:23 +0000</pubDate>
      
      <guid>https://mukai-lab.info/2018/08/10/comic_128/</guid>
      <description></description>
    </item>
    
    <item>
      <title>画伯クイズ</title>
      <link>https://mukai-lab.info/2018/07/06/comic_127/</link>
      <pubDate>Fri, 06 Jul 2018 10:54:30 +0000</pubDate>
      
      <guid>https://mukai-lab.info/2018/07/06/comic_127/</guid>
      <description></description>
    </item>
    
    <item>
      <title>こころ有り無し</title>
      <link>https://mukai-lab.info/2018/07/01/comic_126/</link>
      <pubDate>Sun, 01 Jul 2018 07:53:18 +0000</pubDate>
      
      <guid>https://mukai-lab.info/2018/07/01/comic_126/</guid>
      <description></description>
    </item>
    
    <item>
      <title>兼務</title>
      <link>https://mukai-lab.info/2018/03/07/comic_125/</link>
      <pubDate>Wed, 07 Mar 2018 06:57:38 +0000</pubDate>
      
      <guid>https://mukai-lab.info/2018/03/07/comic_125/</guid>
      <description></description>
    </item>
    
    <item>
      <title>拡散力</title>
      <link>https://mukai-lab.info/2018/02/28/comic_124/</link>
      <pubDate>Wed, 28 Feb 2018 03:47:28 +0000</pubDate>
      
      <guid>https://mukai-lab.info/2018/02/28/comic_124/</guid>
      <description></description>
    </item>
    
    <item>
      <title>ITの黒船</title>
      <link>https://mukai-lab.info/2018/02/28/comic_123/</link>
      <pubDate>Wed, 28 Feb 2018 03:18:30 +0000</pubDate>
      
      <guid>https://mukai-lab.info/2018/02/28/comic_123/</guid>
      <description></description>
    </item>
    
    <item>
      <title>鎖国</title>
      <link>https://mukai-lab.info/2018/02/27/comic_122/</link>
      <pubDate>Tue, 27 Feb 2018 10:55:29 +0000</pubDate>
      
      <guid>https://mukai-lab.info/2018/02/27/comic_122/</guid>
      <description></description>
    </item>
    
    <item>
      <title>なおとちゃん</title>
      <link>https://mukai-lab.info/2018/02/27/comic_121/</link>
      <pubDate>Tue, 27 Feb 2018 09:31:18 +0000</pubDate>
      
      <guid>https://mukai-lab.info/2018/02/27/comic_121/</guid>
      <description></description>
    </item>
    
    <item>
      <title>手を繋ごう</title>
      <link>https://mukai-lab.info/2018/02/22/comic_120/</link>
      <pubDate>Thu, 22 Feb 2018 07:13:33 +0000</pubDate>
      
      <guid>https://mukai-lab.info/2018/02/22/comic_120/</guid>
      <description></description>
    </item>
    
    <item>
      <title>クイックレスポンス</title>
      <link>https://mukai-lab.info/2018/02/22/comic_119/</link>
      <pubDate>Thu, 22 Feb 2018 06:30:31 +0000</pubDate>
      
      <guid>https://mukai-lab.info/2018/02/22/comic_119/</guid>
      <description></description>
    </item>
    
    <item>
      <title>世代交代</title>
      <link>https://mukai-lab.info/2018/02/22/comic_118/</link>
      <pubDate>Thu, 22 Feb 2018 05:38:31 +0000</pubDate>
      
      <guid>https://mukai-lab.info/2018/02/22/comic_118/</guid>
      <description></description>
    </item>
    
    <item>
      <title>Code for Nagoya あるある</title>
      <link>https://mukai-lab.info/2018/02/21/comic-117/</link>
      <pubDate>Wed, 21 Feb 2018 10:59:06 +0000</pubDate>
      
      <guid>https://mukai-lab.info/2018/02/21/comic-117/</guid>
      <description></description>
    </item>
    
    <item>
      <title>入試監督あるある</title>
      <link>https://mukai-lab.info/2018/02/21/comic-116/</link>
      <pubDate>Wed, 21 Feb 2018 10:14:55 +0000</pubDate>
      
      <guid>https://mukai-lab.info/2018/02/21/comic-116/</guid>
      <description></description>
    </item>
    
    <item>
      <title>グループウェア</title>
      <link>https://mukai-lab.info/2018/02/21/comic-115/</link>
      <pubDate>Wed, 21 Feb 2018 09:40:17 +0000</pubDate>
      
      <guid>https://mukai-lab.info/2018/02/21/comic-115/</guid>
      <description></description>
    </item>
    
    <item>
      <title>お供え物</title>
      <link>https://mukai-lab.info/2018/02/21/comic-114/</link>
      <pubDate>Wed, 21 Feb 2018 08:47:12 +0000</pubDate>
      
      <guid>https://mukai-lab.info/2018/02/21/comic-114/</guid>
      <description></description>
    </item>
    
    <item>
      <title>ミッチーロス</title>
      <link>https://mukai-lab.info/2018/02/20/comic_113/</link>
      <pubDate>Tue, 20 Feb 2018 11:34:53 +0000</pubDate>
      
      <guid>https://mukai-lab.info/2018/02/20/comic_113/</guid>
      <description></description>
    </item>
    
    <item>
      <title>友人挨拶</title>
      <link>https://mukai-lab.info/2018/02/20/comic_112/</link>
      <pubDate>Tue, 20 Feb 2018 11:00:25 +0000</pubDate>
      
      <guid>https://mukai-lab.info/2018/02/20/comic_112/</guid>
      <description></description>
    </item>
    
    <item>
      <title>ミッチーの嫁</title>
      <link>https://mukai-lab.info/2018/02/20/comic_111/</link>
      <pubDate>Tue, 20 Feb 2018 10:19:48 +0000</pubDate>
      
      <guid>https://mukai-lab.info/2018/02/20/comic_111/</guid>
      <description></description>
    </item>
    
    <item>
      <title>弱点を狙え</title>
      <link>https://mukai-lab.info/2017/09/15/comic_110/</link>
      <pubDate>Fri, 15 Sep 2017 02:10:34 +0000</pubDate>
      
      <guid>https://mukai-lab.info/2017/09/15/comic_110/</guid>
      <description></description>
    </item>
    
    <item>
      <title>加減を知れ</title>
      <link>https://mukai-lab.info/2017/09/14/comic_109/</link>
      <pubDate>Thu, 14 Sep 2017 11:25:10 +0000</pubDate>
      
      <guid>https://mukai-lab.info/2017/09/14/comic_109/</guid>
      <description></description>
    </item>
    
    <item>
      <title>深まる絆</title>
      <link>https://mukai-lab.info/2017/09/14/comic_108/</link>
      <pubDate>Thu, 14 Sep 2017 09:37:55 +0000</pubDate>
      
      <guid>https://mukai-lab.info/2017/09/14/comic_108/</guid>
      <description></description>
    </item>
    
    <item>
      <title>新しい絆</title>
      <link>https://mukai-lab.info/2017/08/24/comic_107/</link>
      <pubDate>Thu, 24 Aug 2017 10:33:52 +0000</pubDate>
      
      <guid>https://mukai-lab.info/2017/08/24/comic_107/</guid>
      <description></description>
    </item>
    
    <item>
      <title>切りたい症候群</title>
      <link>https://mukai-lab.info/2017/08/23/comic_106/</link>
      <pubDate>Wed, 23 Aug 2017 10:53:22 +0000</pubDate>
      
      <guid>https://mukai-lab.info/2017/08/23/comic_106/</guid>
      <description></description>
    </item>
    
    <item>
      <title>非常勤だけど嬉しいかも</title>
      <link>https://mukai-lab.info/2017/08/23/comic_105/</link>
      <pubDate>Wed, 23 Aug 2017 08:32:59 +0000</pubDate>
      
      <guid>https://mukai-lab.info/2017/08/23/comic_105/</guid>
      <description></description>
    </item>
    
    <item>
      <title>大学院の価値</title>
      <link>https://mukai-lab.info/2017/08/23/comic_104/</link>
      <pubDate>Wed, 23 Aug 2017 07:46:49 +0000</pubDate>
      
      <guid>https://mukai-lab.info/2017/08/23/comic_104/</guid>
      <description></description>
    </item>
    
    <item>
      <title>サマソニ</title>
      <link>https://mukai-lab.info/2017/08/23/comic_103/</link>
      <pubDate>Wed, 23 Aug 2017 05:40:30 +0000</pubDate>
      
      <guid>https://mukai-lab.info/2017/08/23/comic_103/</guid>
      <description></description>
    </item>
    
    <item>
      <title>ブレスト</title>
      <link>https://mukai-lab.info/2017/08/10/comic_102/</link>
      <pubDate>Thu, 10 Aug 2017 03:35:11 +0000</pubDate>
      
      <guid>https://mukai-lab.info/2017/08/10/comic_102/</guid>
      <description></description>
    </item>
    
    <item>
      <title>へりくつ</title>
      <link>https://mukai-lab.info/2017/08/09/comic_101/</link>
      <pubDate>Wed, 09 Aug 2017 10:31:24 +0000</pubDate>
      
      <guid>https://mukai-lab.info/2017/08/09/comic_101/</guid>
      <description></description>
    </item>
    
    <item>
      <title>時給 （第100話）</title>
      <link>https://mukai-lab.info/2017/07/31/comic_100/</link>
      <pubDate>Mon, 31 Jul 2017 03:54:56 +0000</pubDate>
      
      <guid>https://mukai-lab.info/2017/07/31/comic_100/</guid>
      <description></description>
    </item>
    
    <item>
      <title>求人って難しい</title>
      <link>https://mukai-lab.info/2017/07/30/comic_099/</link>
      <pubDate>Sun, 30 Jul 2017 10:42:05 +0000</pubDate>
      
      <guid>https://mukai-lab.info/2017/07/30/comic_099/</guid>
      <description></description>
    </item>
    
    <item>
      <title>羽虫の雨</title>
      <link>https://mukai-lab.info/2017/07/30/comic_098/</link>
      <pubDate>Sun, 30 Jul 2017 09:44:34 +0000</pubDate>
      
      <guid>https://mukai-lab.info/2017/07/30/comic_098/</guid>
      <description></description>
    </item>
    
    <item>
      <title>デジャヴ</title>
      <link>https://mukai-lab.info/2017/07/10/comic_097/</link>
      <pubDate>Mon, 10 Jul 2017 10:24:14 +0000</pubDate>
      
      <guid>https://mukai-lab.info/2017/07/10/comic_097/</guid>
      <description></description>
    </item>
    
    <item>
      <title>来場者</title>
      <link>https://mukai-lab.info/2017/07/10/comic_096/</link>
      <pubDate>Mon, 10 Jul 2017 09:48:37 +0000</pubDate>
      
      <guid>https://mukai-lab.info/2017/07/10/comic_096/</guid>
      <description></description>
    </item>
    
    <item>
      <title>心を金で</title>
      <link>https://mukai-lab.info/2017/07/05/comic_095/</link>
      <pubDate>Wed, 05 Jul 2017 12:13:54 +0000</pubDate>
      
      <guid>https://mukai-lab.info/2017/07/05/comic_095/</guid>
      <description></description>
    </item>
    
    <item>
      <title>プレゼミ</title>
      <link>https://mukai-lab.info/2017/07/03/comic_094/</link>
      <pubDate>Mon, 03 Jul 2017 11:02:20 +0000</pubDate>
      
      <guid>https://mukai-lab.info/2017/07/03/comic_094/</guid>
      <description></description>
    </item>
    
    <item>
      <title>美女と野獣</title>
      <link>https://mukai-lab.info/2017/07/03/comic_093/</link>
      <pubDate>Mon, 03 Jul 2017 10:21:46 +0000</pubDate>
      
      <guid>https://mukai-lab.info/2017/07/03/comic_093/</guid>
      <description></description>
    </item>
    
    <item>
      <title>Ag</title>
      <link>https://mukai-lab.info/2017/06/05/comic_092/</link>
      <pubDate>Mon, 05 Jun 2017 05:41:42 +0000</pubDate>
      
      <guid>https://mukai-lab.info/2017/06/05/comic_092/</guid>
      <description></description>
    </item>
    
    <item>
      <title>THETA</title>
      <link>https://mukai-lab.info/2017/05/30/comic_091/</link>
      <pubDate>Tue, 30 May 2017 11:43:39 +0000</pubDate>
      
      <guid>https://mukai-lab.info/2017/05/30/comic_091/</guid>
      <description></description>
    </item>
    
    <item>
      <title>主キー</title>
      <link>https://mukai-lab.info/2017/05/30/comic_090/</link>
      <pubDate>Tue, 30 May 2017 11:13:41 +0000</pubDate>
      
      <guid>https://mukai-lab.info/2017/05/30/comic_090/</guid>
      <description></description>
    </item>
    
    <item>
      <title>for文</title>
      <link>https://mukai-lab.info/2017/05/30/comic_089/</link>
      <pubDate>Tue, 30 May 2017 10:59:05 +0000</pubDate>
      
      <guid>https://mukai-lab.info/2017/05/30/comic_089/</guid>
      <description></description>
    </item>
    
    <item>
      <title>バリエーション</title>
      <link>https://mukai-lab.info/2017/05/25/comic_088/</link>
      <pubDate>Thu, 25 May 2017 09:15:38 +0000</pubDate>
      
      <guid>https://mukai-lab.info/2017/05/25/comic_088/</guid>
      <description></description>
    </item>
    
    <item>
      <title>THETA S</title>
      <link>https://mukai-lab.info/2017/05/25/comic_087/</link>
      <pubDate>Thu, 25 May 2017 07:58:17 +0000</pubDate>
      
      <guid>https://mukai-lab.info/2017/05/25/comic_087/</guid>
      <description></description>
    </item>
    
    <item>
      <title>ラテンの血</title>
      <link>https://mukai-lab.info/2017/05/11/comic_086/</link>
      <pubDate>Thu, 11 May 2017 02:43:38 +0000</pubDate>
      
      <guid>https://mukai-lab.info/2017/05/11/comic_086/</guid>
      <description></description>
    </item>
    
    <item>
      <title>名鉄瀬戸線</title>
      <link>https://mukai-lab.info/2017/05/10/comic_085/</link>
      <pubDate>Wed, 10 May 2017 03:09:57 +0000</pubDate>
      
      <guid>https://mukai-lab.info/2017/05/10/comic_085/</guid>
      <description></description>
    </item>
    
    <item>
      <title>誰だっけ</title>
      <link>https://mukai-lab.info/2017/04/27/comic_084/</link>
      <pubDate>Thu, 27 Apr 2017 09:08:01 +0000</pubDate>
      
      <guid>https://mukai-lab.info/2017/04/27/comic_084/</guid>
      <description></description>
    </item>
    
    <item>
      <title>あめりかってとこ</title>
      <link>https://mukai-lab.info/2017/04/24/comic_083/</link>
      <pubDate>Mon, 24 Apr 2017 08:09:38 +0000</pubDate>
      
      <guid>https://mukai-lab.info/2017/04/24/comic_083/</guid>
      <description></description>
    </item>
    
    <item>
      <title>一番いい席</title>
      <link>https://mukai-lab.info/2017/03/17/comic_082/</link>
      <pubDate>Fri, 17 Mar 2017 10:36:08 +0000</pubDate>
      
      <guid>https://mukai-lab.info/2017/03/17/comic_082/</guid>
      <description></description>
    </item>
    
    <item>
      <title>幼稚園システム</title>
      <link>https://mukai-lab.info/2017/03/17/comic_081/</link>
      <pubDate>Fri, 17 Mar 2017 03:37:38 +0000</pubDate>
      
      <guid>https://mukai-lab.info/2017/03/17/comic_081/</guid>
      <description></description>
    </item>
    
    <item>
      <title>トヨ先生を囲む会</title>
      <link>https://mukai-lab.info/2017/03/09/comic_080/</link>
      <pubDate>Thu, 09 Mar 2017 08:40:58 +0000</pubDate>
      
      <guid>https://mukai-lab.info/2017/03/09/comic_080/</guid>
      <description></description>
    </item>
    
    <item>
      <title>ベッド購入</title>
      <link>https://mukai-lab.info/2017/03/03/comic_079/</link>
      <pubDate>Fri, 03 Mar 2017 09:24:04 +0000</pubDate>
      
      <guid>https://mukai-lab.info/2017/03/03/comic_079/</guid>
      <description></description>
    </item>
    
    <item>
      <title>IR</title>
      <link>https://mukai-lab.info/2017/02/17/comic_078/</link>
      <pubDate>Fri, 17 Feb 2017 02:33:30 +0000</pubDate>
      
      <guid>https://mukai-lab.info/2017/02/17/comic_078/</guid>
      <description></description>
    </item>
    
    <item>
      <title>FD</title>
      <link>https://mukai-lab.info/2017/02/17/comic_077/</link>
      <pubDate>Fri, 17 Feb 2017 02:33:26 +0000</pubDate>
      
      <guid>https://mukai-lab.info/2017/02/17/comic_077/</guid>
      <description></description>
    </item>
    
    <item>
      <title>わいわいさん</title>
      <link>https://mukai-lab.info/2017/02/16/comic_074/</link>
      <pubDate>Thu, 16 Feb 2017 08:30:41 +0000</pubDate>
      
      <guid>https://mukai-lab.info/2017/02/16/comic_074/</guid>
      <description></description>
    </item>
    
    <item>
      <title>はよいえ</title>
      <link>https://mukai-lab.info/2017/02/15/comic_076/</link>
      <pubDate>Wed, 15 Feb 2017 10:24:48 +0000</pubDate>
      
      <guid>https://mukai-lab.info/2017/02/15/comic_076/</guid>
      <description></description>
    </item>
    
    <item>
      <title>僕らのバレンタイン</title>
      <link>https://mukai-lab.info/2017/02/15/comic_075/</link>
      <pubDate>Wed, 15 Feb 2017 09:49:00 +0000</pubDate>
      
      <guid>https://mukai-lab.info/2017/02/15/comic_075/</guid>
      <description></description>
    </item>
    
    <item>
      <title>帰りはヨイヨイ</title>
      <link>https://mukai-lab.info/2017/02/13/comic_073/</link>
      <pubDate>Mon, 13 Feb 2017 08:27:30 +0000</pubDate>
      
      <guid>https://mukai-lab.info/2017/02/13/comic_073/</guid>
      <description></description>
    </item>
    
    <item>
      <title>解熱</title>
      <link>https://mukai-lab.info/2017/02/06/comic_072/</link>
      <pubDate>Mon, 06 Feb 2017 08:25:50 +0000</pubDate>
      
      <guid>https://mukai-lab.info/2017/02/06/comic_072/</guid>
      <description></description>
    </item>
    
    <item>
      <title>女子大のバレンタイン</title>
      <link>https://mukai-lab.info/2017/02/04/comic_071/</link>
      <pubDate>Sat, 04 Feb 2017 07:12:47 +0000</pubDate>
      
      <guid>https://mukai-lab.info/2017/02/04/comic_071/</guid>
      <description></description>
    </item>
    
    <item>
      <title>販売促進</title>
      <link>https://mukai-lab.info/2017/02/04/comic_070/</link>
      <pubDate>Sat, 04 Feb 2017 06:42:06 +0000</pubDate>
      
      <guid>https://mukai-lab.info/2017/02/04/comic_070/</guid>
      <description></description>
    </item>
    
    <item>
      <title>アイドル</title>
      <link>https://mukai-lab.info/2017/02/03/comit_069/</link>
      <pubDate>Fri, 03 Feb 2017 08:55:21 +0000</pubDate>
      
      <guid>https://mukai-lab.info/2017/02/03/comit_069/</guid>
      <description></description>
    </item>
    
    <item>
      <title>福はどこ</title>
      <link>https://mukai-lab.info/2017/02/03/comit_068/</link>
      <pubDate>Fri, 03 Feb 2017 08:18:37 +0000</pubDate>
      
      <guid>https://mukai-lab.info/2017/02/03/comit_068/</guid>
      <description></description>
    </item>
    
    <item>
      <title>口癖</title>
      <link>https://mukai-lab.info/2016/12/16/comic_067/</link>
      <pubDate>Fri, 16 Dec 2016 10:21:06 +0000</pubDate>
      
      <guid>https://mukai-lab.info/2016/12/16/comic_067/</guid>
      <description></description>
    </item>
    
    <item>
      <title>少数精鋭 vs. 多数精鋭</title>
      <link>https://mukai-lab.info/2016/12/13/comic_066/</link>
      <pubDate>Tue, 13 Dec 2016 03:27:05 +0000</pubDate>
      
      <guid>https://mukai-lab.info/2016/12/13/comic_066/</guid>
      <description></description>
    </item>
    
    <item>
      <title>卒アル</title>
      <link>https://mukai-lab.info/2016/11/03/comic_065/</link>
      <pubDate>Thu, 03 Nov 2016 09:23:57 +0000</pubDate>
      
      <guid>https://mukai-lab.info/2016/11/03/comic_065/</guid>
      <description></description>
    </item>
    
    <item>
      <title>学部長の秘密</title>
      <link>https://mukai-lab.info/2016/10/21/comic_064/</link>
      <pubDate>Fri, 21 Oct 2016 10:08:52 +0000</pubDate>
      
      <guid>https://mukai-lab.info/2016/10/21/comic_064/</guid>
      <description></description>
    </item>
    
    <item>
      <title>自動販売機の気まぐれ</title>
      <link>https://mukai-lab.info/2016/10/18/comic_063/</link>
      <pubDate>Tue, 18 Oct 2016 09:06:34 +0000</pubDate>
      
      <guid>https://mukai-lab.info/2016/10/18/comic_063/</guid>
      <description></description>
    </item>
    
    <item>
      <title>運動会の敵</title>
      <link>https://mukai-lab.info/2016/10/18/comic_062/</link>
      <pubDate>Tue, 18 Oct 2016 08:27:16 +0000</pubDate>
      
      <guid>https://mukai-lab.info/2016/10/18/comic_062/</guid>
      <description></description>
    </item>
    
    <item>
      <title>父の運動会</title>
      <link>https://mukai-lab.info/2016/10/18/comic_061/</link>
      <pubDate>Tue, 18 Oct 2016 07:57:52 +0000</pubDate>
      
      <guid>https://mukai-lab.info/2016/10/18/comic_061/</guid>
      <description></description>
    </item>
    
    <item>
      <title>AR算数</title>
      <link>https://mukai-lab.info/2016/09/03/comic_060/</link>
      <pubDate>Sat, 03 Sep 2016 09:24:48 +0000</pubDate>
      
      <guid>https://mukai-lab.info/2016/09/03/comic_060/</guid>
      <description></description>
    </item>
    
    <item>
      <title>ミッチー先生の誕生日</title>
      <link>https://mukai-lab.info/2016/09/03/comic_059/</link>
      <pubDate>Sat, 03 Sep 2016 08:32:41 +0000</pubDate>
      
      <guid>https://mukai-lab.info/2016/09/03/comic_059/</guid>
      <description></description>
    </item>
    
    <item>
      <title>レアキャラ</title>
      <link>https://mukai-lab.info/2016/08/13/comic_058/</link>
      <pubDate>Sat, 13 Aug 2016 05:21:49 +0000</pubDate>
      
      <guid>https://mukai-lab.info/2016/08/13/comic_058/</guid>
      <description></description>
    </item>
    
    <item>
      <title>素質発見</title>
      <link>https://mukai-lab.info/2016/08/12/comic_057/</link>
      <pubDate>Fri, 12 Aug 2016 09:17:19 +0000</pubDate>
      
      <guid>https://mukai-lab.info/2016/08/12/comic_057/</guid>
      <description></description>
    </item>
    
    <item>
      <title>オーキャンのターゲット</title>
      <link>https://mukai-lab.info/2016/08/12/comic_056/</link>
      <pubDate>Fri, 12 Aug 2016 07:53:44 +0000</pubDate>
      
      <guid>https://mukai-lab.info/2016/08/12/comic_056/</guid>
      <description></description>
    </item>
    
    <item>
      <title>オープンキャンパス GO</title>
      <link>https://mukai-lab.info/2016/08/12/comic_055/</link>
      <pubDate>Fri, 12 Aug 2016 07:14:34 +0000</pubDate>
      
      <guid>https://mukai-lab.info/2016/08/12/comic_055/</guid>
      <description></description>
    </item>
    
    <item>
      <title>UFOキャッチャー</title>
      <link>https://mukai-lab.info/2016/08/05/comic_054/</link>
      <pubDate>Fri, 05 Aug 2016 05:31:50 +0000</pubDate>
      
      <guid>https://mukai-lab.info/2016/08/05/comic_054/</guid>
      <description></description>
    </item>
    
    <item>
      <title>通勤路</title>
      <link>https://mukai-lab.info/2016/08/05/comic_053/</link>
      <pubDate>Fri, 05 Aug 2016 04:16:19 +0000</pubDate>
      
      <guid>https://mukai-lab.info/2016/08/05/comic_053/</guid>
      <description></description>
    </item>
    
    <item>
      <title>進化</title>
      <link>https://mukai-lab.info/2016/07/30/comic_052/</link>
      <pubDate>Sat, 30 Jul 2016 04:27:50 +0000</pubDate>
      
      <guid>https://mukai-lab.info/2016/07/30/comic_052/</guid>
      <description></description>
    </item>
    
    <item>
      <title>ゴース</title>
      <link>https://mukai-lab.info/2016/07/30/comic_051/</link>
      <pubDate>Sat, 30 Jul 2016 03:43:29 +0000</pubDate>
      
      <guid>https://mukai-lab.info/2016/07/30/comic_051/</guid>
      <description></description>
    </item>
    
    <item>
      <title>ミシンの形</title>
      <link>https://mukai-lab.info/2016/07/29/comic_050/</link>
      <pubDate>Fri, 29 Jul 2016 06:27:35 +0000</pubDate>
      
      <guid>https://mukai-lab.info/2016/07/29/comic_050/</guid>
      <description></description>
    </item>
    
    <item>
      <title>堀田駅集合</title>
      <link>https://mukai-lab.info/2016/07/29/comic_049/</link>
      <pubDate>Fri, 29 Jul 2016 05:05:19 +0000</pubDate>
      
      <guid>https://mukai-lab.info/2016/07/29/comic_049/</guid>
      <description></description>
    </item>
    
    <item>
      <title>コイキング</title>
      <link>https://mukai-lab.info/2016/07/29/comic_048/</link>
      <pubDate>Fri, 29 Jul 2016 04:20:44 +0000</pubDate>
      
      <guid>https://mukai-lab.info/2016/07/29/comic_048/</guid>
      <description></description>
    </item>
    
    <item>
      <title>ポケストップ</title>
      <link>https://mukai-lab.info/2016/07/27/comic_047/</link>
      <pubDate>Wed, 27 Jul 2016 05:16:44 +0000</pubDate>
      
      <guid>https://mukai-lab.info/2016/07/27/comic_047/</guid>
      <description></description>
    </item>
    
    <item>
      <title>アイスショー</title>
      <link>https://mukai-lab.info/2016/07/26/comic_046/</link>
      <pubDate>Tue, 26 Jul 2016 09:13:10 +0000</pubDate>
      
      <guid>https://mukai-lab.info/2016/07/26/comic_046/</guid>
      <description></description>
    </item>
    
    <item>
      <title>名誉学生</title>
      <link>https://mukai-lab.info/2016/07/11/comic_045/</link>
      <pubDate>Mon, 11 Jul 2016 06:49:05 +0000</pubDate>
      
      <guid>https://mukai-lab.info/2016/07/11/comic_045/</guid>
      <description></description>
    </item>
    
    <item>
      <title>キネクトの機能</title>
      <link>https://mukai-lab.info/2016/07/11/comic_044/</link>
      <pubDate>Mon, 11 Jul 2016 05:29:48 +0000</pubDate>
      
      <guid>https://mukai-lab.info/2016/07/11/comic_044/</guid>
      <description></description>
    </item>
    
    <item>
      <title>断り上手</title>
      <link>https://mukai-lab.info/2016/07/11/comic_043/</link>
      <pubDate>Mon, 11 Jul 2016 04:46:17 +0000</pubDate>
      
      <guid>https://mukai-lab.info/2016/07/11/comic_043/</guid>
      <description></description>
    </item>
    
    <item>
      <title>既視感</title>
      <link>https://mukai-lab.info/2016/07/07/comic_042/</link>
      <pubDate>Thu, 07 Jul 2016 04:19:11 +0000</pubDate>
      
      <guid>https://mukai-lab.info/2016/07/07/comic_042/</guid>
      <description></description>
    </item>
    
    <item>
      <title>なじみのお店</title>
      <link>https://mukai-lab.info/2016/07/06/comic_041/</link>
      <pubDate>Wed, 06 Jul 2016 04:07:31 +0000</pubDate>
      
      <guid>https://mukai-lab.info/2016/07/06/comic_041/</guid>
      <description></description>
    </item>
    
    <item>
      <title>片道希望</title>
      <link>https://mukai-lab.info/2016/07/04/comic_040/</link>
      <pubDate>Mon, 04 Jul 2016 06:23:25 +0000</pubDate>
      
      <guid>https://mukai-lab.info/2016/07/04/comic_040/</guid>
      <description></description>
    </item>
    
    <item>
      <title>匿名希望</title>
      <link>https://mukai-lab.info/2016/07/01/comic_039/</link>
      <pubDate>Fri, 01 Jul 2016 02:48:23 +0000</pubDate>
      
      <guid>https://mukai-lab.info/2016/07/01/comic_039/</guid>
      <description></description>
    </item>
    
    <item>
      <title>男の仕事</title>
      <link>https://mukai-lab.info/2016/06/30/comic_038/</link>
      <pubDate>Thu, 30 Jun 2016 10:52:23 +0000</pubDate>
      
      <guid>https://mukai-lab.info/2016/06/30/comic_038/</guid>
      <description></description>
    </item>
    
    <item>
      <title>女の子だもん</title>
      <link>https://mukai-lab.info/2016/06/30/comic_037/</link>
      <pubDate>Thu, 30 Jun 2016 09:09:02 +0000</pubDate>
      
      <guid>https://mukai-lab.info/2016/06/30/comic_037/</guid>
      <description></description>
    </item>
    
    <item>
      <title>あのときの・・</title>
      <link>https://mukai-lab.info/2016/06/29/comic_036/</link>
      <pubDate>Wed, 29 Jun 2016 04:08:29 +0000</pubDate>
      
      <guid>https://mukai-lab.info/2016/06/29/comic_036/</guid>
      <description></description>
    </item>
    
    <item>
      <title>おまえは・・</title>
      <link>https://mukai-lab.info/2016/06/29/comic_035/</link>
      <pubDate>Wed, 29 Jun 2016 04:07:33 +0000</pubDate>
      
      <guid>https://mukai-lab.info/2016/06/29/comic_035/</guid>
      <description></description>
    </item>
    
    <item>
      <title>ブドウいかが</title>
      <link>https://mukai-lab.info/2016/06/27/comic_034/</link>
      <pubDate>Mon, 27 Jun 2016 09:58:46 +0000</pubDate>
      
      <guid>https://mukai-lab.info/2016/06/27/comic_034/</guid>
      <description></description>
    </item>
    
    <item>
      <title>購入手続き</title>
      <link>https://mukai-lab.info/2016/06/24/comic_033/</link>
      <pubDate>Fri, 24 Jun 2016 04:25:10 +0000</pubDate>
      
      <guid>https://mukai-lab.info/2016/06/24/comic_033/</guid>
      <description></description>
    </item>
    
    <item>
      <title>しっかりもの</title>
      <link>https://mukai-lab.info/2016/06/23/comic_032/</link>
      <pubDate>Thu, 23 Jun 2016 11:00:36 +0000</pubDate>
      
      <guid>https://mukai-lab.info/2016/06/23/comic_032/</guid>
      <description></description>
    </item>
    
    <item>
      <title>お願いだから休んで</title>
      <link>https://mukai-lab.info/2016/06/21/comic_031/</link>
      <pubDate>Tue, 21 Jun 2016 06:33:22 +0000</pubDate>
      
      <guid>https://mukai-lab.info/2016/06/21/comic_031/</guid>
      <description></description>
    </item>
    
    <item>
      <title>イマドキ勇者</title>
      <link>https://mukai-lab.info/2016/06/21/comic_030/</link>
      <pubDate>Tue, 21 Jun 2016 05:36:46 +0000</pubDate>
      
      <guid>https://mukai-lab.info/2016/06/21/comic_030/</guid>
      <description></description>
    </item>
    
    <item>
      <title>それぞれの戦い方</title>
      <link>https://mukai-lab.info/2016/06/17/comic_029/</link>
      <pubDate>Fri, 17 Jun 2016 05:47:37 +0000</pubDate>
      
      <guid>https://mukai-lab.info/2016/06/17/comic_029/</guid>
      <description></description>
    </item>
    
    <item>
      <title>スギヤマクエスト</title>
      <link>https://mukai-lab.info/2016/06/17/comic_028/</link>
      <pubDate>Fri, 17 Jun 2016 05:10:13 +0000</pubDate>
      
      <guid>https://mukai-lab.info/2016/06/17/comic_028/</guid>
      <description></description>
    </item>
    
    <item>
      <title>下克上</title>
      <link>https://mukai-lab.info/2016/06/17/comic_027/</link>
      <pubDate>Fri, 17 Jun 2016 04:13:05 +0000</pubDate>
      
      <guid>https://mukai-lab.info/2016/06/17/comic_027/</guid>
      <description></description>
    </item>
    
    <item>
      <title>金沢人気</title>
      <link>https://mukai-lab.info/2016/06/13/comic_026/</link>
      <pubDate>Mon, 13 Jun 2016 06:47:28 +0000</pubDate>
      
      <guid>https://mukai-lab.info/2016/06/13/comic_026/</guid>
      <description></description>
    </item>
    
    <item>
      <title>テニス部</title>
      <link>https://mukai-lab.info/2016/06/13/comic_025/</link>
      <pubDate>Mon, 13 Jun 2016 05:46:16 +0000</pubDate>
      
      <guid>https://mukai-lab.info/2016/06/13/comic_025/</guid>
      <description></description>
    </item>
    
    <item>
      <title>金沢弁</title>
      <link>https://mukai-lab.info/2016/06/13/comic_024/</link>
      <pubDate>Mon, 13 Jun 2016 05:05:14 +0000</pubDate>
      
      <guid>https://mukai-lab.info/2016/06/13/comic_024/</guid>
      <description></description>
    </item>
    
    <item>
      <title>おだいちゃん</title>
      <link>https://mukai-lab.info/2016/06/10/comic_023/</link>
      <pubDate>Fri, 10 Jun 2016 03:13:15 +0000</pubDate>
      
      <guid>https://mukai-lab.info/2016/06/10/comic_023/</guid>
      <description></description>
    </item>
    
    <item>
      <title>事務室アイドル 解決編</title>
      <link>https://mukai-lab.info/2016/06/01/comic_022/</link>
      <pubDate>Wed, 01 Jun 2016 03:51:12 +0000</pubDate>
      
      <guid>https://mukai-lab.info/2016/06/01/comic_022/</guid>
      <description></description>
    </item>
    
    <item>
      <title>事務室アイドル その後</title>
      <link>https://mukai-lab.info/2016/06/01/comic_021/</link>
      <pubDate>Wed, 01 Jun 2016 02:51:40 +0000</pubDate>
      
      <guid>https://mukai-lab.info/2016/06/01/comic_021/</guid>
      <description></description>
    </item>
    
    <item>
      <title>事務室アイドル</title>
      <link>https://mukai-lab.info/2016/05/27/comic_020/</link>
      <pubDate>Fri, 27 May 2016 11:26:47 +0000</pubDate>
      
      <guid>https://mukai-lab.info/2016/05/27/comic_020/</guid>
      <description></description>
    </item>
    
    <item>
      <title>視力検査</title>
      <link>https://mukai-lab.info/2016/05/27/comic_019/</link>
      <pubDate>Fri, 27 May 2016 05:52:33 +0000</pubDate>
      
      <guid>https://mukai-lab.info/2016/05/27/comic_019/</guid>
      <description></description>
    </item>
    
    <item>
      <title>ほれてまうやろ</title>
      <link>https://mukai-lab.info/2016/05/13/comic_018/</link>
      <pubDate>Fri, 13 May 2016 02:19:02 +0000</pubDate>
      
      <guid>https://mukai-lab.info/2016/05/13/comic_018/</guid>
      <description></description>
    </item>
    
    <item>
      <title>タフマン</title>
      <link>https://mukai-lab.info/2016/05/12/comic_017/</link>
      <pubDate>Thu, 12 May 2016 09:26:59 +0000</pubDate>
      
      <guid>https://mukai-lab.info/2016/05/12/comic_017/</guid>
      <description></description>
    </item>
    
    <item>
      <title>グッチ先輩登場</title>
      <link>https://mukai-lab.info/2016/05/11/comic_016/</link>
      <pubDate>Wed, 11 May 2016 02:49:51 +0000</pubDate>
      
      <guid>https://mukai-lab.info/2016/05/11/comic_016/</guid>
      <description></description>
    </item>
    
    <item>
      <title>女の子になるなんて</title>
      <link>https://mukai-lab.info/2016/05/07/comic_015/</link>
      <pubDate>Sat, 07 May 2016 07:27:07 +0000</pubDate>
      
      <guid>https://mukai-lab.info/2016/05/07/comic_015/</guid>
      <description></description>
    </item>
    
    <item>
      <title>男には分からないよね</title>
      <link>https://mukai-lab.info/2016/05/07/comic_014/</link>
      <pubDate>Sat, 07 May 2016 05:32:50 +0000</pubDate>
      
      <guid>https://mukai-lab.info/2016/05/07/comic_014/</guid>
      <description></description>
    </item>
    
    <item>
      <title>不可能という文字はある</title>
      <link>https://mukai-lab.info/2016/05/02/comic_013/</link>
      <pubDate>Mon, 02 May 2016 11:26:22 +0000</pubDate>
      
      <guid>https://mukai-lab.info/2016/05/02/comic_013/</guid>
      <description></description>
    </item>
    
    <item>
      <title>うわさ話</title>
      <link>https://mukai-lab.info/2016/04/29/comic_012/</link>
      <pubDate>Fri, 29 Apr 2016 08:25:24 +0000</pubDate>
      
      <guid>https://mukai-lab.info/2016/04/29/comic_012/</guid>
      <description></description>
    </item>
    
    <item>
      <title>近そうで遠い</title>
      <link>https://mukai-lab.info/2016/04/28/comic_011/</link>
      <pubDate>Thu, 28 Apr 2016 03:57:23 +0000</pubDate>
      
      <guid>https://mukai-lab.info/2016/04/28/comic_011/</guid>
      <description></description>
    </item>
    
    <item>
      <title>幕の内弁当</title>
      <link>https://mukai-lab.info/2016/04/20/comic_010/</link>
      <pubDate>Wed, 20 Apr 2016 03:31:50 +0000</pubDate>
      
      <guid>https://mukai-lab.info/2016/04/20/comic_010/</guid>
      <description></description>
    </item>
    
    <item>
      <title>文情においでよ</title>
      <link>https://mukai-lab.info/2016/04/19/comic_009/</link>
      <pubDate>Tue, 19 Apr 2016 11:47:18 +0000</pubDate>
      
      <guid>https://mukai-lab.info/2016/04/19/comic_009/</guid>
      <description></description>
    </item>
    
    <item>
      <title>桜舞い散る季節</title>
      <link>https://mukai-lab.info/2016/04/18/comic_008/</link>
      <pubDate>Mon, 18 Apr 2016 09:40:22 +0000</pubDate>
      
      <guid>https://mukai-lab.info/2016/04/18/comic_008/</guid>
      <description></description>
    </item>
    
    <item>
      <title>ボイトレ</title>
      <link>https://mukai-lab.info/2016/04/16/comic_007/</link>
      <pubDate>Sat, 16 Apr 2016 05:03:23 +0000</pubDate>
      
      <guid>https://mukai-lab.info/2016/04/16/comic_007/</guid>
      <description></description>
    </item>
    
    <item>
      <title>女子大着任！ミッチー先生</title>
      <link>https://mukai-lab.info/2016/03/26/comic_006/</link>
      <pubDate>Sat, 26 Mar 2016 04:36:49 +0000</pubDate>
      
      <guid>https://mukai-lab.info/2016/03/26/comic_006/</guid>
      <description></description>
    </item>
    
    <item>
      <title>先生ですけども</title>
      <link>https://mukai-lab.info/2016/03/23/comic_005/</link>
      <pubDate>Wed, 23 Mar 2016 04:10:10 +0000</pubDate>
      
      <guid>https://mukai-lab.info/2016/03/23/comic_005/</guid>
      <description></description>
    </item>
    
    <item>
      <title>女子大着任！ムカイ先生</title>
      <link>https://mukai-lab.info/2016/03/22/comic_004/</link>
      <pubDate>Tue, 22 Mar 2016 11:21:01 +0000</pubDate>
      
      <guid>https://mukai-lab.info/2016/03/22/comic_004/</guid>
      <description></description>
    </item>
    
    <item>
      <title>抽選は１回だけ</title>
      <link>https://mukai-lab.info/2016/03/21/comic_003/</link>
      <pubDate>Mon, 21 Mar 2016 07:20:25 +0000</pubDate>
      
      <guid>https://mukai-lab.info/2016/03/21/comic_003/</guid>
      <description></description>
    </item>
    
    <item>
      <title>単位認定制度は神様！？</title>
      <link>https://mukai-lab.info/2016/03/21/comic_002/</link>
      <pubDate>Mon, 21 Mar 2016 06:38:59 +0000</pubDate>
      
      <guid>https://mukai-lab.info/2016/03/21/comic_002/</guid>
      <description></description>
    </item>
    
    <item>
      <title>履修登録規制のきょうふ</title>
      <link>https://mukai-lab.info/2016/03/18/comic_001/</link>
      <pubDate>Fri, 18 Mar 2016 07:59:14 +0000</pubDate>
      
      <guid>https://mukai-lab.info/2016/03/18/comic_001/</guid>
      <description></description>
    </item>
    
    <item>
      <title>Java 8における「Access Restriction」の回避</title>
      <link>https://mukai-lab.info/pages/tech/java/2016-02-25-javafx/</link>
      <pubDate>Thu, 25 Feb 2016 06:18:31 +0000</pubDate>
      
      <guid>https://mukai-lab.info/pages/tech/java/2016-02-25-javafx/</guid>
      <description>Eclipse環境でJavaFX（javafxパッケージ）をインポートしようとすると， 「Access Restriction」エラーとなってしまいコンパイルできません． JavaFXはJava 8では標準のGUIライブラリとして統合されたはずなのに， なんでだー となったので回避方法を調べてみました．
Eclipseのツールバーから[ウィンドウ]-[設定]-[Java]-[コンパイラー]-[エラー/警告]を選択します． ここで下記のように「使用すべきではない制限されたAPI」の「禁止された参照」を 無視 に設定します． これで問題なくインポートできるはずです．</description>
    </item>
    
    <item>
      <title>Jekyllでオープン・グラフ・プロトコル（OGP）の設定</title>
      <link>https://mukai-lab.info/pages/tech/jekyll/2016-02-23-ogp/</link>
      <pubDate>Tue, 23 Feb 2016 00:27:33 +0000</pubDate>
      
      <guid>https://mukai-lab.info/pages/tech/jekyll/2016-02-23-ogp/</guid>
      <description>フェイスブックでシェアされたときに表示される画像は，オープン・グラフ・プロトコル（OGP）で制御されています． OGPの設定がなければ，自動で適当な画像が選択されますが，意図しない画像が選択されることも多いです． そこで，Jekyllで採用されている「YAML Front Matter」を利用してOGPを設定する方法をメモしておきます．
まずは，ブログ記事などのファイルの先頭に， 下記のようにimageという変数を用意して，参照する画像を設定しておきます．
--- layout: default image: &amp;#34;https://i.gyazo.com/cdf2b2e7be4e80421f55152a4b348a7a.png&amp;#34; --- これで page.image という記述で設定された値を取得することができるようになります． 次に，&amp;quot;_includes/head.html&amp;quot;に下記のように page.image を利用してOGPの設定をします． このとき，条件文を利用することで page.image が設定されている場合に限ってOGPの設定を有効にしています． OGPは&amp;lt;meta property=&amp;quot;og:image&amp;quot; content=&amp;quot;参照画像&amp;quot;&amp;gt;と記述します．
 これで，フェイスブックでシェアされたときの画像が設定されます． もし画像が反映されない場合は，フェイスブックのキャッシュが原因かもしれません． この場合は，Open Graph Object Debuggerでキャッシュを削除してみましょう．</description>
    </item>
    
    <item>
      <title>Git Bashのホームディレクトリの変更</title>
      <link>https://mukai-lab.info/pages/tech/github/2016-02-17-git-bash/</link>
      <pubDate>Wed, 17 Feb 2016 02:34:43 +0000</pubDate>
      
      <guid>https://mukai-lab.info/pages/tech/github/2016-02-17-git-bash/</guid>
      <description>WindowsでGit環境を構築するとお世話になるであろう Git Bash のホームディレクトリの変更に関してメモします． GitHubのレポジトリはZ:\GitHubに設置しているため，このZ:\GitHubをホームディレクトリに設定することを目指します．
まずは，WindowsとはいえBash であることに変わりはないので，C:\Users\Naoto.bashrcを作成して，環境変数$HOMEの設定を変更してみます．
HOME=/z/GitHub/ これで問題解決と思いきや，Git Bash を実行してみると下記のように，起動時のディレクトリは/c/Users/Naotoのままです． ちなみに，環境変数$HOME自体は設定されていて，cdコマンドを実行すると/z/GitHub/に移動します．

そこで，アプローチを変更して， Git Bash のショートカットアイコンのプロパティを変更してみます． プロパティには 作業フォルダ という項目があり，ここにZ:\GitHub設定します． また，リンク先には &amp;ndash;cd-to-home という引数が設定されているので削除しておきます．

これでGit Bashのショートカットアイコンから起動してみると， 下記のように無事にホームディレクトリを変更することができました．</description>
    </item>
    
    <item>
      <title>Liquidを利用したファイルの埋め込み</title>
      <link>https://mukai-lab.info/2016/02/10/include/</link>
      <pubDate>Wed, 10 Feb 2016 08:45:44 +0000</pubDate>
      
      <guid>https://mukai-lab.info/2016/02/10/include/</guid>
      <description>JekyllではテンプレートエンジンとしてLiquidを採用しています． このLiquidでは タグ や フィルタ という機能を利用して， ウェブページ制作における無駄を減らすすことが可能です．
ここでは，複数のページに共通で利用されるコードの断片を他のファイルから読み込んで埋め込む方法を紹介します． 埋め込むコードを common.html として作成し， _includes ディレクトリに配置します． 後はMDファイルやHTMLファイルに下記のように記述するだけです．
 その他，Gistで公開しているソースコードも下記の方法で公開可能です．
 ただし，jekyll-gistを事前にインストールし， さらに，_config.yml に下記の設定を加えておく必要があるようです． この _config.yml の設定は忘れがちになるので特に注意が必要です．
 </description>
    </item>
    
    <item>
      <title>Github Pagesでの独自ドメインの設定</title>
      <link>https://mukai-lab.info/pages/tech/github/2016-02-08-domain/</link>
      <pubDate>Mon, 08 Feb 2016 09:13:03 +0000</pubDate>
      
      <guid>https://mukai-lab.info/pages/tech/github/2016-02-08-domain/</guid>
      <description>ブログを立ち上げたので独自ドメインを取得してみることにしました． ドメインはお名前.comで，トップレベルドメインには「.info」を選択しました． １年間の契約でなんと「269円（手数料込）」！ メジャーなトップレベルドメインではないとはいえ，この安さに驚きました（普段，ドメイン取得することないからなぁ）．
さて，ホスティングしているGithub Pagesを独自ドメインで公開する方法ですが， 様々なサイトで詳しく情報が公開されており，検索すれば容易に発見できると思います． 他と重複する情報とはなりますが，念のためメモしておきたいと思います．
まずは，お名前.comの設定ですが， ドメインNaviでGithub PagesのDNSレコードの登録が必要です． 具体的には，下記のようにAレコードとして，192.30.252.153と192.30.252.154を登録するだけです． （参考：Github Help）

次に，自身のレポジトリの設定ですが， CNAME という名前をファイルを作成し， 転送先の独自ドメイン（ここでは muka-lab.info ）を入力します． 後は，このファイルを他のHTMLファイルなどと一緒にデプロイするだけです． これらの変更の適用には時間がかかるようなので， 少し時間を空けてから転送が成功するか確認しましょう．</description>
    </item>
    
    <item>
      <title>Jekyllにおけるシンタックスハイライト</title>
      <link>https://mukai-lab.info/pages/tech/jekyll/2016-02-05-highlight/</link>
      <pubDate>Fri, 05 Feb 2016 02:58:35 +0000</pubDate>
      
      <guid>https://mukai-lab.info/pages/tech/jekyll/2016-02-05-highlight/</guid>
      <description>Jekyllが得意とするシンタックスハイライトですが，設定でつまずいたのでメモしておきます． シンタックスハイライトにはrougeやpygmentsが利用されるようですが，ここではrougeを適用してみたいと思います． まずは，下記のコマンドでrougeをインストールします．
gem install rouge 次に，&amp;quot;_config.yml&amp;quot;でシンタックスハイライトにrougeを指定しておきます．
highlighter: rouge ここまでは，何てことないのですが，ここからつまずきました． シンタックスハイライトのスタイルは&amp;rdquo;_syntax-highlighting.scss&amp;quot;で設定されているようです． 色などを変更したい場合は，このファイルを修正すれば良いはずですが，何故か変更が適用されません．
マークダウンでハイライトするときは，ソースコードを``で囲みます． 変換後のhtmlを確認すると，該当箇所は下記のように，クラス属性にhighlighter-rougeが設定されています．
&amp;lt;code class=&amp;#34;highlighter-rouge&amp;#34;&amp;gt;&amp;lt;/code&amp;gt; 再度，&amp;quot;_syntax-highlighting.scss&amp;quot;を確認すると，クラス属性はhighlightとして設定されています． そこで，ファイル内のクラス属性をhighlighter-rougeに置換することで，シンタックスハイライトが適用されました． 試行錯誤の末，シンタックスハイライトの適用までこぎつけましたが，この辺り十分に理解できていないかもしれません．</description>
    </item>
    
    <item>
      <title>Jekyllデフォルトテンプレートの自動リンク</title>
      <link>https://mukai-lab.info/pages/tech/jekyll/2016-02-04-top_link/</link>
      <pubDate>Thu, 04 Feb 2016 09:26:26 +0000</pubDate>
      
      <guid>https://mukai-lab.info/pages/tech/jekyll/2016-02-04-top_link/</guid>
      <description>Jekyllのデフォルトテンプレートでは， トップページのヘッダ部の右にサイトに含まれるページのリンクを自動的に追加してくれます． これはとても便利な機能ではあるのですが，ページ数が増えてくると，特定のページは除いて欲しいというケースが発生します．
そこで，YAML Front Matterを利用して解決します． まずは，&amp;quot;_templates/page&amp;quot;に，top_linkという名前の変数を下記のように用意します． これで，新規に作成するページには，top_linkの行が自動的に追加されます．
 トップページに自動的にリンクを追加する場合は，ページを作成した後で，このtop_linkの値を&amp;quot;true&amp;quot;に設定しておきましょう． 次に，&amp;quot;_includes/header.html&amp;quot;に下記のようにtop_linkに関する条件文を追加します．
 これで，トップページの自動リンクをtop_linkという変数で制御できるようになります．</description>
    </item>
    
    <item>
      <title>2項分布</title>
      <link>https://mukai-lab.info/pages/classes/advanced_studies_seminar_2/chapter6/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://mukai-lab.info/pages/classes/advanced_studies_seminar_2/chapter6/</guid>
      <description>2項分布 -- 2項分布  2項分布とは，結果が2通り（例，成功・失敗）となる試行を複数回行ったときの確率分布です． 例えば，「コインを投げる」という試行の結果は，表，または，裏のどちらかになります． 他にも，「サイコロを投げる」という試行の結果は，偶数，または，奇数のどちらかになります． このような試行はベルヌーイ試行と呼ばれ，ベルヌーイ試行を複数回行ったときの結果が2項分布に従います． 今回は，サンプルデータを基に2項分布のグラフを描く事から始め，2項分布を利用して生起確率を求める方法を学びます．
スクリプトの作成 -- スクリプトの作成  コードを入力し保存するためのスクリプトを作成しましょう． [ファイル]-[新しいスクリプト]をクリックし，Rエディタを表示します． 次に，[ファイル]-[保存]をクリックして，スクリプトを保存します． このとき，ファイル名はchapter6としてください． また，ファイルの保存場所と作業ディレクトリをデスクトップに変更しておきます． このとき，グラフ描画に必要なggplot2も読み込んでおきましょう．
library(ggplot2) 2項分布のグラフ -- 2項分布のグラフ  まずは「コインを投げる」という試行に注目しましょう． 試行の結果は，表 と 裏 の2通りですが，ここでは便宜的に，1 と 0 で表現します． このとき，1 が出る確率は50%と仮定します．当然，0 が出る確率も50%です． この試行を10回繰り返して行ない，1 が出た数をカウントします．
乱数を生成するsample関数を用いて，上記の試行の結果を生成してみましょう． 引数には，「取り得る値のベクトル（ここでは，0または1）」，「乱数の個数（ここでは10回）」，「重複の許可」を設定します． 結果は下記のようになりました（乱数なので結果は毎回変わる）． 10回投げて，表が5回，裏も5回という結果です．
&amp;gt; sample(0:1,10,replace=TRUE) [1] 0 1 1 1 0 0 1 0 0 1 さらに，この試行（「コインを10回投げる」）を1000回繰り返し，配列に変換して変数coinに代入しましょう．
coin &amp;lt;- matrix(sample(0:1,10000,replace=TRUE),1000,10) coinは1000行，10列の配列になります． これが，試行を1000回繰り返した結果を表しています．
&amp;gt; coin[1:10,] [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] [,9] [,10] [1,] 0 1 0 1 0 1 0 1 1 1 [2,] 0 0 1 1 1 0 0 1 1 0 [3,] 1 0 0 0 1 1 0 1 1 1 [4,] 0 0 1 0 0 1 1 1 0 0 [5,] 0 1 0 1 0 1 1 0 0 0 [6,] 0 1 1 0 0 0 1 1 1 1 [7,] 0 0 1 1 1 1 1 0 1 1 [8,] 1 1 0 0 1 0 1 0 1 1 [9,] 1 0 0 0 0 1 1 0 1 0 [10,] 0 0 0 0 1 1 1 1 0 1 次に，各試行の表の出た回数をカウントし，ベクトルcountに代入します． 各行の総和を求めるにはrowSums関数を用います．</description>
    </item>
    
    <item>
      <title>3Dグラフィックス</title>
      <link>https://mukai-lab.info/pages/classes/programming_1/chapter9/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://mukai-lab.info/pages/classes/programming_1/chapter9/</guid>
      <description>スケッチの作成  Processingを起動して，新規にスケッチを保存しましょう． メニューから[ファイル]-[名前を付けて保存]をクリックして，「スケッチフォルダを名前を付けて保存」を開きます． ファイル名に「Project9」を入力し，[保存]をクリックしましょう． 保存先に「Project9」という名前のフォルダが作成されていることを確認してください．

3次元グラフィックス  Processingは，これまで学んできた 2Dグラフィックス だけでなく， 3Dグラフィックス の描画も可能です． 3Dグラフィックスを描画するには，「 P3D(Processing 3D) 」または「 OpenGL 」の いずれかの レンダラ を指定しますが，ここでは標準の P3D を採用することにします． P3D を指定すると，2次元の座標系（x,y）が，３次元の座標系（x,y,z）に変更されます（z軸は 奥行き を表します）．
まずは，下記のコードを参考に，size()関数で P3D を指定しましょう． また，rect()関数で，1辺の長さが200の正方形を描きまます． ここで，translate()関数を利用して， 原点 をウィンドウ中央に変更していることに注意してください． Runボタンをクリックしたら，正方形が画面中央に描かれることを確認してください．
 
このままでは，座標系が３次元に変更されているか確認出来ません． そこで，マウスの動きに合わせて正方形を，X軸とY軸を中心に回転させてみましょう． X軸まわりに回転させるにはrotateX()関数，Y軸まわりに回転させるにはrotateY()関数を利用します． いずれも引数には回転する角度を ラジアン角 で指定します．
下記を参考にコードを入力したら，Runボタンをクリックしてください． ドラッグしたままマウスを動かすと，正方形が回転することを確認してください．
 

立体的な図形の描画  立体的な図形を描画してみましょう． 直方体を描画するにはbox()関数を利用します． box()関数の引数には，直方体の幅（width），高さ（height），奥行き（depth）を指定します． box()関数で描かれた直方体は原点を中心に描かれることに注意してください．
box(width, height, depth); 下記を参考にコードを入力したら，Runボタンをクリックしてください． ドラッグしたままマウスを動かすと，直方体が回転することを確認してください．
 
球を描画するにはsphere()関数を利用します． sphere()関数の引数には，半径（radius）を指定します． sphere()関数で描かれた球は原点を中心に描かれることに注意してください．
sphere(radius); 下記を参考にコードを入力したら，Runボタンをクリックしてください． ドラッグしたままマウスを動かすと，球が回転することを確認してください．</description>
    </item>
    
    <item>
      <title>ARToolkitを利用した拡張現実</title>
      <link>https://mukai-lab.info/pages/classes/programming_1/chapter12/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://mukai-lab.info/pages/classes/programming_1/chapter12/</guid>
      <description>スケッチの作成  Processingを起動して，新規にスケッチを保存しましょう． メニューから[ファイル]-[名前を付けて保存]をクリックして，「スケッチフォルダを名前を付けて保存」を開きます． ファイル名に「Project12」を入力し，[保存]をクリックしましょう． 保存先に「Project12」という名前のフォルダが作成されていることを確認してください．

NyARToolkitの導入  ARToolkit は奈良先端科学技術大学院大学の加藤研究室によって 開発された拡張現実（Augumented Reality: AR）のためのソフトウェアです． 拡張現実とは，コンピュータを利用して，現実世界の一部に「仮想的な物体や情報」を重ねて表示することを指します． この ARToolkit のProcessing向けのライブラリが「 NyARToolkit for Processing 」です．
GitHubのリリースページから， 最新バージョンのNyARToolkitをダウンロードしましょう． ダウンロードしたファイルはZIPで圧縮されているので解凍し， 解凍後の library フォルダをコピーして，「スケッチフォルダ（Project12）」の中に配置しましょう． コピーしたら，フォルダの名前を library から code に変更します． 同様に，カメラの設定ファイル camera_para.dat も「スケッチフォルダ（Project12）」の中にコピーしておきます．


次に，ソースコードの先頭に「 import jp.nyatla.nyar4psg.∗ 」を入力してください． また，今回もカメラ映像を利用するため，[スケッチ]-[ライブラリをインポート]-[Video]をクリックして， Videoライブラリをインポートしておきます．
 カメラ映像の表示  Capture クラスを利用して，カメラから入力した画像を表示しましょう． 下記を参考にコードを入力したら，Runボタンをクリックしてください． ここでは， サイズ（size） が 320x240 ， フレームレート（fps） が 30 となっている， 3 番のカメラを使用していることに注意してください． ウィンドウにカメラ映像が表示されることを確認してください．
 
拡張現実の表示  ARToolkitを利用すると，ARマーカー と呼ばれる特定のパターンをカメラで読み取ることにより， その位置を認識し，３Dオブジェクトを配置することができます． ここでは，NYARToolkitに標準搭載されている NyID を利用します． NyIDには番号が設定されており， ここではMODEL2の1番のNyIDを利用します．</description>
    </item>
    
    <item>
      <title>CodeCombatでプログラミング学習</title>
      <link>https://mukai-lab.info/pages/tech/codecombat/codecombat/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://mukai-lab.info/pages/tech/codecombat/codecombat/</guid>
      <description>CodeCombatとは  CodeCombatはRPG風のゲームを遊びながらプログラミングを学ぶことができるプラットフォームです． オープンソースのコミュニティで運営されており，2013年に公開されて以降，500人以上のプログラマーがこのプロジェクトに関わって開発が続けられています． IEやChromeなどのウェブブラウザさえあれば，プラットフォームに参加できることが特徴であり，50以上の言語に翻訳され，世界で5,000,000人以上のプレイヤーがこのプラットフォームでプログラミングを学んでいます(2016年11月18日現在)． 本格的にプラットフォームを利用するには，アカウント登録が必要ですが，今回はアカウント登録はしないで，プログラミングの基本的な文法を学ぶ「キースガードのダンジョン」に挑戦してみましょう． この授業を受ける多くの皆さんは「プログラミングは難しい」という先入観を持っているのではないでしょうか． この授業が終わった頃には「プログラミングは楽しい」と思ってもらえることを期待します．

学習コースの選択  早速，CodeCombatでプログラミング学習を始めましょう． まずは，下記のリンクをクリックしてブラウザでCodeCombatを開きます．
CodeCombat CodeCombatを開いたら，「今すぐプレイ」をクリックしましょう． すると，学習コース（ダンジョン）を選択するページに遷移します．

プログラミングに必要な，文法，メソッド，パラメータなどの基本的なスキルを学ぶことが出来る学習コースが「キースガードのダンジョン」です． キースガードのダンジョンの「ゲームスタート」をクリックしましょう．

キースガードのダンジョン ～始まりの回廊~  キースガードのダンジョンは，40のステージで構成されています． まず最初は「始まりの回廊」に挑戦します． 「始まりの回廊」をクリックしすると，このステージの概要が表示されます． このステージの目的は「宝石を集めること」のようです． 「壁の針」がちょっと気になりますね． では，ゲームスタートを選びましょう．


次に，ヒーロー（主人公）を選択する画面になります． 最初は４人しか選べませんが，ゲームを進めると選択できるヒーローが増えていきます． 好きなヒーローを選びましょう． 剣士の「サー・サーリン・サンダフィスト」を選択したとして説明を続けます． また，この画面では学習するプログラミング言語を選択します． ここでは，ウェブで用いられる「JAVASCRIPT」を選びましょう． ヒーローとプログラミング言語の選択が終わったら「次へ」をクリックしましょう．

次に，武器や防具などを装備するイベントリの画面になります． ここでは，ヒーローを上下左右に動かすための「質素な靴」を装備します． 靴のアイコンをダブルクリックすると装備することが可能です． 「質素な靴」を装備したら「ゲームスタート」をクリックしましょう．


さぁ，とうとうゲームが開始しました． 「レベルスタート」をクリックしましょう． このステージの目標は「壁の針をよける」「宝石を集める」の２つです． プログラムをコーディングして目標を達成しましょう．

マップを確認すると，ヒーローはスタート位置から右に進んだ後に，壁の針を避ける必要がありそうです． ヒーローを下に進めるには「hero.moveDown()」というコードを入力すれば良さそうです． では，6行目に上記のコードを追加して，「実行」をクリックしましょう．


これで，残るはヒーローの右にある宝石をゲットするだけです． ヒーローを右に進めるには「hero.moveRight()」というコードを入力しましょう． では，7行目に上記のコードを追加して，「実行」をクリックしましょう

宝石をゲットして，全ての目標を達成したため，ゲームクリアです． 「完了」をクリックしましょう． 獲得した経験値，ジェム，武器・防具を確認したら「次へ」をクリックします．


これで，最初のステージは終了です． プログラミングに興味が湧いてきましたか． ではその調子で次のステージに挑戦してみましょう．
キースガードのダンジョン ～宝石の部屋~  次のステージは「宝石の部屋」です． このステージの目的は「素早く宝石を集めること」のようです． 「将来必要になる」との暗示は，女性にとっては嬉しいかもしれませんが，男性にとっては恐怖です（笑）． では，ゲームスタートを選びましょう．</description>
    </item>
    
    <item>
      <title>Cortexで脳波データの取得</title>
      <link>https://mukai-lab.info/pages/tech/emotiv/emotiv2/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://mukai-lab.info/pages/tech/emotiv/emotiv2/</guid>
      <description>Cortexとは  Python を経由して，Emotiv Epoc+ で計測したデータを取得してみましょう． データを取得するには，Emotivの標準APIであるCortexを利用します． 今回はPythonを利用しますが，このCortexは JSON と WebSockets で実装されているため， Python以外のプログラミング言語でも利用可能です． また，Cortexは，EmotivProと一緒にインストールされますが， Cortex UIというソフトウェアで動作確認が可能です． 下図のように対象のデバイスが検出されていればOKです． コンタクト・クオリティは今回も35%とパッとしません（笑）．

ライブラリの導入  Pythonはウィンドウズ版のバージョン3.7.2を用いることにします． Cortexでは，データの送受信には WebSockets という技術を用います． ここでは，WebSockets のクライアント（データ受信側）として実装するため， websocket-client ライブラリをインストールしておきます．
$ pip install websocket-client また，WebSocketsのポート番号は 54231 です． URLには wss://localhost:54321 を指定します． ここで，wss はWebSocketsのプロトコルを表しています．
手順１：認証  Cortexから脳波の生データを取得するには，クライアントIDとシークレットで認証が必要です． この，クライアントIDとシークレットは，EMOTIVのユーザページで事前に取得しておきましょう（ライセンス番号も必要）．
まずは，CORTEXで用いられるJSON-RPCについて簡単に説明します． 上述したように，サーバとクライアント間のデータのやりとりをJSON形式で行うという仕組みです． クライアントが送信するリクエストの基本フォーマットは下記です． ここで，プロトコルバージョンの jsonrpc は常に 2.0 を指定します． メソッドやパラメータには，認証（authorize）やデータ取得（subscribe）などの文字列を指定します．
{ &amp;#34;jsonrpc&amp;#34;: &amp;#34;2.0&amp;#34;, &amp;#34;method&amp;#34;: メソッド, &amp;#34;params&amp;#34;:{ パラメータ: 値 }, &amp;#34;id&amp;#34;: ID番号 } また，クライアントが受信するレスポンスの基本フォーマットは下記となります． サーバーからの応答結果は result に格納されています． また，リクエストと同じID番号が付与されています．</description>
    </item>
    
    <item>
      <title>Emotivで脳波を可視化</title>
      <link>https://mukai-lab.info/pages/tech/emotiv/emotiv/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://mukai-lab.info/pages/tech/emotiv/emotiv/</guid>
      <description>
Emotivとは  Emotivは株式会社イノバテックが提供している小型の脳波計です． Epoc+，INSIGHT，EPOC flexなど複数の種類がありますが， ここでは，14チャネルの電極が装着されたEMOTIV EPOC+を対象に開発することを目的とします． この装置は，他の脳波計と比べ，スタイリッシュなデザインが特徴です． 頭に装着するだけで，未来感がビシビシ伝わってきます． 専用のアプリケーションであるEmotivPROで， 脳波データを取得・可視化するだけなら無料のラインセンスで利用可能です． しかし，脳波の生データをAPI（Cortex）を経由して取得するなど， 研究を目的として利用するためには，別途ライセンスの購入が必要です． 月額99ドルと決して安くはないため注意が必要です（年払いで割引されますが）．

EmotivPROを使ってみよう  最初に，専用のアプリケーションであるEmotivPROを利用して， 脳波データを取得・可視化してみましょう． まずは，電極のフェルドパッドを生理食塩水で水和させます． この生理食塩水はコンタクトレンズなどにも用いられているものです． ここで，しっかりと水和させておかないと，センサーの感度が悪くなる可能性があります． 電極を時計回りに回すと取り外すことができますが， 力を入れ過ぎるとフェルト部分がはずれてしまうので要注意です．

それでは，ヘッドセットを頭に装着します． ヘッドセットを両手で持ち，頭上から下に向かってスライドさせます． このとき，左右の参照電極を，ちょうど耳たぶの裏の骨部分に配置します． 参照電極を用いた方法は単極導出と呼ばれ，この参照電極と他の電極との電位差が記録されます． この参照電極は，他の電極にも影響するため，正確な設置が必要です． また，前方の左右の電極は，眉毛から指３本だけ上にあるように配置します．

この電極の設置の質（コンタクト・クオリティ）はEmotivProの下記の画面で確認できますが，・・・，非常に難しい． 緑色の電極はコンタクト・クオリティが高いことを示しています． 電極の位置を微調整しても，コンタクト・クオリティは全体で**28%**がやっとでした． このあたりのコツをご存知でしたら，お教えください．

脳波を可視化しよう  次は脳波を可視化してみましょう． ここで，脳波のサンプリングレートとA/D変換の分解能を確認しておきます． サンプリングレートは128Hz，また，分解能は16ビット（65536階調）です． 図中にEEGと表記がありますが，これはElectroencephalographの略で脳波（図）を意味しています （単に脳波をEEGと呼ぶことも多い）．

次に電極の位置番号を確認しておきます． 上述したようにEpoc+では，14チャネルの電極があり， それぞれ，AF3，AF4，F3，F4，F7，F8，FC5，FC6，T7，T8，P7，P8，O1，O2です． 図中の赤い丸で表現されている電極は，耳たぶの裏にある参照電極です． ここでは，コンタクト・クオリティの高いAF4，F3，P8の３箇所に注目します．

AF4，F3，P8の３箇所の電極の生データは下記です． 横軸は時間で単位は10[ms]，また，縦軸は電位を表し**-100µV**〜**100µV**の範囲を取ります． 一般的にローデータから，脳波の意味を読み取ることは困難なため，高速フーリエ変換をして周波数成分を取り出します．

EmotivProはフーリエ変換した周波数スペクトルの表示も可能です． P8にフーリエ変換をした結果は下記のようになります． 周波数に応じて脳波は分類され，4〜8Hzはシータ波，8〜12Hzはアルファ波，13Hz以上はベータ波と呼ばれます． この結果では，若干ですがシータ波が有意なように見えます． シータ波は眠い状態で発生する波とされ，いかに寝不足かが分かる結果となりました（笑）．

今回はEmotivの基本的な使い方を解説しました． 次回はCortexと呼ばれるAPIを利用して，Pythonで脳波データを取得することに挑戦します．
参考書籍</description>
    </item>
    
    <item>
      <title>Excelを利用した7市町オープンデータの分析①・グラフ作成</title>
      <link>https://mukai-lab.info/pages/classes/seminar_fundamental_areas/chapter1_2020/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://mukai-lab.info/pages/classes/seminar_fundamental_areas/chapter1_2020/</guid>
      <description>オープンデータとは  平成２４年，日本において公共データの活用促進を目的として電子行政オープンデータ戦略が策定されました． この戦略では，「公共データ活用の推進」「公共データ活用のための環境整備」が具体的な施策とされており， これらの施策の鍵となるのがオープンデータです．
オープンデータは下記に従うことを条件としています．
 機械判読に適したデータ形式 二次利用が可能な利用ルールで公開  つまり，行政（地方自治体）が保持している統計データや施設データなどを， 誰もが再利用や再頒布ができることを条件に，コンピュータに扱いやすい形式で公開されたデータをオープンデータと呼びます． 企業や個人のデータでも上記に従えばオープンデータですが，ここでは，行政のデータにターゲットを絞ります（オープンガバメントデータと呼ぶこともあります）． 一般に，再利用や再頒布が可能なソフトウェアのことはオープンソースと呼ばれることも合わせて覚えておきましょう．
ここで，ポイントとなるのは，「機械判読に適したデータとは何か？」ということです． 一般に小規模のデータを管理するときには，エクセル を採用することが多いです． 文化情報学部では，１年後期に開講されている「コンピュータと情報 Ⅱ」において，エクセルの使い方を学習します． たしかに，エクセルは，デザイン（書式）や関数など様々な機能を提供しており，人間にとってはとても便利なソフトウェアです． しかし，これらのデータをコンピュータで処理しようとするとき，これらの機能が却って冗長となり，コンピュータによる判読が難しい状況が起こります．
具体例をみてみましょう． まずは，エクセル形式（.xlsx）で表現された日進市の人口のデータ（jinkou.xlsx）です． タイトル部分に太字，表部分に罫線などのデザイン（書式）が設定されていることが分かります． これらは，エクセルを利用している人間が見るためのデザインであり，データの本質ではありません． また，エクセル形式（.xlsx）の実態は，XMLや画像などで構成されるZIPファイルであり， 専用のソフトウェア（エクセル，OpenOfficeなど）でしか開くことはできません．

次に，CSV形式（.csv）で表現された日進市の人口のデータ（jinkou.csv）です． CSVは「しーえすぶい」と読み，オープンデータで頻繁に採用されるデータ形式です． データが「,（カンマ）」で区切られて表現されるだけで，エクセルのようなデザイン（書式）は含みません． このため，一般的なエディタ（メモ帳）でも開くことができます（エクセルでも開けます）． エクセル形式（.xlsx）に比べると，人間にとっては理解しにくいですが，コンピュータの判読には優れています．
﻿町名,男,女,総数,世帯数 赤池町,1693,1647,3340,1315 浅田町,2593,2431,5024,2086 梅森町,1017,1034,2051,876 野方町,171,173,344,143 蟹甲町,171,200,371,152 折戸町,1404,1381,2785,1073  今回の授業では，日進市のオープンデータミュージアムで公開されている CSV形式のデータをエクセルで可視化することを目的とします． エクセル以外の方法でオープンデータを扱う方法は第３回以降に解説します．
公開されているオープンデータ  オープンデータはウェブで公開されるのが一般的であり， 総務省が運用するData.go.jpがオープンデータのカタログサイトとして知られています． このサイトでは，国土交通省，経済産業省などの組織別のデータセット，また，行財政や観光などのトピックに関するデータ・セットが提供されています． 例えば，観光 というキーワードで検索すると，「平成28年度 国際経済調査事業報告書」，「平成28年度 商店街インバウンド・空き店舗実態調査」などのデータセットがヒットします（平成30年2月28日現在）． しかし，残念ながら，これらの多くはPDF形式での提供であり，「機械判読に適したデータ」ではありません． 現状では，まだまだオープンデータの整備は不十分と言えるでしょう．
この他，内閣府のまち・ひと・しごと創生本部が提供している地域経済分析システム（RESAS）が注目されています． RESAS（りーさす）は，総務省が提供している統計情報 e-Statのオープンデータなどを可視化するためのシステムです． 地方自治体の現状や課題を発見することを目的としており，情報を直感的にわかりやすく見える化することができます． 例えば，2015年の愛知県名古屋市の 人口マップ を下記のように可視化することができます． マウスで各市区町村をホバーすると人口が表示され，名古屋市千種区は164,696人であることが分かります． また，人口推移や人口ピラミッドなどのグラフも簡単に描画することができます． このようにデータを可視化して，分かりやすく伝えることも，オープンデータの活用に必要な要素です．



愛知県下においては，オープンデータに関する取り組みを精力的に進める自治体の一つに日進市があります． 日進市のウェブサイトでは，オープンデータミュージアムを開設しており， 住民向け情報（暮らしの情報），事業者向け情報，行政活動情報，観光情報の区分に分けてオープンデータを公開しています． また，平成28年度には，瀬戸市，尾張旭市，豊明市，日進市，みよし市，長久手市，東郷町の7市町で 「7市町オープンデータ検討会」を組織し，連携してオープンデータの整備を始めています． これまでに，7市町が共通のフォーマットで，子育て支援施設，教育機関などのデータを各自治体のウェブサイトで公開しています． 今回は日進市のオープンデータミュージアムで公開されている町別・年齢別人口のデータをダウンロードして利用します． 行政活動情報のページにアクセスし， 平成29年4月1日のCSV形式のデータ をダウンロードしてください．</description>
    </item>
    
    <item>
      <title>Excelを利用した7市町オープンデータの分析②・相関分析</title>
      <link>https://mukai-lab.info/pages/classes/seminar_fundamental_areas/chapter2_2020/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://mukai-lab.info/pages/classes/seminar_fundamental_areas/chapter2_2020/</guid>
      <description>相関分析とは  相関分析とは，2つの変数XとYの関係性を分析する方法です． 例えば，暑い日にはアイスクリームの売上数が増加すると考えられます． このとき，「X:気温」と「Y:アイスクリームの売上数」には関係がありそうです． 一般に，相関分析には相関係数と呼ばれる評価指標が用いられます（正確にはピアソンの積率相関係数と呼ばれる）． 相関係数は-1から1の範囲で与えられ，1に近いほど正の相関，-1に近いほど負の相関を示します．
   相関係数 相関の強さ     0.7～1 強い正の相関   0.4～0.7 正の相関   0.2～0.4 弱い正の相関   -0.2～0.2 相関なし   -0.4～0.2 弱い負の相関   -0.7～-0.4 負の相関   -1～-0.7 強い負の相関    正の相関は，Xが増加するとYも増加する関係を表し，負の相関は，Xが増加するとYが減少する関係性を表します． 先の「気温」と「アイスクリームの売上数」の例では，気温が増加すると，売上数も増加するので正の相関となります． 相関係数はアンケートの分析などでも用いられるメジャーな分析手法の一つです． ここでは，日進市のオープンデータを対象に相関分析を適用してみましょう．
データの準備  前回の授業で日進市の人口ピラミッドを作成しました． グラフから，日進市には子育て世帯が多く，幼稚園や保育園などが充実した地区が人気であることが予想されます． そこで，町別人口・世帯数と子育て支援施設のデータを対象に，相関関係があるかを調べてみましょう．
それでは，日進市のオープンデータミュージアムから 上記の2種類のデータをダウンロードしましょう． まずは，オープンデータミュージアムで公開されている行政活動情報の町別人口・世帯数のデータをダウンロードします． 行政活動情報のページにアクセスし， 平成30年1月1日のCSV形式のデータをダウンロードしてください． このデータには，日進市内の各町（赤池町，浅田町など）の人口や世帯数が含まれています．

次に7市町オープンデータのフォーマットに従った子育て支援施設のデータをダウンロードします． 7市町オープンデータ共通整備項目にアクセスし， CSV形式のデータをダウンロードしてください． このデータには，日進市内にある幼稚園や保育園などの子育て支援施設の名称や住所が含まれています．

相関係数の算出  それでは，ダウンロードしたデータをエクセルで読み込み相関係数を算出してみましょう． まずはエクセルを起動して，空白のブックを選択します． セルA1をアクティブにした状態で，データ・タブのテキストまたはCSVからをクリックします． ダイアログが表示されたら，ダウンロードした町別人口・世帯数のファイルを選択し，インポートをクリックします． プレビュー画面で，編集をクリックし，クエリエディタを開きます． ここでは，1行目から3行目の不要なデータを削除してしまいます． 削除後に，1行目をヘッダーとして使用をクリックして，最後に，閉じて読み込むをクリックします． 読み込み後に，下記のように表示されていることを確認してください．</description>
    </item>
    
    <item>
      <title>Excelを利用した統計処理・2項分布</title>
      <link>https://mukai-lab.info/pages/classes/seminar_core_areas_learning/chapter2/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://mukai-lab.info/pages/classes/seminar_core_areas_learning/chapter2/</guid>
      <description>授業の準備  今回、分析対象とするデータは、「コインを10回投げる」という試行の結果です。 コイン投げの試行の結果は2通り（表・裏）であり、表を 1 、裏を 0 と表現します。 また、表が出る確率は 50% 、同様に裏が出る確率は 50% と仮定します。 下記のデータは「コインを10回投げる」という試行を100回繰り返したときの結果です（21回目以降の試行は省略）。
上記のデータを含むファイルcoin.csvをダウンロードしましょう。 ファイルをダウンロードしたら、前回と同様にExcelでcoin.csvを読み込んでください。

2項分布  まずは、各試行でコインが表になった回数を数えてみましょう。 表は1で与えられるので、各試行の値の総和が表になった回数を表します。 また、表が出る回数は0から10の範囲に収まります。
 セルL2:L101に、sum関数で表が出た回数を求める  
1回目の試行は5回、2回目の試行は7回となりました。 では「コインが表になった回数」はどのような分布になっているか確認するために 分析ツール を利用して ヒストグラム（頻度分布） を求めましょう。 最初に、下図のようにN列に0から10までのデータ区間を入力します。

次に、データタブに切り替え、データ分析をクリックします。 一覧からヒストグラムを選択し、OKをクリックすると、ダイアログが表示されます。 ダイアログに下記の設定をしてから、ヒストグラムを求めて下さい。
 入力範囲にL2:L101を設定する データ区間にN2:N12を設定する 出力オプションで新規ワークシートにチェックを入れる  
新規に作成されたシートには、0から10の範囲で表が出た回数のヒストグラムがまとめられます。 中央の5回が最頻値となっており、中央から離れるほど頻度が小さくなることが分かります（0回と10回は一度も出現していません）。 ここで、頻度を基に各データ区間の発生確率を求めましょう。 C列に頻度を100で割った値を入力します。

さらに、求めた確率で棒グラフを描きます。 C列をマウスで選択し、挿入タブの棒グラフをクリックします。 すると、下図のように、横軸が「表が出た回数」、縦軸が「確率」である棒グラフが描けます（タイトル、軸ラベル、軸の書式設定を図に合わせて修正してください）。

このグラフは2項分布と呼ばれる確率分布に近似することが可能です。 このデータは100回の繰り返しの結果ですが、試行回数が増えるほどに2項分布の理想の形状に近付きます。
2項分布の公式  では2項分布の理想的な形状を考えましょう。 2項分布は上記のコインのように結果が2通りの試行を対象とします（ベルヌーイ試行 と呼びます）。 また、試行の結果が生じる確率を生起確率と呼びます。 よって、2項分布は「1回の生起確率がpのベルヌーイ試行を、n回行って、k回起こる確率」を表すことになります。
例えば、「コインを5回投げて表が3回出る確率（p=0.5、n=5、k=3）」を考えます。 このとき、「コインを5回投げて表が3回出る組み合わせ」は $ _n C_k = _5 C_3=10$ 通りです。</description>
    </item>
    
    <item>
      <title>Excelを利用した統計処理・正規分布</title>
      <link>https://mukai-lab.info/pages/classes/seminar_core_areas_learning/chapter3/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://mukai-lab.info/pages/classes/seminar_core_areas_learning/chapter3/</guid>
      <description>授業の準備  今回、分析対象とするデータは、気象庁が公開している「名古屋の降水量（1891年～2016年）」です。 下記のデータは各年度の降水量（mm）の合計を表しています（1911年以降は省略）。 気象庁では降水量に加え、気圧、気温、湿度など天候に纏わるデータを公開しているので様々なデータを対象に分析すると面白いです。
上記のデータを含むファイルprecipitation.csvをダウンロードしましょう。 ファイルをダウンロードしたら、前回と同様にExcelでprecipitation.csvを読み込んでください。

正規分布  正規分布は、平均値に近い値の頻度が高く、平均値から離れるほど頻度が低くなる特徴を持った確率分布のことです。 前回学んだ2項分布も上記と同じような特徴を持ちますが、２項分布 は離散値（例、コインの表が出る回数）を対象としますが、 正規分布 は連続値（例、降水量）を対象とする点が大きく異なります（実際、２項分布の試行回数nを無限大に近づけると正規分布に一致する）。 一般に、正規分布は様々な自然現象や社会現象に当てはまると考えられており、上記の降水量も例外ではありません。
まずは、降水量の分布を確認するために 分析ツール を利用して ヒストグラム（頻度分布） を求めましょう。 最初に、下図のようにD列に1100から2500までのデータ区間（幅は200）を入力します。

次に、データ タブに切り替え、データ分析 をクリックします。 一覧からヒストグラムを選択し、OKをクリックすると、ダイアログが表示されます。 ダイアログに下記の設定をしてから、ヒストグラムを求めて下さい。
 入力範囲はB2:B128を設定する データ区間はD2:D9を設定する 出力オプションで新規ワークシートにチェックを入れる  
新規に作成されたシートには、1100から2500の範囲で降水量のヒストグラムがまとめられます。 1700-1900が最頻値となっており、この範囲から離れるほど頻度が小さくなることが分かります。 ここで、頻度を基に各データ区間の確率密度を求めましょう（確率 ではないことに注意）。 実際の降水量は連続値ですが、ヒストグラムは離散値であるため、データ区間の幅を考慮しなくてはいけません。 そこで、C列に頻度を、頻度の合計である126と、データ区間の幅200を掛けた25200 で割った値を入力します。 このとき、データ区間も1700-1900のように区間を含めた表現に修正しておきましょう。

さらに、求めた確率密度で棒グラフを描きます。C列をマウスで選択し、挿入 タブの棒グラフをクリックします。 すると、下図のように、横軸が「降水量」、縦軸が「確率密度」である棒グラフが描けます（タイトル、軸ラベル、軸の書式設定を図に合わせて修正してください）。 確率密度を表していることから、棒グラフの面積の総和が1になることが分かります。

このグラフは正規分布に近似することが可能です。 一般にデータサンプルが多いほど、理想的な正規分布の形状に近付きます。
正規分布の公式  正規分布の確率密度は下記の式で与えられます。 2項分布よりも難しく感じると思いますが、この式の重要なパラメータはたった2つです。 １つは平均\mu、もう１つは標準偏差\sigmaです。 この2つのパラメータで正規分布の形状が決まります。
\frac{1}{\sqrt{2 \pi} \sigma} \exp \left(- \frac{(x - \mu)^2}{2 \sigma ^2} \right)  また、上記の計算はExcelではnorm.dist関数を用いて求めることができます。 それでは、Excelで降水量を近似する正規分布を求めましょう。 まずは、平均\mu、標準偏差\sigmaを求めます。 平均は1588.</description>
    </item>
    
    <item>
      <title>Excelを利用した統計処理・相関係数</title>
      <link>https://mukai-lab.info/pages/classes/seminar_core_areas_learning/chapter1/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://mukai-lab.info/pages/classes/seminar_core_areas_learning/chapter1/</guid>
      <description>Microsoft Excelとは  Microsoft Excelはマイクロソフトが開発している表計算ソフトです． 表計算ソフトとは数値データの集計や分析を行うためのソフトウェアのことを指し， Excel以外にもOpenOfficeやGoogleドキュメントなどが存在しますが， Excelが**デファクトスタンダード(事実上の標準)**となっています． 一般に，Excelは，マス目状のセル（入力の単位）で構成されたスプレッドシート（単にシートと呼ぶことが多い）に， 数値，文字列，計算式などのデータを入力することで，財務管理や販売管理などに利用されています． 一方で，Excelには，分析ツール（統計処理） や ソルバー（最適化処理） などの機能が備えられており，統計学的な分析も可能です． この授業では，統計分析の基本である「相関係数」や「2項分布」などを，Excelを用いた実習形式で学ぶことを目的とします． マイクロソフトの認定資格であるマイクロソフト・オフィス・スペシャリスト（MOS）の取得も視野に入れて学習していきましょう．
授業の準備  今回，分析対象とするデータは，20人の5教科（国語，算数，理科，英語，社会）の得点リストです．
まずは，上記のデータを含むファイル seiseki.csv をダウンロードしましょう． ファイルをダウンロードするには，ファイルのリンクを右クリックをして，「名前を付けてリンク先を保存」を選択します（ブラウザによって異なる）． ここで，ファイルは**CSV（Comma Separated Values）**という形式で保存されていることに注意してください． CSV形式では，対象となるデータ（ここでは得点）が，「,（カンマ）」で区切って入力されています（メモ帳で開いて確認してみてください）．
ファイルをダウンロードしたら，Excelでseiseki.csvを読み込んでみましょう． Excelを起動し，空白のブック を選択し，ファイルを新規作成します． 次にデータタブに切り替え，テキストまたはCSVから をクリックします． 表示された データの取り込み のダイアログでseiseki.csvを選択し，インポートをクリックします． 最後に，読み込まれるデータを確認したら，読み込みをクリックします．

Excelで下記のように表示されていれば成功です． シートの1行目には項目名である氏名，国語，算数，理科，英語，社会が入力されています． また，2行目以降は，20人の生徒の得点リストが入力されています．

相関係数  読み込んだ得点リストのデータを対象に，相関係数 を考えていきましょう． 相関係数とは，2種類のデータの関係の強弱を示す指標です． 例えば，夏の暑い日には，アイスクリームがよく売れますよね． このとき，温度 とアイスクリームの売上 には相関があると言えます． これを定量的に数値で相関の強弱を表したものが 相関係数 です．
まずは，視覚的に相関係数の意味を捉えていきます． 「算数と理科」の組み合わせで散布図を描きます． 算数のC列と理科のD列をマウスで選択し，挿入タブの散布図をクリックします． すると，下図のように，横軸が算数，縦軸が理科である散布図が描けます（タイトル・軸ラベル・軸の境界値を図に合わせて修正してください）．

次に，データ系列で右クリックして，近似曲線の追加をクリックしてください． このとき，近似曲線のオプションで線形近似を選択します．

この結果から，算数と理科には右上がりの相関関係があることが分かります． つまり，「算数が得意な生徒は理科も得意」，逆に，「算数が苦手な生徒は理科も苦手」と考えることができます． このような相関関係を正の相関と呼びます．
今度は，「算数と英語」の組み合わせて散布図を描きます． 算数のC列と英語のE列をマウスで選択し，挿入タブの散布図をクリックします（離れたセルを選択するにはCtrlキーを押します）． すると，下図のように，横軸が算数，縦軸が英語である散布図が描けます（タイトル・軸ラベル・軸の境界値を図に合わせて修正してください）． このとき，同様に近似曲線も追加してください．</description>
    </item>
    
    <item>
      <title>Google VR SDKで視線の検知</title>
      <link>https://mukai-lab.info/pages/tech/unity/google_vr2/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://mukai-lab.info/pages/tech/unity/google_vr2/</guid>
      <description>視線の検知  VR環境では，タップなどスマートフォンで一般に用いられる操作が出来ません． そこで，Google VRでは， ユーザの視線による操作を可能としたGoogle VR Pointer System が用意されています． 今回は，視線を利用したオブジェクトの選択を実現してみましょう． 事前に準備が必要なプロジェクトの作成やパッケージの導入などは， Google VR SDKを利用した360°画像ビューアーを参考にしてください．
シーンの作成  シーンを新規に作成します． ここでは，シーンの名前は[MenuScene]とします． まずは，Google VR SDKを利用した360°画像ビューアーを参考に， 空のオブジェクトであるVR Cameraを作成し，直下にMain CameraとGvrEditorEmulatorを設定します．
次に対象となるQuadオブジェクトをシーンに配置します． Quadオブジェクトを配置するには，[GameObject]-[3D]-[Quad]を選択します． Quadオブジェクトのインスペクターを開き，Position の Z座標 を5に設定しましょう． また，新規にマテリアルを作成し，Quadオブジェクトに追加しておきます（マテリアルに関しては割愛します）． シーンを再生すると下記のように表示されます．

視線の検知  上記で作成したQuadオブジェクトを視線に捉えていることを検出してみましょう． まずは，ヒエラルキーにGvrEventSystemをドラッグ＆ドロップで配置します． GvrEventSystemは視線に関するイベントの包括的な処理を行います． また，ヒエラルキーのMain Cameraの直下に，GvrReticlePointer を配置します． GvrReticlePointerは，ユーザが見つめている一点をポインタで表します． 対象となるオブジェクトを見続けているとポインタが拡大します． シーンを再生すると下記のように表示されます． 中央に視点を表すポインタが表示されていることが分かります． 現時点ではQuadオブジェクトを見続けてもポインタに変化はありません．

次に，視線を検出するためのスクリプトをMain Cameraに設定します． Main CameraのインスペクターでAdd Componentを選び，Physics Raycaster を選択します（Physics Raycasterはスクリプトであることに注意）．

また，対象となるQuadオブジェクトにEvent Triggerを設定します． QuadオブジェクトのインスペクターでAdd Componentを選び，Event Trigger を選択します（Event Triggerもスクリプト）．
シーンを再生すると下記のように表示されます． 中央にあるポインタがQuadオブジェクトを捉えると， ポインタが大きな円に変形することが分かります．

シーンの切替  Quadオブジェクトを2秒間見続けるとシーンを切り替えるようにします． QuadオブジェクトのインスペクターでAdd Componentを選び，Net Script を選択します（C#で記述する）． ここでは，スクリプト名はCntrol Sceneとします．</description>
    </item>
    
    <item>
      <title>Google VR SDKを利用した360°画像ビューアー</title>
      <link>https://mukai-lab.info/pages/tech/unity/google_vr/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://mukai-lab.info/pages/tech/unity/google_vr/</guid>
      <description>Google VR SDK for Unity  近年，VR(Virtual Reality)に関する技術は目覚ましいスピードで発展しています． Oculus社が開発する「Oculus Rift」， SCE(Sony Computer Entertainment)の「PlayStation VR」など， 本格的なVRのためのヘッドマウントディスプレイも手に入れることができます． しかし，これらの製品はまだまだ高価であり，気軽に導入することは難しいです． このような状況のなか，Googleは，スマートフォンを組み合わせて利用する， ダンボール製の安価な「Cardboard」というヘッドマウントディスプレイを提供しています． 同時に，Googleは，「Google VR」という， VRに関するプロジェクトを立ち上げ，開発者向けのツールも提供しています． そこで，今回は，ゲームエンジンの一つであるUnityで， Cardboard向けVRを開発可能な「Google VR SDK for Unity」を利用したアプリを制作してみます． また，VR環境には，リコーが開発する「RICHO THETA S」で撮影した360°画像（全天球画像）を用い， ヘッドセットの動きに合わせて，360°画像を閲覧できるようにします． 開発に当たり，SlideShareで公開されているOculus Rift勉強会の資料 THETAでモバイルVRコンテンツ開発を参考にさせて頂きました．
準備  アプリの開発に当たり下記の機器を利用します． ヘッドマウントディスプレイにはCardboardではなく， サンワサプライが販売している「VR SHINECON」を利用します． ヘッドホンが搭載されており，Cardboardに比べると高級感があるモデルです．
また，360°画像（全天球画像）の撮影にはRICHO THETA Sを採用します． 静止画・動画に対応しており，動画のライブストリーミングも可能なモデルです．
 VR SHINECON RICHO THETA S  下記がRICHO THETA Sで撮影したサンプル画像です． マウスを使って画像をスクロールすると，教室に一人で寂しそうに立っている向の姿が見えるはずです． ここでは，ウェブで360°画像を表示するために「VR view on the web」を利用しています． また，RICHO THETA Sで撮影された画像の解像度は5376x2688ですが，VR viewに最適な4096x2048に変換してあります．
 プロジェクトの作成  Unityでプロジェクトを作成します． Unityのバージョンは5.</description>
    </item>
    
    <item>
      <title>JavaFX①入力フィールドとボタン</title>
      <link>https://mukai-lab.info/pages/classes/applied_programming/chapter9/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://mukai-lab.info/pages/classes/applied_programming/chapter9/</guid>
      <description>プロジェクトの準備 --プロジェクトの準備  Eclipseで新規にプロジェクトを作成しましょう． メニューから[ファイル]-[新規]-[Javaプロジェクト]をクリックして，「新規Javaプロジェクトの作成」を開きます． ここでは，プロジェクト名に”Project9”を入力します． また，JREは プロジェクト固有のJREを使用 を選択します． 最後に，[完了]をクリックしましょう． パッケージ・エクスプローラに作成したプロジェクトが表示されていることを確認してください．

本日取り上げるのJavaFXは，Eclipseの現バージョン（Mars）では， 「使用すべきではない制限されたAPI」に指定されているため， 事前に，JavaFXの利用を許可する必要があります（将来的には指定から取り除かれると思います）． メニューから[ウィンドウ]-[設定]をクリックして，「設定」のダイアログを開きます． さらに，ダイアログから[Java]-[コンパイラー]-[エラー/警告]を選択します． ここで，「使用すべきではないAPI」，「禁止された参照」，「阻止された参照」の３カ所を無視に設定してください．

JavaFXとは --JavaFXとは  従来，Javaにおける GUI（Graphical User Interface） は， AWT（Abstract Window Toolkit）やSwingと呼ばれるGUIツールキットを利用するのが標準でした． 一方，JavaFXは2014年にリリースされたJava 8に統合された新しいGUIツールキットです． AWTやSwingに比べ，より洗練されたGUIアプリケーションの制作が可能です． それでは，このJavaFXを利用したGUIプログラミングを学習していきましょう．
ウィンドウの表示 --ウィンドウの表示  JavaFXを利用したGUIアプリケーションを作成するには， javafx.applicationパッケージに含まれるApplicationクラスを継承することから始めます． パッケージとはクラスをグループ分けして管理するためのフォルダのようなものです． パッケージ名も含めたクラス名はjavafx.application.Applicationと表記します．
まずは，Applicationクラスを継承したMyApplicationクラスを作成しましょう． メニューから[ファイル]-[新規]-[クラス]をクリックして，「新規Javaクラス」を開きます． まず，名前に”MyApplication”を入力します． 次にスーパークラスを設定するために，[参照]ボタンから「スーパークラスの選択」を開き， 一致する項目からjavafx.application.Applicationを選択して，[OK]をクリックします． 最後に[完了]をクリックしましょう．


MyApplicationクラスでは，Applicationクラスの抽象メソッドである startメソッドをオーバーライドする必要があります． また，他のパッケージのクラスを利用する場合は，ソースコードの先頭にimportという表記を用いて，import javafx.application.Application;のように記述します（Eclipseが自動的に補完してくれるはず）．
 startメソッドの引数であるStageクラスがウィンドウを表しています． 下記コードを参考にStageクラスのsetTitleメソッド，setWidthメソッド，setHeightメソッドを利用して，タイトルをProject 9，幅を320px，高さを240pxに設定しましょう． また，作成したウィンドウを表示するにはshowメソッドを利用します． プログラムの実行後にウィンドウが表示されることを確認してください．
 
プログラム実行時の注意  JavaFXはmainメソッドがなくともプログラムの実行が可能という特徴を持っています． しかし，Eclipseの現バージョンでは未対応のため，下記のコードをMyApplicationクラスに記述する必要があります． プログラム実行の前に，必ず下記のコードをソースコードに挿入してください．</description>
    </item>
    
    <item>
      <title>Javaの開発環境の確認</title>
      <link>https://mukai-lab.info/pages/classes/applied_programming/chapter1/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://mukai-lab.info/pages/classes/applied_programming/chapter1/</guid>
      <description>Javaとは -- Javaとは  Javaはサン・マイクロシステムズが1990年に開発したオブジェクト指向のプログラミング言語です． サン・マイクロシステムズは2010年にオラクルに吸収合併されたため， 現在，Javaはオラクルによって開発・提供されており， 無料でjava.comからダウンロードすることが可能です． Javaは下記の特徴を備えており，さまざまな分野で広く利用されています．
 オブジェクト指向であり，大規模なチームでの開発にも向いている ウィンドウズやマッキントッシュなどのプラットフォームに依存しない C，C++の文法を引き継いでおり，標準的で学びやすい  第1の特徴の「オブジェクト指向」という考え方は，Javaの重要なキーワードですが， プログラミング初心者にはちょっと難しい概念かもしれまん． 取り敢えず「もの（オブジェクト）」という考え方を中心にした開発手法と覚えておいてください． オブジェクト指向に関しては第8回で詳しく説明します．
第2の特徴はJVM（Java Virtual Machine）という方法で実現しています． 一般にJavaで開発されたプログラムはバイトコードと呼ばれる独自の形式で配布されています． このバイトコードを実行するためには事前にJVMをウィンドウズやマッキントッシュなどのPCにインストールする必要があります． つまり，どんなプラットフォームでも，JVMさえインストールしておけば，Javaのプログラムは実行可能というわけです．
第3の特徴は，Javaがオブジェクト指向を実現しつつ，C++よりもシンプルであることを目指して設計されたことが理由です． このため，JavaはCプログラマーには馴染みやすく，新人研修など教育向けのプログラミング言語としても広く利用されています．
Javaの開発環境 -- Javaの開発環境  Javaのポピュラーな開発環境としてEclipseがあります． EclipseはIBMによって開発され，現在はオープンソースとして開発が継続されています． プログラミング初心者が開発環境を整えるには，日本語化プラグインを導入したパッケージPleiadesを利用するのがお薦めです． Eclipseにはバージョン管理システムのCVS，Gitなども組み込まれているため， チームで効率的にソースコードを管理することも可能です．
Eclipseを起動すると下記のメイン画面が表示されます． Eclipseのメイン画面はビューという区画で区切られています． 様々な機能を備えたビューがありますが，この授業で主に利用するのは「パッケージ・エクスプローラー」「エディタ」「問題・コンソール」の3つです． パッケージ・エクスプローラーは，プロジェクトに含まれるファイルやフォルダを階層的な構造で管理するためのビューです． エディタは，Javaのソースコードを編集・保存するためのビューです． 問題・コンソールは，コンパイル時に発生したエラーを確認したり，プログラムの実行結果を確認するためのビューです．

プロジェクトの作成 -- プロジェクトの作成  Eclipseでは「プロジェクト」という単位でプログラムを管理します． プロジェクトを作成するには，メニューから[ファイル]-[新規]-[Javaプロジェクト]をクリックして，「新規Javaプロジェクト」を開きます． ここでは，プロジェクト名に&amp;quot;Project1&amp;quot;を入力して，[完了]をクリックしましょう． パッケージ・エクスプローラに作成したプロジェクトが表示されていることを確認してください． プロジェクト内に生成された&amp;quot;src&amp;quot;フォルダに，Javaのソースファイルは保存されます．

ソースファイルの作成 -- ソースファイルの作成  作成したプロジェクトにJavaソースファイルを作成します． Javaのプログラムはクラスという単位で構成され，ファイル名は&amp;quot;クラス名.java&amp;quot;となります． Javaソースファイルを作成するには，メニューから[ファイル]-[新規]-[クラス]をクリックして，「新規Javaクラス」を開きます． ここでは，名前に&amp;quot;MyClass&amp;quot;を入力し，public static void main(String[] args)(V)にチェックを入れ，[完了]をクリックしましょう． パッケージ・エクスプローラに作成したソースファイルが表示されていることを確認してください．

エディタには作成した下記のソースコードが表示されています． ソースコードの詳しい説明はここでは省略します．
 文字列の出力 -- 文字列の出力  文字列を出力するにはSystem.</description>
    </item>
    
    <item>
      <title>MOONBlockでゲームプログラミング</title>
      <link>https://mukai-lab.info/pages/tech/enchant_js/moonblock/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://mukai-lab.info/pages/tech/enchant_js/moonblock/</guid>
      <description>MOONBlockとは  MOOBlockは株式会社ユビキタスエンターテインメントが 開発する教育用のプログラミング言語です． 普通のプログラミング言語（C言語など）は複雑な命令や制御を理解する必要がありますが， MOONBlockではブロックを並べるだけで簡単にプログラミングできるという特徴があります （同様の方法でプログラミングが可能なMITメディアラボ開発のSCRATCHも有名です）． 事前にソフトウェアをインストールする必要もなく， ウェブブラウザ（IE，Chromeなど）がインストールされていれば動作させることが可能です． 今回はこのMOONBlockを利用して簡単なゲームを制作することを目指しましょう．
MOONBlockの基本  MOONBlockはゲームエンジンの一つであるenchant.jsがベースとなっています． このため，MOONBlockで作成したプログラムを基にPC，Mac，iOS，Androidなど様々なプラットフォームで動作するアプリケーションを開発することが可能です． enchant.jsはMITライセンスであり，ソースコードの著作権の表示を条件に， 「ソースコードの改変」「再配布」が認められています （詳細はenchant.jsのライセンスを参照）．
また，制作したゲームをゲーム投稿サイトの9leapに投稿することで， ゲームを体験したユーザから様々なフィードバックを得ることができます（コンテストに応募して賞金を狙うことも）． 下記は研究室の学生が制作し9leapに応募した作品です． 時間があるときに遊んでみてください．
星を集めようはスライムを避けながら星（スター）を３つ集めるゲームです．
 イライラ棒アプリは木，森などの障害物に当たることなく，ゴールを目指すゲームです．
 ひよこマンは，３種類に変身するひよこを操りながら，鍵を集めてゴールに向かうゲームです．
 MOONBlockのゲーム素材画像  ゲームを制作する際に必要なアイコン，キャラクター，背景などの素材画像は， MOONBlockであらかじめ用意されています（非営利目的であれば自由に利用可能）． アイコンは16×16ピクセル，キャラクターは32&amp;amp;times32;ピクセル， 背景は320×320ピクセルで構成されています． これらの素材画像を重ねて表示することでゲーム画面は構成されます．
ここでキャラクターの素材画像（chara1.png）に注目してみましょう． 少しずつ異なるクマの画像が横に並んでいることが分かります． これらの画像を，パラパラ漫画の要領で，素早く切り替えることでクマが動いているように見せることができます．

Chara1.png

icon0.png

rpg.png
MOONBlockの開発画面  下記のリンクをクリックして，MOONBlockのサイトを開きましょう！
http://www.moonblock.jp/
画面上に並んでいる「パペット」「ビヘイビア」などの箱を「キット」と呼びます． キットにはプログラミングに必要なブロックが使用目的に合わせて別れて入っています． キットは左右にドラッグすることで全ての種類を確認できます．
画面右上にある青い正方形は実行画面です． プログラムの実行結果はここで確認できます． 大きさは背景画像と同じ320×320ピクセルです．
画面左下にあるボタンをクリックすると，プログラムの保存や，プログラムの実行ができます． 一端保存して自宅でプログラミングの続きをしたり，9leapに作品を投稿するときに利用しましょう．
画面右下にあるゴミ箱には，不要になったブロックを入れます． 一度捨てたブロックは復元できないので注意してください．

くまのバナナ拾いゲームの制作  くまが画面内にあるバナナを拾うゲームを作ってみましょう．
まずは，クマのキャラクターを画面に出現させましょう． 「パペット」キットから「パペット」ブロックをドラッグしてワークスペースに配置します． パペットとは”操り人形”の意味であり，MOONBlockではクマなどのキャラクターやバナナなどのアイテムを指します． 次に，「ビヘイビア」キットから「出現」ブロックを引き出し，「パペット」ブロックに下図のように接続します． ビヘイビアとは”振る舞い”の意味であり，パペットの動きなどを設定するときに用います． Runボタンをクリックして実行してみましょう． このときのブロックの状態はここから確認できます．</description>
    </item>
    
    <item>
      <title>NyARToolkit for Unityで3Dモデルのアニメーション</title>
      <link>https://mukai-lab.info/pages/tech/unity/artoolkit4/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://mukai-lab.info/pages/tech/unity/artoolkit4/</guid>
      <description>
3Dモデルのアニメーション  前回に引き続き，Unityのオリジナルキャラクターである「ユニティちゃん」を利用して， 3Dモデルにアニメーションを設定してみましょう（詳細はNyARToolkit for 3Dモデルの表示を参照）．
Unityで3Dモデルにアニメーションを設定するときは，Animator ControllerというAssetを利用します． 「ユニティちゃん」のパッケージには，UnityChanLocomotions，UnityChanActionCheck，UnityChanARPoseの ３種類のAnimator Controller **が含まれています．
今回は，UnityChanLocomotionsを「ユニティちゃん」に設定して，キーボードの入力に対応してアニメーションするように改良します．
Animation Controller  [UnityChan]-[Animators]にAnimation ControllerのUnityChanLocomotionsがあります． これをドラッグし，unitychanのInspectorにあるControllerに設定します． これで，「ユニティちゃん」はUnityChanLocomotionsで定義されたアニメーションを行うことが可能となります．

ここで，UnityChanLocomotionsの内容を確認してみましょう． Animation Controllerは下図のようにグラフで定義されます． まずは，Entryから始まり，Idle状態に遷移することが分かります．

Idle状態のInspectorを確認すると， MotionにWAIT00が設定されていることが分かります． このWAIT00が3Dモデルの動きに対応します． また，Idle状態から，Locomotion状態，WalkBack状態，Rest状態の ３つの状態に遷移可能なことが分かります．

では，Idle状態から他の状態に遷移するための条件は何でしょうか． TransitionsのIdle -&amp;gt; Restをクリックすると，状態遷移のための条件（Conditions）が表示されます． ここでは，Restという変数（パラメータ）がtrueであるときにRest状態に遷移することが分かります． 同様に，Locomotions状態に遷移する条件は，Speedが0.1より大きいとき， また，WalkBack状態に遷移する条件は，Speedが-0.1より小さいときということが分かります． このように変数（パラメータ）に基づき，3Dモデルの状態が確定します．

スクリプトによる状態遷移の制御  次に，C#スクリプトを作成し，キーボードからの入力に応じて状態遷移を制御してみます． まずは，[Create]-[C# Script]をクリックして，新規にC#のスクリプトを作成します． ファイル名はARAnimationsとしておきます．
まずは，キーボードの1を押すとRest状態に遷移するようにしてみます． キーの入力判定はInput.GetKey()メソッドを利用します． 引数にはstring型で対象となるキーを指定します． また，状態遷移のトリガーとなる変数Restの値を設定するには， SetBool()メソッドを利用します． 引数には，String型で対象となる変数と，その値を指定します． 再生ボタンをクリックして，「ユニティちゃん」を表示した状態で，キーボードの1を押してみましょう． ユニティちゃんが背伸びをするアニメーションが表示されるはずです．
 次に，キーボードの2を押すとLocomotions状態，3を押すとWalkBack状態， 4を押すとIdle状態に遷移するようにしてみます． トリガーとなる変数Speedはfloat型のため，SetFloat()メソッドを利用して値を変更しています． 再生ボタンをクリックして，「ユニティちゃん」を表示した状態で，キーボードの2，3，4を押してみましょう． ユニティちゃんが走ったり，後ずさりするアニメーションが表示されるはずです．  

これまでに紹介した機能を利用して，拡張現実を利用した作品を制作してみてください．
参考書籍</description>
    </item>
    
    <item>
      <title>NyARToolkit for Unityで3Dモデルを表示</title>
      <link>https://mukai-lab.info/pages/tech/unity/artoolkit3/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://mukai-lab.info/pages/tech/unity/artoolkit3/</guid>
      <description>
3Dモデルの準備  NyARToolkitのパッケージに含まれる サンプルSimpleLiteはマーカーを検出すると赤色の立方体（Cube）を表示するプログラムです． このSimpleLiteを修正し，3Dモデルを立体的に表示できるよう改良します．
SimpleLiteフォルダをコピーし，フォルダに含まれるC#スクリプトをARPictureCamera， シーンをARPictureSceneにファイル名を変更した状態を前提とします （詳細はNyARToolkit for Unityの導入を参照）．
Unityでは**.3ds**，**.obj**などの一般的な3Dモデルのファイル形式を利用できますが， 今回はUnityのオリジナルキャラクターである「ユニティちゃん」を利用してみます． 「ユニティちゃん」はUnityの**アセット（素材）**として配布されているので導入はとても簡単です． また，このキャラクターは，ラインセンスロゴもしくはライセンス表記があれば，キャラクターの二次創作物の制作が認められています （詳細は「ユニティちゃんライセンス条項」を参照）．

まずは，「ユニティちゃん」の公式ページから，ライセンスに同意し，データをダウンロードします． データをダウンロードしたら，ツールバーから[Assets]-[Import package]-[Custom package]をクリックして， ダウンロードしたパッケージを選択します． ファイルの読込み後に，ダイアログが表示されたら，全てのファイルにチェックを入れた状態でimportをクリックしましょう． ファイルの取り込みが終わると，プロジェクトのAssetsに新しくUnityChanフォルダが展開されます．

3Dモデルの表示  [UnityChan]-[Models]に「ユニティちゃん」の3Dモデルであるunitychanがあります． これを，ドラッグし，HierarchyにあるMarkerObjectの直下に配置します． すると下記のようにx=0，y=0，ｚ=0の位置に「ユニティちゃん」が配置されます．

次に，「ユニティちゃん」の**サイズ（Scale）や座標（Position）**を調整します． ここでは，Inspectorから，サイズの値をX=80，Y=80，Z=80，位置をX=0，Y=-40，Z=-20に修正しましょう．

再生ボタンをクリックすると，「ユニティちゃん」が表示されることを確認してください． 説明文なしに下記の画像だけだと完全に変な人かもしれません．

次回はAnimator Controllerを利用して「ユニティちゃん」に歩くなどの動きを付けることに挑戦します．
参考書籍</description>
    </item>
    
    <item>
      <title>NyARToolkit for UnityでNFTを利用したマーカーの認識</title>
      <link>https://mukai-lab.info/pages/tech/unity/artoolkit5/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://mukai-lab.info/pages/tech/unity/artoolkit5/</guid>
      <description>画像の準備  NyARToolkitのパッケージに含まれるサンプルSimpleNftは NFT(Natural Feature Tracking)を利用したマーカー認識のサンプルです． NFTとは自然特徴点を利用した物体認識のことで，この技術を利用することで，一般的な画像をマーカーとして扱うことができます （詳しくはThe Sixwish Projectを参照）． ここでは，下記の下記の「犬の画像（001.png）」と 「うさぎの画像（002.png）」を マーカーとして利用することに挑戦します． 画像サイズは300x300ピクセル，画像フォーマットは透過背景のPNGです． また，犬の画像を認識すると赤色の立方体，うさぎの画像を認識すると青色の立方体を表示させることにします．


SimpleNftフォルダをコピーし，フォルダに含まれるC#スクリプトをARPictureCamera， シーンをARPictureSceneにファイル名を変更した状態を前提とします（詳細はNYARToolkit for Unityの導入を参照）．
パターンファイルの作成  上記の２種類の画像から，マーカーのパターンファイルを作成します． パターンファイルの作成には，NyARToolkitのパッケージに含まれるNftFileGeneratorを利用します （詳しくはNyARToolkit Projectを参照）． [Data]-[Tools]にあるNftFileGeneratorをダブルクリックするとプログラムが起動します． importをクリックし，特徴点を抽出したいJPGやPNGなどの画像を指定します（透過より背景白の方が認識精度が高いようです）． 次に，Make Feature Setをクリックし，特徴点を抽出します． このとき，Source DPIやIset DPIsなどのパラメータは特に変更する必要はないようですが， 特徴点数が多すぎたり，少なすぎる場合にはFSET parameterを調節すると良いようです．

抽出されたパターンは赤い四角や青い円で表示されます． パターンを保存するにはExportをクリックし，適当なファイル名で保存します． ここでは，「犬の画像」のパターンファイルをpatt_001.bytes， 「うさぎの画像」のパターンファイルをpatt_002.bytesというファイル名で保存します． これらのパターンファイルは，AssetsのResourcesフォルダにコピーしておきます．


マーカーオブジェクトの作成  SimpleNftはマーカーを認識すると赤色の立方体を表示します． ここでは，２種類のマーカーに応じて，赤色の立方体に加え，青色の立方体を作成しておきます．
まずは，シーンのARPictureSceneをダブルクリックし，HierarchyにあるMarkerObjectを複製します． スクリプトからこれのオブジェクトを操作するため，２つのマーカーオブジェクトには共通のタグ（Tag）を設定します （Gameobject.FindGameObjectsWithTag(String tag)メソッドでタグからオブジェクトを取得することが可能）． タグ名は自由に設定することができますが，ここではMarkerObjectとしておきます．

次に，Assetsで赤色と青色のマテリアルを作成します． [Create]-[Materials]をクリックしてマテリアルを作成し，Albedoに赤色と青色を設定します． ここでは，マテリアルの名前をRedとBlueにしておきます． これらのマテリアルはMarkerObjectの直下にあるCubeのMaterialsに設定しておきます．

マーカーが認識されたときに表示されるのは，上記のCubeオブジェクトです． Cubeの**サイズ（Scale）や位置（Position）**はマーカーの大きさに合わせて調整する必要がありますが， ここでは，サイズの値をX=80，Y=80，Z=80，位置をX=-80，Y=80，Z=40に修正しておきます．

スクリプトの修正  最後にC#スクリプトのARPictureCameraを修正します．
まずは，2つのマーカーオブジェクトを配列で取得します． マーカーオブジェクトはMarkerObjectというタグが設定されていることを利用します．</description>
    </item>
    
    <item>
      <title>NyARToolkit for Unityで画像を表示</title>
      <link>https://mukai-lab.info/pages/tech/unity/artoolkit2/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://mukai-lab.info/pages/tech/unity/artoolkit2/</guid>
      <description>
画像の準備  NyARToolkitのパッケージに含まれる サンプルSimpleLiteはマーカーを検出すると赤色の立方体（Cube）を表示するプログラムです． このSimpleLiteを修正し，一般的なJPGやPNGなどの画像を立体的に表示できるよう改良します．
SimpleLiteフォルダをコピーし，フォルダに含まれるC#スクリプトをARPictureCamera， シーンをARPictureSceneにファイル名を変更した状態を前提とします （詳細はNyARToolkit for Unityの導入を参照）．
立方体の代わりに表示する犬の画像（001.png）は下記です． この画像は，テンプレートBANKを参考に，本学の学生が作成しました． 画像サイズは300x300ピクセル，画像フォーマットは透過背景のPNGです．

まずは，新規にanimalsフォルダを作成し，上記の画像をコピーしておきます． 対象のフォルダには，C#スクリプトのARPictureCamera，シーンのARPictureScene， 画像フォルダのanimalsが含まれる状態になっていることを確認してください．

テクスチャの利用  立方体（Cube）に犬の画像（001.png）をテクスチャとして貼り付けることで， マーカーを検出すると犬の画像を立体的（マーカーから少し浮いた状態）に表示してみます．
まずは，Assetsフォルダで[Create]-[Materials]を選択し，新規にマテリアルを作成します． マテリアルの名前はDogに変更しておきます． 画像フォーマットが透過背景であることから，InspectorでShaderをUnit/Transparentに設定します． Unit/Transparentはテクスチャ画像のアルファ値を反映して透過にすることが可能なシェーダーです． 次に，Textureを犬の画像に変更します これで，オブジェクトに設定するマテリアルが準備できました．


次に，シーンのARPictureSceneをダブルクリックします． ここで，Hierarchyから[Create]-[3D Object]-[Cube]を選択し，新規に立方体（Cube）のオブジェクトを作成します． オブジェクトの名前はDogObjectに変更しておきます． このDogObjectをドラッグして，MarkerObjectの直下に配置します． このとき，デフォルトで設定されている，Cubeオブジェクトは削除しておきます．
DogObjectのInspectorから，オブジェクトの**位置（Position）やサイズ（Scale）**を修正します． 位置はX=0，Y=0，Z=20とし，サイズはX=80，Y=80，Z=0とします（Z=0とすることで幅がなくなり平面となります）．

最後に，DogObjectのMaterialsをクリックして，作成したDogを選択しておきます． 再生ボタンをクリックすると，犬の画像（001.png）が表示されることを確認してください． テクスチャ画像が上下反対に張り付けられる場合は， TilingのYの値を**-1**に変更します（Direct3DかOpenGLで振る舞いが異なるようです）．


次回は画像の代わりに3Dオブジェクトを表示することにに挑戦してみます．
参考書籍</description>
    </item>
    
    <item>
      <title>NyARToolkit for Unityの導入</title>
      <link>https://mukai-lab.info/pages/tech/unity/artoolkit/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://mukai-lab.info/pages/tech/unity/artoolkit/</guid>
      <description>NYARtoolkitとは  ARToolkitをベースに開発された拡張現実ライブラリが**NyARToolkit**です． ゲーム開発環境である**Unity**で利用可能な**NyARToolkit for Unity**の導入方法を紹介します． ここでは，**Unity**のバージョンは**5.3.5**，**NyARToolkit for Unity** **のバージョンは**5.0.8**を対象とします． また，NyARToolkitのライセンスは**LGPLv3**となっています（商用ライセンスもあるようです）． このライセンスは，「著作権の表示」を条件に，商用利用や配布が認められています（詳細はWikipediaを参照）．
プロジェクトの作成  Unityで新しいプロジェクトを作成します． ここでは，プロジェクト名を「ARPictureBook」としています． また，ゲーム環境は「3D」を選択しておきます．

次に，「NyARToolkit for Unity」のパッケージをインストールします． パッケージは下記URLからダウンロードできます．
https://github.com/nyatla/NyARToolkitUnity/releases
ツールバーから[Assets]-[Import package]-[Custom package]をクリックして， ダウンロードしたパッケージを選択します． ファイルの読込み後に，ダイアログが表示されたら， 全てのファイルにチェックを入れた状態でimportをクリックしましょう．

ファイルの取り込みが終わると，プロジェクトのAssetsには6つのフォルダが展開されます． Assetとは，ゲームを構成する最小の構成単位のことです． 例えば，シーン，キャラクター，画像ファイル，音楽ファイルなどもAssetです． ここでは，sampleフォルダに含まれるSimpleLiteを試しに実行してみましょう．

SimpleLiteを実行する前に下記の準備が必要です． ウェブカメラは標準的なモノであれば問題ないと思われます． また，マーカーはパッケージに付属しているMarkerHiro.pngを利用しますが， NyARToolkit用のマーカーは，tarotaroorg氏が公開している オンラインのツールを利用して，自由に作成することも可能です．
 ウェブカメラ（CMS-V30SETBKを使用） マーカーが印刷された紙（resourceフォルダに含まれるMarkerHiro.pngを印刷します）  
準備が整ったら，画面上部にある再生ボタンをクリックします． すると，ゲーム画面にカメラ映像が映し出されます． このカメラにマーカーを印刷した紙を映すと，マーカー上に赤色の立方体（Cube）表示されることを確認してください． これが，拡張現実と呼ばれる技術です．


フォルダのコピー  Assetsフォルダに新規フォルダを作成し，SimpleLiteのフォルダに含まれる２つのファイルをコピーします（ARCameraBehaviorはC#のスクリプト，simpleLiteはシーンと呼ばれるファイルです）． ここでは，C#スクリプトをARPictureCamera，シーンをARPictureSceneにファイル名を変更しておきます． 次に，ARPictureSceneをダブルクリックし，HierarchyのCameraをクリックします． シーンに関連付けられたコンポーネントが表示されているので， ARCameraBehaviorを削除（Remove Component）します． さらに，Add Componentをクリックし，コピーしたARPictureCameraを選択しておきます． これで，ARPictureCameraに記述したスクリプトが，ARPictureSceneに関連付けられます．


しかし，このままではARPictureCameraがエラーとなり実行できません． これは，変更したファイル名とスクリプトのクラス名が一致しないことが原因です． そこで，ARPictureCameraのソースコードを表示し， クラス宣言部にあるクラス名を，ARCameraBehaviorからARPictureCameraに修正し，エラーを取り除きましょう． 最後に，再生ボタンをクリックして，SimpleLiteと同様の実行結果になることを確認してください．</description>
    </item>
    
    <item>
      <title>Onsen UI(1) コンポーネント</title>
      <link>https://mukai-lab.info/pages/classes/graduation_preperation_1/chapter1/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://mukai-lab.info/pages/classes/graduation_preperation_1/chapter1/</guid>
      <description>HTML5とは  HTML5とは -- HTML5とは，HTML(Hyper Text Markup Language)のバージョン5のことを指し， W3C(World Wide Web Consortium)と呼ばれる非営利団体が2014年10月28日に勧告した技術のことです． HTML5では，文書構造を表すタグが追加されており，例えば，ヘッダを表すheaderタグ，フッタを表すfooterなどが利用できます． また，動画や音声などのマルチメディアファイルも，Flashなどのプラグインを必要とせず， videoタグや，audioタグを利用してページに埋め込むことが可能になりました． その他，ブラウザにデータの保存が可能なWeb Storage， サーバー・クライアント間の双方向通信が可能なWeb SocketなどもHTML5の一部として認識されています．
HTML5ハイブリッドアプリとは -- HTML5ハイブリッドアプリとは  スマートフォンに搭載されているiOSやAndroidは， ウェブブラウザのようにウェブページを取得・表示するための，Web Viewという機能が利用できます． この，Web Viewを利用して，HTML，CSS，JavaScriptなどの技術で， ネイティブ・アプリと同等の機能を提供する方法がHTML5ハイブリッドアプリです． 一般に，ネイティブ・アプリを開発するには，iOSであればObjective-CやSwift， AndroidであればJavaで実装する必要があり，学生が気軽に開発を初めることは困難です． 一方，HTML5ハイブリッドアプリであれば，ウェブページを制作するための技術が中心であり， HTMLの基本を学んでいれば取り組むことが可能です． 本授業では，HTML5ハイブリッドアプリのプラットフォームであるMonacaを利用して， 様々なアプリを開発するためのプログラミング技術を身に着けます．
Monaca -- Monaca  Monacaはアシアル株式会社が提供する HTML5ハイブリッドアプリ専用の開発プラットフォームです． Chromeで動作するクラウドサービスとして提供されているため， ウェブに接続出来る環境であれば，どこでも開発が可能という特徴があります （Monaca Localkitを利用すればローカルの環境でも開発可能）． Apacheが提供しているハイブリッドアプリのフレームワークである **Cordova**を採用しているため，ネイティブ・アプリと同様に， スマートフォンのカメラやセンサーの機能を利用することも可能です．
また，開発中のアプリをスマートフォンで動作テストすることが可能な Monacaデバッガーというアプリを利用することが可能です． iOS版，Android版がともにリリースされており，アプリ・マーケットから取得が可能です． ブラウザのプレビューでは動作するけど，スマートフォンでは動作しないという現象が， まれに発生するので，こまめにMonacaデバッガーで動作確認すると良いでしょう． 加えて，Monacaデバッガーにはチャットやスクリーンショットなどのコミュニケーション機能が搭載されており， チームでのアプリ開発もサポートしてくれます（有料のようですが）． ブラウザでMonacaを開く前に，Monacaデバッガーを自身のスマートフォンにインストールしておきましょう．
プロジェクトの作成 -- プロジェクトの作成  Monacaを開き，ログインしてみましょう． このとき，ブラウザはChromeを利用することに注意してください （IEなど他のブラウザでの動作は保証されていないようです）． ログインすると下図のようにプロジェクトを管理するためのダッシュボードが表示されます． プロジェクトはプロジェクト名，プロジェクトの説明に加え，タグを付けて管理することができます．

今回は，Onsen UI ver.2というSPA（Single Page App）の フレームワークを利用して簡単な自己紹介アプリを作成してみましょう． Onsen UI ver.</description>
    </item>
    
    <item>
      <title>Onsen UI(2) テキスト入力</title>
      <link>https://mukai-lab.info/pages/classes/graduation_preperation_1/chapter2/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://mukai-lab.info/pages/classes/graduation_preperation_1/chapter2/</guid>
      <description>Onsen UIとは -- Onsen UIとは  Onsen UIはアシアル株式会社が提供するSPA(Single Page App)のためのフレームワークです． このOnsenという名称は，英単語Spaの日本語訳が温泉であることから名付けられたようです． 旧バージョンの1.0は，GoogleのフレームワークであるAngularJSに依存していましたが， 最新バージョンの2.0では依存を切り離すことで，AngularJSだけでなく， ReactやVue.jsなどのフレームワークでも開発が可能になりました． 本授業では，最新のバージョン2.0を採用しますが， 特定のフレームワークは用いず，標準的なJavaScriptで実装することを基本とします．
プロジェクトの作成 -- プロジェクトの作成  今回は，テキスト入力の機能を利用して，クイズアプリを作成してみましょう． ダッシュボードから【新規プロジェクトの作成】-【Onsen UI】-【Onsen UI V2 JS Navigation】を選択します． プロジェクト名をクイズアプリ，説明をテキスト入力を利用したクイズアプリとします． プロジェクトを作成したらMonacaクラウドIDEの画面を開きましょう．

テキスト入力 -- テキスト入力  最初にindex.htmlのpage1.htmlを下記のように修正していきましょう （基本構造は「Onsen UI(1) コンポーネント」を参照）．
 テキスト入力にはons-inputタグを利用します． ここでは，id属性にanswer，modifier属性にunderbarを設定しています． modifier属性は，コンポーネントの外見を設定するために用いられます． ons-inputタグであれば，マテリアルデザインのmaterialと， 下線が表示されるunderbarの２種類が設定可能です．
このテキスト入力にクイズの答えを入力し，回答ボタンをクリックすると， 入力された答えが正しいかを判定し，それぞれ正解，または，不正解ページに遷移することにします． ここで，正解のページはpage2.html，不正解のページはpage3.htmlとします．
-- 
次に，ons-templateタグと，ons-pageタグを利用して， 正解と不正解のページを下記のように作成します． page2.htmlは入力された回答が正解のときに表示されるページです． ツールバーに正解，中央にpタグで「向先生は射手座です！」と表示します． また，page3.htmlは入力された回答が不正解のときに表示されるページです． ツールバーに不正解，中央にpタグで「向先生は違う星座だよ！」と表示します．
 -- 
-- 
最後にscript要素のJavaScriptのコードを下記のように修正します． フォームに入力されたテキストは**getElementById()**関数でID属性を参照して取得します．
var answer = document.getElementById(&amp;#34;answer&amp;#34;); 次に，if文を利用して，入力されたテキストが射手座と一致するときに， page2.htmlに遷移し，一致しないときは，page3.htmlに遷移するようにします． ここで，ページの遷移は**pushPage()**関数を利用していることに注意してください．</description>
    </item>
    
    <item>
      <title>Onsen UI(3) テーマローラー</title>
      <link>https://mukai-lab.info/pages/classes/graduation_preperation_1/chapter3/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://mukai-lab.info/pages/classes/graduation_preperation_1/chapter3/</guid>
      <description>Onsenテーマローラーとは -- テーマローラーとは  Onsen UIでは Onsenテーマローラー というテーマ機能を利用できます． CSSファイルを直接編集しなくても，Onsenテーマーローラーで，各コンポーネントのデザインを変更することが可能です． また，Onsen UIを利用したデザインパターン（プロフィールやコンタクトリストなど）も用意されており， デザインパターンのソースコードを参考にしながら，オリジナルのデザインが可能です． アプリのデザインは個人のセンスが問われる要素です． 一からデザインを組み立てるよりも既存のデザインを流用する方が簡単かつ美しくなることが多いです．
プロジェクトの作成 -- プロジェクトの作成  今回は，Onsenテーマローラを利用しながら，お店紹介アプリを作成してみましょう． ダッシュボードから【新規プロジェクトの作成】-【Onsen UI】-【Onsen UI V2 JS Minimum】を選択します． プロジェクト名を お店紹介アプリ ，説明を Onsenテーマローラーを利用したお店紹介アプリ とします． プロジェクトを作成したら MonacaクラウドIDE の画面を開きましょう．

デザインパターンの利用 -- デザインパターンの利用  今回は， Onsenテーマローラー にリストアップされているパターンの中から， 「Shop Details」を利用します． まずは， Show Source をクリックして，ソースコードを表示します． 表示されたダイアログの左には HTML ファイルのソースコード， 右には CSS ファイルのソースコードが表示されます． そこで，この HTML ファイルのソースコードの body 要素をコピーして， お店紹介アプリ の index.html の body 要素を上書きします．

すると，プレビュー表示は下記のようになります． 次に， CSS ファイルのソースコードを全てコピーして， お店紹介アプリ の css/style.</description>
    </item>
    
    <item>
      <title>Onsen UI(4) ジェスチャー操作</title>
      <link>https://mukai-lab.info/pages/classes/graduation_preperation_1/chapter4/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://mukai-lab.info/pages/classes/graduation_preperation_1/chapter4/</guid>
      <description>ジェスチャー操作とは -- ジェスチャー操作とは  スマートフォンなどの画面に対して，指やタッチペンなどで行う動作が ジェスチャー操作 です． 例えば，画面を１回叩く操作を タップ（Tap） ，画面を平行に動かす操作を スワイプ（Swipe） と呼びます． Onsen UIでは ons-gesture-detector 要素を利用することで，ジェスチャー操作を検出することができます． また，Onsen UIにおけるジェスチャー操作の検出は，HAMMER.JSのカスタマイズ版をベースにしているとのことです．
プロジェクトの作成 -- プロジェクトの作成  今回は，ジェスチャー操作を利用した簡単なゲームを作成してみましょう． 特定のジェスチャー操作をすることで，ブロック要素（div要素）を消去するゲームです． ダッシュボードから【新規プロジェクトの作成】-【Onsen UI】-【Onsen UI V2 JS Minimum】を選択します． プロジェクト名を ジェスチャー・ゲーム ，説明を ジェスチャー操作を利用したゲームアプリ とします． プロジェクトを作成したら MonacaクラウドIDE の画面を開きましょう．

ブロック要素とイベントの検出 -- ブロック要素とイベントの検出  ここでは，下記表の３つのジェスチャー操作を検出することとします．
   ジェスチャー イベント名 説明     タップ tap 画面を１回叩く   ホールド hold 画面を長く押す   スワイプ swipe 画面に平行に動かす    まずは，イベントを処理するためにjQueryを導入します． ツールバーから [設定]-[JS/CSSコンポーネントの追加と削除] をクリックします． 次に，コンポーネントの一覧から jQuery(Monaca Version) を選択し 追加 をクリックします． これで，対象のプロジェクトで jQuery が利用可能になります．</description>
    </item>
    
    <item>
      <title>OpenCVを利用した視線位置の描画</title>
      <link>https://mukai-lab.info/pages/tech/eyetracker/eyetracker2/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://mukai-lab.info/pages/tech/eyetracker/eyetracker2/</guid>
      <description>OpenCVとは  前回はTobii Eye Tracker 4Cを利用して， ディスプレイに対する視線の位置を検出しました． 今回は画像処理ライブラリのOpenCVを利用して， 視線位置に合わせてウィンドウに図形を描画することに挑戦します． OpenCVは，インテル が開発したオープンソースのライブラリであり， 画像処理に関する様々なアルゴリズムを容易に実装することができます（2016年にインテルがItseezを買収）． また，C/C++，Java，Python，MATLAB のライブラリとして配布されており， プログラミング言語を問わず利用できることも魅力です．
図形描画の実装  前回までにライブラリの導入は完了しているので，今回はウィンドウを表示するところからスタートしましょう． ファイル名は MyEyeTrack2.py とします． まずは，OpenCV(cv2) と NumPy のモジュールをインポートします． ここで，NumPy には，np という別名を付けていることに注意してください．
 最初に，np.zeros メソッドを用いて，幅1980px，高さ1080pxの黒色の画像を生成します． このメソッドは値が0の配列を返値とし，引数には配列の長さを表す タプル と データタイプを渡します． ここでは，8ビットの符号なし整数（0~255）であるnp.unit8をデータタイプとしています． この画像を imshow メソッドで表示します． 第1引数の &amp;ldquo;MyEyeTrack&amp;rdquo; はウィンドウのタイトルバーに表示される文字列です．
 前回実装したコールバックメソッドを修正し，視線位置に白色の円を描画するように改良します． 左右の視線位置の平均値を円の中心座標とします． コールバックメソッドで取得される視線位置は， 標準化された値のためウィンドウのサイズを掛けて，ピクセル座標に変換しています． このとき，y座標はウィンドウのタイトルバーの幅を考慮して，50 だけ減らしています （本当はキャリブレーションをやらなきゃいけないけど）． 円を描くには，cv2.circle メソッドを利用します． 引数には，画像，中心座標，半径，色，枠線の太さ を指定します． ここで，枠線の太さに負の値を指定すると，塗りつぶしの円になります． また，global はグローバル変数の img を用いることの宣言です．
 上記で実装したコールバックメソッドをEyeTrackerオブジェクトに登録します．
 最後にwhile文でimshowメソッドを呼び出し，画像の再描画を繰り返します． ここでは，100ms毎に画像を描画しています． このとき，ESCキー が押されると，ループを終了し， コールバックメソッドの解除，ウィンドウの破棄，システムの終了を行います．
 では，プログラムを実行してみましょう． ここでは，四角形を描くように視線を動かしてみました． 視線に合わせて白い円が描画されていることが分かります． しかし，思っていたより視線を安定させるのは難しいです．</description>
    </item>
    
    <item>
      <title>OpenCVを利用した顔検出</title>
      <link>https://mukai-lab.info/pages/classes/programming_1/chapter11/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://mukai-lab.info/pages/classes/programming_1/chapter11/</guid>
      <description>スケッチの作成  Processingを起動して，新規にスケッチを保存しましょう． メニューから[ファイル]-[名前を付けて保存]をクリックして，「スケッチフォルダを名前を付けて保存」を開きます． ファイル名に「Project11」を入力し，[保存]をクリックしましょう． 保存先に「Project11」という名前のフォルダが作成されていることを確認してください．

OpenCVの導入  インテルが開発したオープンソースのライブラリである OpenCV を導入することで， 画像処理・画像解析など様々な機能を利用することが可能となります． ここでは，Processing用の OpenCV を導入して，顔検出を試みてみましょう． まずは，メニューから[スケッチ]-[ライブラリをインポート]-[ライブラリを追加]をクリックして， 「Contribution Manager」を開きます． ここで， opencv をキーワードに検索すると， 「 OpenCV for Processing | Computer vision with OpenCV. 」が表示されるので， このライブラリを選択してインストールしましょう．

次に，[スケッチ]-[ライブラリをインポート]-[OpenCV for Processing]をクリックして，OpenCVライブラリをインポートします． また，同様にVideoライブラリをインポートしてください． ソースコードの先頭に「 import gab.opencv.∗ 」と「 import processing.video.∗ 」が 表示されていることを確認してください．
 カメラ映像の表示  Capture クラスを利用して，カメラから入力した画像を表示しましょう． 下記を参考にコードを入力したら，Runボタンをクリックしてください． ここでは， サイズ（size） が 320x240 ， フレームレート（fps） が 30 となっている， 3番のカメラを使用していることに注意してください． ウィンドウにカメラ映像が表示されることを確認してください．
 
顔位置の検出  顔位置の検出には OpenCV クラスを利用して下記のように記述します． 例えば， OpenCV.</description>
    </item>
    
    <item>
      <title>Processingではじめての画像処理</title>
      <link>https://mukai-lab.info/pages/tech/processing/processing/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://mukai-lab.info/pages/tech/processing/processing/</guid>
      <description>Processingとは  Processingは，2001年からMIT Media Labでスタートしたオープンソースのプロジェクトです． 当初からプログラミング教育を意識して開発され，初学者でも視覚的なコンテンツ（ビジュアルコンテンツ）を容易に作成できることが大きな特徴です． デザイナーや建築家などの利用も多く，作品はニューヨーク近代美術館など多くの著名な美術館で公開されています． オープンソースであることにもこだわりが強く，活発なコミュニティが形成されており，ソフトウェアを拡張するためのライブラリやツールが多く提供されています． ウィンドウズ，マッキントッシュ，リナックスなどのプラットフォームで動作可能であり，公式サイトから無料でダウンロードすることができます． また，ProcessingはJavaをベースに開発されており，Javaによく似た文法でコードを記述できることも人気の高い理由です．
Processingの開発環境  前節で述べたように様々なプラットフォームで動作可能なパッケージが配布されていますが， 今回はオンラインでコーディングが可能なOpenProcessingを利用してみましょう． このサイトでは，Processingで制作した作品（スケッチ）を公開することができます． また，登録も無料で誰でも利用することが可能です． では，下記のリンクをクリックしてOpenProcessingのサイトを開きましょう．
OpenProcessing
残念ながら現在は英語のサイトしか存在せず，ユーザ同士の交流は英語が中心です． 一方で，日本語でコメントを記述することは問題ないようです． Processingに慣れてきたらオリジナルの作品を投稿することを目指しましょう．

まずは，公開されているスケッチを閲覧してみましょう． 「Activity」のタブをクリックすると，右下に評価の高い作品の一覧が表示されます． これらのスケッチはOpenProcessingの登録者が制作した作品です． 自由にスケッチを選んでプログラムを実行してみましょう． 下記のは2017日6月9日現在のスケッチのリストです．

幾つか人気のある作品を取り上げてみましょう． まずは，aadebdeb氏のrainbow spinという作品です． マウスの動きに合わせて，描かれている虹色の渦巻きの回転方向や倍率が変化します．
 次は，Victor Galve氏のPractica 2という作品です． マウスでクリックすると，様々な色や形の花火が打ちあがります．
 最後は，Raven Kwok氏のNoise Turbulence Doodlesという作品です． マウスをドラッグすると円が重なりながら奇妙な形に成長します．
 スケッチの作成  新しいスケッチを作成してみましょう． サイトのトップから「+Create a Sketch」をクリックしてください． 下記のようにソースコードを入力する画面になります（デフォルトで記述されているコードは削除しておきましょう）． ソースコードを記述した後で，をクリックすると，記述されたコードを実行することができます．

Processingをウェブ上で実行するには「P5js」，または，「Processing.js」というライブラリを利用します． 今回は後者の Processing.js を利用するため，画面右の Settings で， Mode を Processing.js に変更してください．

図形を描く前に，スケッチの大きさや背景色を設定しましょう． スケッチの大きさは300x300ピクセル，背景色は白にします． 大きさを設定するにはsize(幅,高さ)，背景色を設定するにはbackground(色)と記述します（255は白色を意味します）． 下記のソースコードを入力したら，をクリックしましょう． 背景色が白色のスケッチが表示されます（300x300ピクセルのスケッチが中央に配置されています）． （「//」が先頭にある文章はコメントと呼ばれ，プログラムとは認識されません） もとのソースコードの入力画面に戻るにはをクリックします．</description>
    </item>
    
    <item>
      <title>Processingの開発環境の確認</title>
      <link>https://mukai-lab.info/pages/classes/programming_1/chapter1/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://mukai-lab.info/pages/classes/programming_1/chapter1/</guid>
      <description>Processingとは  Processing は，大学院生だったBenjamin FryとCasey Reasが2001年にMIT Media Labでスタートしたオープンソースのプロジェクトです． 当初からプログラミング教育を意識して開発され，初学者でも視覚的なコンテンツ（ビジュアルコンテンツ）を容易に作成できることが大きな特徴です． 一方で，デザイナーや建築家などの利用も多く，作品はニューヨーク近代美術館など多くの著名な美術館で公開されています． オープンソースであることにもこだわりが強く，活発なコミュニティが形成されており，ソフトウェアを拡張するためのライブラリやツールが多く提供されています． ウィンドウズ，マッキントッシュ，リナックスなどのプラットフォームで動作可能であり，公式サイトから無料でダウンロードすることができます． また，ProcessingはJavaをベースに開発されており，Javaによく似た文法でコードを記述できることも人気の高い理由です．
 オープンソース プログラミング教育に最適 ビジュアルコンテンツの作成が容易 Javaによく似た文法  Processingの開発環境  Processing 自体が統合開発環境であるため，開発するために他のソフトウェアを必要としません． Processingを拡張するためのプロジェクトは多く存在し，最新のウェブ環境（HTML5）で視覚的なプログラミングが可能なProcessing.js，AR（拡張現実）を実現するためのNyARToolkitなど応用範囲は幅広いです．
Processingを起動すると下記のメイン画面が表示されます（バージョンは 3.02 ）． メイン画面はシンプルに構成されており，標準的なメニューバーとツールバーに加え，ソースコードを編集するためのエディタ，プログラムのエラーを確認するためのコンソールがあります． この画面でプログラムを作成し， Runボタン をクリックするだけで，実行結果を確認することができます．

スケッチの作成  Processingは スケッチ という単位でプログラムを作成します（保存する前のファイル名は「sketch_日付a」）． まずは，スケッチを保存する場所を設定しましょう． メニューから[ファイル]-[設定]をクリックして，「設定」を開きます． ここで，スケッチブックの場所を「 H:\MyProcessing 」に変更しましょう（ドライブは環境に合わせて変更してください）． このとき，スケッチブックの場所は日本語名のフォルダを含まないようにする必要があります．

次に，スケッチを保存してみましょう． メニューから[ファイル]-[名前を付けて保存]をクリックして，「スケッチフォルダを名前を付けて保存」を開きます． ファイル名に「Project1」を入力し，[保存]をクリックしましょう． 保存先に「Project1」という名前のフォルダが作成されていることを確認してください． また，このフォルダを開くと中に「Project1.pde」というファイルがあります． このファイルがProcessingのソースコードです．

コンソールへの出力  コンソールに文字列を出力するにはprintln()という命令文を用います． ここでは，「Hello World!」という文字列をコンソールに出力してみます． 下記を参考にコードを入力したら，Runボタンをクリックしてください． 命令文の最後にはセミコロン（;）が必要なことに注意してください． コンソールに「Hello World!」が出力されていることを確認してください．

もし入力したコードにエラーがある場合は，エラータブに切り替えることで，エラーの詳細を確認することができます． 例えば，下記のコードの場合は「Missing right parenthesis &amp;ldquo;)&amp;quot;」と表示されます．

課題  println()を使用して，「本日の授業の感想」をコンソールに出力させてください． 課題が完成したら，作成したスケッチを ZIPアーカイブ 形式で保存します． ZIPアーカイブを作成するには，メニューから[ツール]-[スケッチをアーカイブ]をクリックして，「スケッチを名前を付けてアーカイブする」を開きます． 保存するファイル名を確認した上で，[保存]をクリックします． 保存先に「Project1-日付a.</description>
    </item>
    
    <item>
      <title>QRコードの読み取り</title>
      <link>https://mukai-lab.info/pages/tech/robohon/robohon3/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://mukai-lab.info/pages/tech/robohon/robohon3/</guid>
      <description>ロボホンのカメラ  ロボホンの開発キットRoBoHoN Software Development Kitに 同梱されているカメラ用のアプリ SampleCamera を基にQRコードの読み取り機能を実装します． QRコードの読み取りには，オープンソースとして提供されているZXingを採用します． ちなみに， ZXing の名称は Zebra Crossing が基になっているようです． ZXing の実装方法はNAVERまとめの記事「Java QRコード読み取り」を参考にし， ライブラリはMaven RepositoryからダウンロードしたJARファイルを利用します． 現時点での最新バージョンは 3.3.0 です（2017年9月20日現在）．
カメラの利用  まずは，SampleCamera のプロジェクトを Android Studio で開き確認しましょう． MainActivity.javaがこのサンプルの中心となるソースファイルです．
ロボホンのカメラを利用した撮影には，静止画，動画，また，顔認識の有無などの設定が可能です． ここでは，写真撮影 顔認識無ボタン の挙動にQRコードの読み取り機能を加えます． 下記が該当部分のソースコードです． 背面のモニタにあるcameraButtonをタップすると，getIntentForPhoto メソッドの 返り値（Intent クラスのインスタンス）が，sendBroadcast メソッドで通知される処理となっていることが分かります．
 次に，getIntentForPhoto メソッドを確認します． ここで，登場する ShootMediaUtil クラスが重要な役割を担います． Intent クラスのコンストラクタの引数には静止画撮影用のアクション名であるShotMediaUtil.ACTION_SHOOT_IMAGEを指定します． また，アクション（撮影）終了後の結果通知を得るために，putExtraメソッドで ShotMediaUtil.EXTRA_REPLYTO_ACTIONを指定し， ACTION_RESULT_TAKE_PICTURE をその返り値としています． このインテントを sendBroadcast で通知することで，カメラの撮影機能が実行されます．
 カメラの撮影後には，結果通知として ACTION_RESULT_TAKE_PICTURE を CameraResultReceiver クラスの onReceive メソッドで受け取ります． ここでは，ACTION_RESULT_TAKE_PICTURE に該当するコードのみを抜き出してみます． 撮影が成功していれば，インテントから ShootMediaUtil.RESULT_OK を受け取り， 保存した画像ファイルのパスを取得します． 取得されたパスは，リソースIDを利用して，ロボホンの背面の TextView に表示されます．</description>
    </item>
    
    <item>
      <title>R言語によるデータの視覚化</title>
      <link>https://mukai-lab.info/pages/classes/advanced_studies_seminar_2/chapter3/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://mukai-lab.info/pages/classes/advanced_studies_seminar_2/chapter3/</guid>
      <description>データの可視化 -- データの可視化  データの特徴を理解するには，グラフなどを利用してデータを可視化することが重要です． R言語には散布図やヒストグラムなどで可視化するための機能がありますが， ここでは，よりリッチな可視化を実現するために，拡張パッケージのggplot2を採用します． ggplot2には，簡単に素早く描画するqplot関数と，複雑な描画が可能なggplot関数があります． 今回は，qplot関数に注目します．
スクリプトの作成 -- スクリプトの作成  コードを入力し保存するためのスクリプトを作成しましょう． [ファイル]-[新しいスクリプト]をクリックし，Rエディタを表示します． 次に，[ファイル]-[保存]をクリックして，スクリプトを保存します． このとき，ファイル名はchapter3としてください． また，ファイルの保存場所と作業ディレクトリをデスクトップに変更しておきます．
ggplot2のインストール -- ggplot2のインストール  まずは，ggplot2 パッケージをインストールしましょう． ツールバーから[パッケージ]-[パッケージの読み込み]をクリックし， パッケージの一覧からggplot2を選択します． これで対応するパッケージがダウンロードされます．

このパッケージを利用可能な状態にするには， library関数を利用します． ここでは，スクリプトに下記のように記述しておきます．
library(ggplot2) これで，ggplot2 を利用する準備が整いました．
ヒストグラム -- ヒストグラム  まず，ヒストグラム を描いてみましょう． 対象となるデータフレームは下記のように生成しましょう． ここで，data.frame は，引数のベクトルを列とするデータフレームを生成する関数です． また，value は列名を表しています．
y &amp;lt;- c(1,1,2,3,5,6,6,6,7,9) d1 &amp;lt;- data.frame(value=y) プロンプトでデータフレームd1 の要素を確認します． 要素はvalueの列だけで構成された１次元のデータとなります．
&amp;gt; d1 value 1 1 2 1 3 2 4 3 5 5 6 6 7 6 8 6 9 7 10 9 qplot() 関数を利用して，このデータフレームのヒストグラムを描きます． 引数には， Y軸の列名 ， data=データフレーム名 を与えます． ここでは，下記のように value， data=d1 が引数となります．</description>
    </item>
    
    <item>
      <title>R言語のデータ構造</title>
      <link>https://mukai-lab.info/pages/classes/advanced_studies_seminar_2/chapter2/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://mukai-lab.info/pages/classes/advanced_studies_seminar_2/chapter2/</guid>
      <description>データ構造 -- データ構造  一般にプログラミング言語には，整数型，実数型，文字列型などデータの型が存在します． データの型を調べるにはtypeof関数を使用します． プロンプトで下記のように入力してみましょう．
&amp;gt; typeof(10) [1] &amp;#34;double&amp;#34; &amp;gt; typeof(&amp;#34;a&amp;#34;) [1] &amp;#34;character&amp;#34; すると，10 は double型であることが分かります． このdouble型は実数であることを表しています． 同様に，a は character型であることが分かります． このcharacter型は文字（もしくは文字列）であることを表しています． これらのデータ型は自動的に設定されるため，普段は特に意識する必要はありません．
R言語では，これらの基本的なデータ型に加えて，数値処理に適したベクトル，行列，データフレーム といった構造が存在します． これらは，基本的に複数の値をまとめて処理するときに利用し，他のプログラミング言語における配列と同じような使い方をされます． 今回は，これらデータ構造に注目していきます．
スクリプトの作成 -- スクリプトの作成  コードを入力し保存するためのスクリプトを作成しましょう． [ファイル]-[新しいスクリプト]をクリックし，Rエディタを表示します． 次に，[ファイル]-[保存]をクリックして，スクリプトを保存します． このとき，ファイル名はchapter2としてください． また，ファイルの保存場所と作業ディレクトリをデスクトップに変更しておきます．
変数 -- 変数  上述した実数や文字列は変数と呼ばれるオブジェクトに記録し，参照することができます． 変数に値を代入するには，&amp;lt;- という演算子を利用します． スクリプトに下記を入力して，スクリプトを読み込み実行してください（実行は「source(&amp;ldquo;chapter2.R&amp;rdquo;)」）．
x &amp;lt;- 10 y &amp;lt;- 2 z &amp;lt;- x * y これで，変数x，y，zに，それぞれ値が代入されました． 変数に代入された値を確認するには，プロンプトで下記のように，変数名をそのまま入力します．
&amp;gt; x [1] 10 &amp;gt; y [1] 2 &amp;gt; z [1] 20 x に10， y に2，z に20が代入されていることが確認できます． このように，演算子**&amp;lt;-**の後方に，代入したい値や式を記述します．</description>
    </item>
    
    <item>
      <title>R言語の基本的な操作</title>
      <link>https://mukai-lab.info/pages/classes/advanced_studies_seminar_2/chapter1/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://mukai-lab.info/pages/classes/advanced_studies_seminar_2/chapter1/</guid>
      <description>R言語とは -- R言語とは  Rは，AT &amp;amp; Tベル研究所が開発したS言語を基本に開発された統計解析向けのプログラミング言語です． オープンソースとして開発されており，誰でも自由に利用，改変，再配布が可能なフリーソフトウェアです． 統計用のソフトウェアには，マイクロソフトのExcelや， IBMのSPSSなどがありますが， R言語はプログラミング言語として統計処理が可能なことが大きな特徴となっています． 一方でGUI（グラフィカル・ユーザ・インターフェイス）は弱く，文化系の学生には取っ付きにくい印象を与えるかもしれません． しかし，Rの基本を学べば，データマイニングなどの高度な統計解析手法を利用することが可能です． この授業ではRの基本から学び，多変量解析やデータマイニングなどの応用を学習することを目標とします．
R言語のインストール -- R言語のインストール  まずはRを公式サイトからダウンロードしてインストールしましょう． 現在のところ公式サイトは英語表記しかないので注意してください． この資料では，2017年3月8日の時点の最新バージョンであるR 3.3.3を利用して説明していきます． Rをインストールするとデスクトップに32ビット版の「R i386 3.3.3」と 64ビット版の「R x64 3.3.3」のショートカットが作成されます． 各自のPC環境に合わせてプログラムを実行してください． 実行すると下記のような「R console」というウィンドウが表示されます（ここでは64ビット版を使用）．

Rによる統計処理は，この「R console」に命令文を入力することが基本となります． 行頭の「&amp;gt;」はプロンプトと呼ばれ，この後にコマンド（命令）を入力して， エンターキーを押すとコマンドが実行されます． これを繰り返して，特定の処理を実現します．
四則演算 -- 四則演算  まずは，加算，減算などの算術演算を実行してみましょう． Rでは，下記表の算術演算子が利用可能です．
   演算 演算子 例     加算 + 2+3   減算 - 2-3   乗算 * 2*3   除算 / 2/3   べき乗 ^ 2^3   剰余 %% 2%%3    では，プロンプトの後に，「2 + 3」と入力してみましょう． すると下記のような加算の結果が得られます． ここで，[1]は出力される結果の1番目であることを意味しています． （今回は5のみが結果となるので，必然的に1番目になる）</description>
    </item>
    
    <item>
      <title>Tobii Eye Trackerを利用した視線の認識</title>
      <link>https://mukai-lab.info/pages/tech/eyetracker/eyetracker1/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://mukai-lab.info/pages/tech/eyetracker/eyetracker1/</guid>
      <description>Tobii Eye Trackerとは  近年，ユーザの視線を検出するアイトラッキングという技術が注目されています． アイトラッキングはマウスやキーボードの代替となりうるヒューマンインターフェイスの一つであり， 手足が不自由な障がい者のコミュニケーション装置としても活用されています． 光学センサーと画像処理技術を用いて，眼球の動き を解析することで， ユーザの注視点（見つめている場所）を推定する方法が一般的です． 今回は，トビー・テクノロジー株式会社が ゲーム用に提供しているEye Tracker 4Cという 視線入力装置を利用して，ユーザの視線を検出するプログラムを実装してみます． トビー・テクノロジーは自社の製品を利用したソフトウェアを開発するための Tobii Pro SDKを独自に提供していますが， Eye Tracker 4CでTobii Pro SDKを利用するためには， プロアップグレードキーが必要となることに注意が必要です （Tobii Core SDK や Tobii Gaming SDK という選択肢もありますが，研究やデータ分析を用途とする場合は Tobii Pro SDK を利用する必要があります）． また，開発用の言語には Python，Matlab，C，Unity などに対応していますが， ここでは，機械学習に適したPythonを採用します． Tobii Pro SDK のドキュメントが公開されおり，この情報を参考にしながら開発を進めることになります．

開発環境の準備  まずは，Pythonをインストールします． Pythonのバージョンには3.xと2.xの２通り存在しますが， Tobii Pro SDK に対応している 2.x を選択する必要があることに注意してください． ここでは，現時点での最新バージョンである2.7.14を利用します(2017年10月17日)．
Pythonの本体に加えて，画像処理ライブラリのOpenCVと， 数値計算ライブラリのNumPyを追加でインストールします． インストール方法はPythonのパッケージ管理システムであるpipを利用すれば簡単です． コマンドプロンプトで下記のように入力します． ここでは，3.3.0.10 のOpenCVと 1.13.3 のNumPyがインストールされました．
$ python -m pip install opencv-python Collecting opencv-python Downloading opencv_python-3.</description>
    </item>
    
    <item>
      <title>t分布を用いた検定</title>
      <link>https://mukai-lab.info/pages/classes/advanced_studies_seminar_2/chapter10/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://mukai-lab.info/pages/classes/advanced_studies_seminar_2/chapter10/</guid>
      <description>検定とは -- 検定とは  第8回で示したように，母数は標本からある程度は推定することができます． しかし，標本のサンプル数nが少ないときは， 標本分散から母分散を推定することは難しくなります． このため，前回学んだ 標準正規分布を用いた検定（Z検定） を適用することができません．
 母平均\hat{\mu}は標本平均\muで推定できる 母分散\hat{\sigma}^2は標本分散（不偏分散）\sigma^2で推定できる  そこで，利用するのがt検定です． t検定では，母分散の推定値に，標本分散を用いて検定を行います． すなわち，母分散\hat{\sigma}^2が未知の場合です． このような場合は，t分布 と呼ばれる正規分布によく似た釣鐘状の分布を利用します． 今回は，t検定 の基本を解説した上で，R言語の関数を利用した検定を行います．
スクリプトの作成 -- スクリプトの作成  コードを入力し保存するためのスクリプトを作成しましょう． [ファイル]-[新しいスクリプト]をクリックし，Rエディタを表示します． 次に，[ファイル]-[保存]をクリックして，スクリプトを保存します． このとき，ファイル名はchapter10としてください． また，ファイルの保存場所と作業ディレクトリをデスクトップに変更しておきます．
t検定 -- t検定  具体例として，前回と同じ問題を取り上げていきます． 前回と異なるのは母集団の分散が未知というところです．
文化情報学部の学生Xに情報数学に関するテストを行ったところ， その得点の平均\hat{\mu}は60であった． このうち，向研究室に所属する5人の学生xの得点は下記であった． 向研究室に所属する学生xは， 文化情報学部の学生Xと， 同様の傾向があるか（母集団からランダムサンプリングした学生だろうか）．
x = \{63,75,72,67,71\}   上記の問題を t検定 で考えます． 準備として，標本の分散を求めておきましょう．
x &amp;lt;- c(63,75,72,67,71) &amp;gt; var(x) [1] 21.8 母集団は「文化情報学部の学生X」， 標本は「向研究室に所属する学生x」と考えることができます． また，「標本平均の分布」をmとします． いずれも正規分布に従うと仮定すると，母集団の分布と，標本平均の分布は下記のようになります． ここで，母分散\hat{\sigma}^2は未知であることに注意してください．
X \sim N(60,\hat{\sigma}^2)  m \sim N(60,\hat{\sigma}^2/5)  帰無仮説 と 対立仮説 は前回と同じです． 信頼区間も前回と同じ「95%信頼度（5%棄却域）」を用いることにしましょう．</description>
    </item>
    
    <item>
      <title>アニメーション</title>
      <link>https://mukai-lab.info/pages/classes/applied_programming/chapter12/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://mukai-lab.info/pages/classes/applied_programming/chapter12/</guid>
      <description>プロジェクトの準備 --プロジェクトの準備  Eclipseで新規にプロジェクトを作成しましょう． メニューから[ファイル]-[新規]-[Javaプロジェクト]をクリックして，「新規Javaプロジェクトの作成」を開きます． ここでは，プロジェクト名に”Project12”を入力ます． また，JREは&amp;rdquo;プロジェクト固有のJREを使用&amp;ldquo;を選択します． 最後に，[完了]をクリックしましょう．

Applicationクラスを継承したMyApplicationクラスを作成しましょう． メニューから[ファイル]-[新規]-[クラス]をクリックして，「新規Javaクラス」を開きます． まず，名前に”MyApplication”を入力します． 次にスーパークラスを設定するために，[参照]ボタンから「スーパークラスの選択」を開き， 一致する項目からjavafx.application.Applicationを選択して，[OK]をクリックします． 最後に[完了]をクリックしましょう．

Applicationクラスの抽象メソッドであるstartメソッドをオーバーライドしておきます． 下記コードを参考に，タイトルをProject 12，幅を800px，高さを500pxに設定しましょう． プログラムの実行後にウィンドウが表示されることを確認してください．
 
プログラム実行時の注意  JavaFXはmainメソッドがなくともプログラムの実行が可能という特徴を持っています． しかし，Eclipseの現バージョンでは未対応のため，下記のコードをMyApplicationクラスに記述する必要があります． プログラム実行の前に，必ず下記のコードをソースコードに挿入してください．
 イメージの描画 --イメージの描画  今回はイメージをキャンバスに描画し，パラパラ漫画の要領でアニメーションさせることに挑戦していきましょう． 前準備として，下記のコードを参考にCanvasクラスをウィンドウに配置してください． レイアウトペインとしてVBoxクラスを利用しています． プログラムの実行後に表示されるウィンドウを確認してください．
 
まずは，下記の「歩いている女性のイメージ（png画像）」をキャンバスに表示してみます． この２つのイメージを交互に表示することで歩いている様子の表現が可能です． walking1.pngとwalking2.pngをダウンロードしたら， プロジェクトのsrcフォルダにコピーしてください．
 
保存したイメージを読み込むには，下記のようにImageクラスを利用します （Imageクラスのコンストラクタの引数には，画像ファイルの位置を表すURLを指定します）． ここでは，２つのイメージを利用するため，Imageクラスの配列walkingを宣言して， walking[0]にwalking1.png，walking[1]にwalking2.pngをそれぞれ読み込みます．
Image walking[] = new Image[2]; walking[0] = new Image(this.getClass().getResource(&amp;#34;walking1.png&amp;#34;).toString()); walking[1] = new Image(this.getClass().getResource(&amp;#34;walking2.png&amp;#34;).toString()); キャンバスにイメージを表示するには，GraphicsContextクラスのdrawImage()メソッドを利用します． drawImage()メソッドの３つの引数は，表示するイメージ，X座標，Y座標を表しています．
gc.drawImage(walking[0], 0, 0); 下記のコードを参考に，新たにpaint()メソッドを定義して，walking1.pngの画像を表示してください． プログラムの実行後に表示されるウィンドウを確認してください．</description>
    </item>
    
    <item>
      <title>アニメーションの表示</title>
      <link>https://mukai-lab.info/pages/classes/programming_1/chapter5/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://mukai-lab.info/pages/classes/programming_1/chapter5/</guid>
      <description>スケッチの作成  Processingを起動して，新規にスケッチを保存しましょう． メニューから[ファイル]-[名前を付けて保存]をクリックして，「スケッチフォルダを名前を付けて保存」を開きます． ファイル名に「Project5」を入力し，[保存]をクリックしましょう． 保存先に「Project5」という名前のフォルダが作成されていることを確認してください．

setupとdraw  アニメーションを制御するにはsetup()関数とdraw関数()が必要になります． setup()関数には，変数の初期化など，プログラムを実行したときに 1回だけ 実行する処理を記述します． 一方，draw()関数は，プログラムの実行中に 繰り返し 実行され，アニメーションなど何かを変化させるための処理を記述します． また，setup()関数とdraw()関数の外部で宣言された変数は両方の関数内で利用できます（ グローバル変数 と呼びます）． setup()関数とdraw関数()は下記のように記述します（ void は「この関数は返値をもたない」という意味です）．
void setup(){ 1回だけ実行する処理; } void draw(){ 繰り返し実行する処理; } ここでは，ウィンドウの中央に半径10の円を描いてみましょう． 変数の初期化はsetup()関数，円の描画はdraw()関数に記述していることに注意してください． 下記を参考にコードを入力したら，Runボタンをクリックしてください． ウィンドウの中央に円が描かれていることを確認してください．
 
直線運動 円が右方向に直線的に動くアニメーションを設定してみましょう． 右方向へのアニメーションは，draw()関数において，変数xの値を増加させることで表現できます． 下記を参考にコードを入力したら，Runボタンをクリックしてください． 複数の円が右方向に描画されることを確認してください．
 
しかし，上記のコードでは円が複数描画されてしまい，アニメーションしているように見えません． そこで，draw()関数の最初で，背景を灰色（#cccccc）で塗りつぶすことで，常に円が1つだけ描画されるように変更します． 下記を参考にコードを入力したら，Runボタンをクリックしてください． 1つの円が右方向に移動することを確認してください．
 
円がウィンドウの端に到達したら，跳ね返って逆方向に進むように修正しましょう． まずは，右端に到達したら，左方向に進むようにします． 円の速度を表す変数speedを宣言し，if文を利用してxの値が右端に到達したらspeedの正負を反転します． 下記を参考にコードを入力したら，Runボタンをクリックしてください． 円が右端に到達すると跳ね返ることを確認してください．
 
同様に，左端に到達したら，右方向に進むようにします． if文を利用してxの値が左端に到達したらspeedの正負を反転します． 下記を参考にコードを入力したら，Runボタンをクリックしてください． 円が左端に到達すると跳ね返ることを確認してください．
 
円運動 次は，円運動するアニメーションを設定してみましょう． 円運動を表現するにはsin()関数とcos()関数を利用します． sin()関数とcos()関数の引数には 角度 を指定しますが， ラジアン角を用いることに注意が必要です（ラジアン角は $0$ から $2\pi$ ）．</description>
    </item>
    
    <item>
      <title>イベント処理</title>
      <link>https://mukai-lab.info/pages/classes/programming_1/chapter6/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://mukai-lab.info/pages/classes/programming_1/chapter6/</guid>
      <description>スケッチの作成  Processingを起動して，新規にスケッチを保存しましょう． メニューから[ファイル]-[名前を付けて保存]をクリックして，「スケッチフォルダを名前を付けて保存」を開きます． ファイル名に「Project6」を入力し，[保存]をクリックしましょう． 保存先に「Project6」という名前のフォルダが作成されていることを確認してください．

マウスイベント  Processingではマウスイベントを検出するために下記表の関数が用意されています． これらの関数内に，実行したい内容を記述することで，マウスイベントに対応した処理が可能になります． また，これらのイベントの結果を反映させるには，draw()関数の記述が必要なことに注意してください．
   関数名 イベント     mouseMoved() マウスボタンを押さずに動かしたとき   mouseDragged() マウスボタンを押しながら動かしたとき   mousePressed() マウスボタンを押したとき   mouseReleased() マウスボタンを離したとき    ここでは，mouseMoved()関数を利用して，マウスの軌跡を描画してみましょう． ウィンドウ内のマウスの位置は変数 mouseX と mouseY で取得可能です． マウスの動きを検知したら，半径3の塗りつぶし円を描きます． 下記を参考にコードを入力したら，Runボタンをクリックしてください． マウスの動きに合わせて，軌跡が描かれることを確認してください．
 
次に，MousePressed()関数を利用して，マウスボタンを押したとき（クリックしたとき）に， 赤色の正方形を描画してみましょう． 下記を参考にコードを入力したら，Runボタンをクリックしてください． マウスの位置に合わせて，正方形が描かれることを確認してください．
 
今度は，mousePressed()関数とmouseDragged()関数を組み合わせてみましょう． マウスボタンを押した位置を中心座標として，マウスをドラッグして移動した距離を半径とした円を描きます． まず，変数xとyを宣言し，mousePressed()関数でマウスボタンを押した位置を記録します． 次に，ouseDragged()関数で，座標(x,y)からの距離をdist()関数で求め円を描きます （dist(x1, y1, x2, y2)関数は，座標(x1,y1)と座標（x2,y2）の距離を求めます）． 下記を参考にコードを入力したら，Runボタンをクリックしてください． マウスのドラッグ操作に合わせて，円が描かれることを確認してください．
 
キーボードイベント  キーボードイベントを検出するために下記表の関数が用意されています． これらの関数内に，実行したい内容を記述することで，キーボードイベントに対応した処理が可能になります． また，これらのイベントの結果を反映させるには，draw()関数の記述が必要なことに注意してください．</description>
    </item>
    
    <item>
      <title>オブジェクト指向</title>
      <link>https://mukai-lab.info/pages/classes/programming_1/chapter8/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://mukai-lab.info/pages/classes/programming_1/chapter8/</guid>
      <description>スケッチの作成  Processingを起動して，新規にスケッチを保存しましょう． メニューから[ファイル]-[名前を付けて保存]をクリックして，「スケッチフォルダを名前を付けて保存」を開きます． ファイル名に「Project8」を入力し，[保存]をクリックしましょう． 保存先に「Project8」という名前のフォルダが作成されていることを確認してください．

オブジェクト指向  オブジェクト指向 は大規模なプログラムを作成する際の開発者の負担を減らすための コンセプト です． しかし，オブジェクト指向を正しく理解には，多くの知識を経験を要します． そこで，この授業では，オブジェクト指向における実用的なテクニックに絞って解説します． オブジェクト指向の詳細を学びたい場合は，河合昭男氏の「ここから始めるオブジェクト指向（ITmediaエンタープライズ）」を参考にすると良いです．
オブジェクト指向の中心となるのは クラス と呼ばれる概念です． これまでに使用した String や PImage もクラスに該当します． クラスは，int型やdouble型などのプリミティブなデータ型の変数（ フィールド ）と， 幾つかの処理をまとめて実行する関数（ メソッド ）を，一つにまとめて扱うことができるという特徴があります．
クラスの定義  ここでは，クラスを利用してウィンドウに雪を降らせるアニメーションを設定しましょう． 雪を表現するにはどんな フィールド や メソッド が必要でしょうか．
フィールドの宣言 まずは，雪を表す Snowクラス を定義して，その位置を表すxとyをフィールドとして宣言します． クラスを定義するには，「class」の文字列の後にスペースを空けて， クラス名 を指定します（ここでは Snow ）． また，「{}」で括られた内部に，フィールドの宣言やメソッドの定義を記述します． ここでは，float型のxとyを宣言しています．
class Snow{ float x; float y; } 下記のコードを参考に Snow クラスを定義してみましょう． setup() 関数では，Snowクラスの実体（ インスタンス ）を生成しています． インスタンス の生成は，クラス名 変数名 = new クラス名();と記述します． また，フィールドに値を代入したり，保存されている値を取り出すには， 変数名.</description>
    </item>
    
    <item>
      <title>オブジェクト指向①クラスとメソッド</title>
      <link>https://mukai-lab.info/pages/classes/applied_programming/chapter7/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://mukai-lab.info/pages/classes/applied_programming/chapter7/</guid>
      <description>プロジェクトの準備 --プロジェクトの準備  Eclipseで新規にプロジェクトを作成しましょう． メニューから[ファイル]-[新規]-[Javaプロジェクト]をクリックして，「新規Javaプロジェクトの作成」を開きます． ここでは，プロジェクト名に”Project7”を入力して，[完了]をクリックしましょう． パッケージ・エクスプローラに作成したプロジェクトが表示されていることを確認してください．

続いてソースファイルを作成しましょう． メニューから[ファイル]-[新規]-[クラス]をクリックして，「新規Javaクラス」を開きます． ここでは，名前に”MyClass”を入力し，public static void main(String[] args)(V)にチェックを入れ，[完了]をクリックしましょう． パッケージ・エクスプローラに作成したソースファイルが表示されていることを確認してください．

オブジェクト指向 --オブジェクト指向  今回はJavaの本質とも言えるオブジェクト指向について学びます． オブジェクト指向は，大規模なプログラムを作成する際の開発者の負担を減らすためのコンセプトであり， オブジェクト指向に沿ってプログラミングすることでプログラムの「柔軟性」「保守性」「再利用性」の向上が期待できます． しかし，オブジェクト指向はあくまでコンセプトであり，たとえ経験豊かなエンジニアであっても， 一言で「オブジェクト指向が何か」を言い表すことは難しく， Javaプログラミング初心者にとっては大きな障壁となりがちです．
極論すれば，オブジェクト指向とは「現実世界の オブジェクト（もの） を， そのままプログラムの世界の オブジェクト（もの） に置き換えること」と言えます． 例えば，サッカー選手をプログラムの世界に置き換えることを考えてみます （ウイニングイレブンなどのサッカーゲームを想像してください）． サッカー選手をプログラムの世界で表現するには，サッカー選手の特徴を数値化したり，それぞれの役割や操作を定義する必要があります． 例えばサッカーゲームの本田圭佑選手は，キック力は80，ドリブルスピードは76などのように，個々の特徴を数値で特徴化していますね． 他にも，ポジションはフォワードやミッドフィールダー，操作はドリブルやシュートなどを設定する必要がありそうです．
オブジェクト指向では，オブジェクト（サッカー選手）を表現する型のことをクラス，そして， 型を実体化したもの（本田圭佑選手）をインスタンスと呼びます． また，個々の特徴をフィールド，操作をメソッドと呼びます． 一方，オブジェクトは実は曖昧な表現で，クラスとインスタンスの両方の意味で用いられることがあるので注意が必要です．
クラスの定義 --クラスの定義  ここでは，現実世界の「色画用紙」をクラスで表現することを考えてみましょう． 画用紙に必要な特徴は何でしょうか． ここでは，幅（width），高さ（height），**色（color）**を色画用紙を表す特徴として考えていきましょう．

クラスはファイルに１つだけ定義するのが基本です． まずは，色画用紙を表すPaperクラスを新規に作成しましょう． メニューから[ファイル]-[新規]-[クラス]をクリックして，「新規Javaクラス」を開きます． ここでは，名前に”Paper”を入力し，[完了]をクリックしましょう．

クラスの宣言部に当たるpublic class クラス名{}は既に記述されています． この宣言の{}内に，画用紙の特徴を表すフィールドを定義します． ここでは，width，height，colorの3つのフィールドです． 下記のコードを参考に，色画用紙を表すクラスPaperのフィールドを宣言してみましょう．
 次に，下記のコードを参考にPaperクラスをインスタンス化してみましょう． ここでは，幅182[mm]，高さ257[mm]，赤色の画用紙を想定しています． インスタンス化はクラス名 変数名 = new クラス名()と記述します． また，フィールドに値を代入したり，保存されている値を取り出すには変数名.</description>
    </item>
    
    <item>
      <title>オブジェクト指向②継承とインターフェイス</title>
      <link>https://mukai-lab.info/pages/classes/applied_programming/chapter8/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://mukai-lab.info/pages/classes/applied_programming/chapter8/</guid>
      <description>プロジェクトの準備 -- プロジェクトの準備  Eclipseで新規にプロジェクトを作成しましょう． メニューから[ファイル]-[新規]-[Javaプロジェクト]をクリックして，「新規Javaプロジェクトの作成」を開きます． ここでは，プロジェクト名に”Project8”を入力して，[完了]をクリックしましょう． パッケージ・エクスプローラに作成したプロジェクトが表示されていることを確認してください．

続いてソースファイルを作成しましょう． メニューから[ファイル]-[新規]-[クラス]をクリックして，「新規Javaクラス」を開きます． ここでは，名前に”MyClass”を入力し，public static void main(String[] args)(V)にチェックを入れ，[完了]をクリックしましょう． パッケージ・エクスプローラに作成したソースファイルが表示されていることを確認してください．

継承とは -- 継承とは  前回はオブジェクト指向について学習しました． オブジェクト指向とは「現実世界のオブジェクト（もの）を，そのままプログラムの世界のオブジェクト（もの）に置き換えること」を意味しているんでしたね． そして，オブジェクトの型をクラスで表現することも理解したかと思います． 今回は，オブジェクト指向における重要な機能の１つクラスの継承について学びます． クラスの継承とは，「クラスの持つフィールドやメソッドを引き継ぎながら新しいクラスを作成すること」を意味しています． この継承という機能を利用することで，コードの冗長性を排除し，スッキリとした表現で記述することが可能になります．
ここでは，会話が出来るロボットを表すRobotクラスを作成してみましょう． メニューから[ファイル]-[新規]-[クラス]をクリックして，「新規Javaクラス」を開きます． ここでは，名前に”Robot”を入力し，[完了]をクリックしましょう．

下記のコードを参考に，nameフィールドと，speakメソッドを定義してください． コンストラクタでnameフィールドを初期化していることに注意してください．
 下記のコード参考にRobotクラスをインスタンス化してみましょう． ここでは，ロボットの名前をロボット1号とします． プログラムの実行後にコンソール出力を確認してください．
 上記で作成したロボット１号は一方的に話すだけで面白くありません． そこで，次に対話が可能なロボットに改良してみましょう． このようなときに利用すると便利な機能が継承です． Robotクラスを継承してTalkRobotを作成してみます．
メニューから[ファイル]-[新規]-[クラス]をクリックして，「新規Javaクラス」を開きます． ここでは，名前に”TalkRobot”，スーパクラスに&amp;quot;Robot&amp;quot;を入力し，[完了]をクリックしましょう． このスーパークラスとは，継承元となるクラスを意味し，「スーパークラス」の他にも「親クラス」などと呼びます． 一方，継承したクラスは，「サブクラス」や「子クラス」と呼びます．

継承するとクラス宣言部のextendsの後に継承元のクラス名が記述されます． 下記のコードを参考に，talkメソッドを定義してください． talkメソッドでは，キーボードから名前を入力すると，ロボットが入力された名前を話します． コンストラクタ内のsuper(name)は，スーパークラスであるRobotクラスのコンストラクタと同じ処理をします．
 下記のコードを参考にTalkRobotクラスをインスタンス化してみましょう． ここでは，ロボットの名前をロボット2号とします． プログラムの実行後にコンソール出力を確認してください． Robotクラスを継承することで，Robotクラスのnameフィールドやspeakメソッドを， TalkRobotでも利用できることが分かります．
 TalkRobotクラスで，speakメソッドを修正することもできます． これをオーバーライドと呼びます． ここでは，下記のコードを参考にspeakメソッドをオーバライドして， 男らしい話し方をするロボットに修正しましょう． プログラムの実行後にコンソール出力を確認してください．
 インターフェイスとは 継承する際にスーパークラスは1つしか指定することはできません． 複数の継承元の機能を引き継ぎたい場合はどうすれば良いでしょうか（多重継承と呼びます）． このような場合に利用するのがインターフェイスです． インターフェイスは下記の点がクラスとは異なります．</description>
    </item>
    
    <item>
      <title>オリジナルのオンラインマップの作成</title>
      <link>https://mukai-lab.info/pages/classes/seminar_fundamental_areas/chapter5/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://mukai-lab.info/pages/classes/seminar_fundamental_areas/chapter5/</guid>
      <description>オリジナルのオンラインマップの作成  オープンストリートマップとオープンデータを利用したオリジナルのマップを作成してください． 対象とするエリアは住んでいる街やお気に入りの街など自由に設定してください（日進市は除く）． 地図に表示するオープンデータは，緯度・経度の情報が含まれていれば，観光地，医療施設など自由です． 自治体が公開しているオープンデータを利用することを推奨しますが，独自にデータを作成しても構いません． 作成するオンラインマップは下記の条件を満たしてください．
 Folium または GeoPandas を利用してマップを表示 オープンデータ含まれるデータを マーカー として表示（ツールチップも表示すること） 少なくとも 3箇所以上 のマーカーを設置（地図を表示したときにマーカーが視認できること）  オープンデータの公開サイト  オープンデータを公開しているサイトを列挙します． これらのサイトから，オープンデータをCSV形式やGeoJSON形式でダウンロードすると良いでしょう． 他のサイトに掲載されているオープンデータや，独自に作成したデータを利用しても構いません．
 愛知県 オープンデータカタログ 名古屋市 オープンデータ一覧 東京都オープンデータカタログサイト 京都府オープンデータカタログサイト 政府機関オープンデータポータル データカタログサイト data.go.jp 自治体オープンデータ CKAN Google Dataset Search  オープンデータのサンプル 京都府の観光施設に関するオープンデータ（抜粋）
名称,名称_カナ,緯度,経度 縁城寺,エンジョウジ,35.659433,135.069206 間人のお宿炭平,タイザノオヤドスミヘイ,35.728973,135.087985 磯砂山,イサナゴサン,35.548532,135.03811 愛知県の美術館に関するオープンデータ（抜粋）
経度,緯度,施設名,住所 136.948874211326,35.1687621229592,古川美術館,名古屋市千種区 池下町2-50 136.911410920255,35.1708254022429,愛知芸術文化センター愛知県美術館,名古屋市東区 東桜1-13-2 136.911012631801,35.1753137574013,楽只美術館,名古屋市東区 泉1-17-28 CSVファイルの取り込み方法  CSV形式のオープンデータをGoogle Colaboratoryで利用するには，CSV形式のデータを文字列として代入する方法があります． ここでは，上記の京都府の観光施設に関するCSVデータを例に説明します． 次に示すようにCSVデータを文字列として，変数csv_dataに代入します． &amp;quot;&amp;quot;&amp;quot;で括ることで，改行を含めた文字列を変数に代入することができます．
# CSVのデータを文字列として代入 csv_data = &amp;#34;&amp;#34;&amp;#34; 名称,名称_カナ,緯度,経度 縁城寺,エンジョウジ,35.659433,135.069206 間人のお宿炭平,タイザノオヤドスミヘイ,35.728973,135.087985 磯砂山,イサナゴサン,35.</description>
    </item>
    
    <item>
      <title>オリジナル作品の制作①：準備</title>
      <link>https://mukai-lab.info/pages/classes/applied_programming/chapter13/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://mukai-lab.info/pages/classes/applied_programming/chapter13/</guid>
      <description>オリジナル作品の条件 -- オリジナル作品の条件  
これまでに学習した技術を活かして，自由なテーマでオリジナルのJavaプログラムを制作してください． テーマは，「ユーティリティ」「ゲーム」「アート」「写真・画像編集」など自由に選んでください． これまでに制作したプログラムに新しい要素を追加して自身の作品としても構いません． ただし，作品は下記の条件を必ず満たして下さい． また，Javaの書籍やウェブサイトを参考にすることも問題ありませんが， 必ず発表の際に参考にした書籍やウェブサイトを紹介してください．
 JavaFXを利用したGUIアプリケーションであること ボタン，マウス，キーボードなどのイベント処理，または，タイムラインを利用したアニメーション処理を含むこと 実行可能JARファイルとしてエクスポートし，JARファイルのみで実行可能であること  参考書籍</description>
    </item>
    
    <item>
      <title>オリジナル作品の制作①：準備</title>
      <link>https://mukai-lab.info/pages/classes/programming_1/chapter13/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://mukai-lab.info/pages/classes/programming_1/chapter13/</guid>
      <description>
これまでに学習した技術を活かして，自由なテーマでオリジナルのProcessingプログラムを制作してください． これまでに制作したプログラムに新しい要素を追加して自身の作品としても構いません． ただし，作品は下記の”いずれか”の機能を必ず取り入れてください．
 アニメーションの利用 マウスやキーボードのイベント処理の利用 3Dグラフィックスの利用 カメラ映像の利用  参考書籍</description>
    </item>
    
    <item>
      <title>オリジナル作品の制作②：実装</title>
      <link>https://mukai-lab.info/pages/classes/applied_programming/chapter14/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://mukai-lab.info/pages/classes/applied_programming/chapter14/</guid>
      <description>オリジナル作品の条件 -- オリジナル作品の条件  
これまでに学習した技術を活かして，自由なテーマでオリジナルのJavaプログラムを制作してください． テーマは，「ユーティリティ」「ゲーム」「アート」「写真・画像編集」など自由に選んでください． これまでに制作したプログラムに新しい要素を追加して自身の作品としても構いません． ただし，作品は下記の条件を必ず満たして下さい． また，Javaの書籍やウェブサイトを参考にすることも問題ありませんが， 必ず発表の際に参考にした書籍やウェブサイトを紹介してください．
 JavaFXを利用したGUIアプリケーションであること ボタン，マウス，キーボードなどのイベント処理，または，タイムラインを利用したアニメーション処理を含むこと 実行可能JARファイルとしてエクスポートし，JARファイルのみで実行可能であること  参考書籍</description>
    </item>
    
    <item>
      <title>オリジナル作品の制作②：実装</title>
      <link>https://mukai-lab.info/pages/classes/programming_1/chapter14/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://mukai-lab.info/pages/classes/programming_1/chapter14/</guid>
      <description>
これまでに学習した技術を活かして，自由なテーマでオリジナルのProcessingプログラムを制作してください． これまでに制作したプログラムに新しい要素を追加して自身の作品としても構いません． ただし，作品は下記の”いずれか”の機能を必ず取り入れてください．
 アニメーションの利用 マウスやキーボードのイベント処理の利用 3Dグラフィックスの利用 カメラ映像の利用  参考書籍</description>
    </item>
    
    <item>
      <title>オリジナル作品の制作③：発表</title>
      <link>https://mukai-lab.info/pages/classes/applied_programming/chapter15/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://mukai-lab.info/pages/classes/applied_programming/chapter15/</guid>
      <description>オリジナル作品の発表 -- オリジナル作品の発表  
１人につき１分程度で制作したオリジナル作品を紹介してください． 紹介の際には下記の４項目を必ず含めて下さい．
 作品タイトル 作品の概要 操作方法（実演しながら） 苦労した点，工夫した点 （参考にした書籍やウェブサイトなど）  参考書籍</description>
    </item>
    
    <item>
      <title>オリジナル作品の制作③：発表</title>
      <link>https://mukai-lab.info/pages/classes/programming_1/chapter15/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://mukai-lab.info/pages/classes/programming_1/chapter15/</guid>
      <description>
１人につき１分程度で制作したオリジナル作品を紹介してください． 紹介の際には下記の４項目を必ず含めて下さい．
 作品タイトル 作品の概要 操作方法（実演しながら） 苦労した点，工夫した点  参考書籍</description>
    </item>
    
    <item>
      <title>オリジナル地図の発表</title>
      <link>https://mukai-lab.info/pages/classes/seminar_fundamental_areas/chapter5_2020/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://mukai-lab.info/pages/classes/seminar_fundamental_areas/chapter5_2020/</guid>
      <description>
オリジナル地図の作成  オリジナルのオンライン地図を作成してください． 対象とするエリアは住んでいる街やお気に入りの街など自由に設定してください（日進市は除く）． また，テーマに関しても，観光に限らず，書店，図書館，美容院など自由です． ただし，作成する地図は下記の条件を満たす必要があります． ポップアップ表示する写真（画像）は事前に撮影しておくことが望ましいです．
 Leafletを利用すること 3箇所以上のマーカーを設定すること マーカーのポップアップ表示で**写真（画像）**を表示すること  オリジナル地図の発表  作成したオンライン地図を紹介してください． 紹介する際は下記の情報を含めてください．
 対象としたエリアはどこか（例，日進市） 対象としたテーマは何か（例，観光） 表示したマーカーの詳細  課題  Leafletで作成したHTMLファイルを，画像を含めたフォルダごとZIPで圧縮し，提出しなさい．
参考書籍</description>
    </item>
    
    <item>
      <title>オンラインマップを利用したCSVデータのプロット</title>
      <link>https://mukai-lab.info/pages/classes/seminar_fundamental_areas/chapter3/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://mukai-lab.info/pages/classes/seminar_fundamental_areas/chapter3/</guid>
      <description>オープンストリートマップとは  行政が公開しているオープンデータには， 施設の位置を表す緯度，経度の情報が含まれることが多くあります． 前回利用した日進市の子育て支援施設のオープンデータにも，施設の名称や住所に加えて，緯度・経度の情報が含まれていました． オンライン地図を利用して，これらの位置情報を可視化することで，新たな気付きを得ることが可能です．
オンラインマップとして最も有名なサービスはGoogleが提供しているGoogle Mapsでしょう． Google Mapsは，滑らかな地図の表示はもちろん，ストリートビュー，ジオコーディング，ルート検索などの機能も充実しています． ジオコーディングとは住所や地名などを緯度・経度に変換する技術です． 例えば，椙山女学園大学の地図をGoogle Mapで表示してみます． ウェブページにGoogle Mapsを埋め込むには，共有をクリックし， 地図を埋め込むのタブに表示されているソースコードをコピペするだけで完成です．
Google Mapsはとても便利なのですが，利用規約が厳しいことが知られています． クレジット表示が必要なことに加え，非営利であっても 印刷物 での使用には大きな制限があります． 新聞，雑誌，レポートなどの目的では問題ありませんが，ガイドブックや印刷広告には使用することができません． これは，行政にとっては致命的であり，自治体を紹介する印刷広告を作成しようとしても，Google Mapsを掲載することができません． そこで，代わりに用いられるのがオープンストリートマップ(OpenStreetMap: OSM)です． オープンストリートマップはオープンデータベースライセンス（ODbL）と呼ばれるライセンスで提供されており，適切にクレジットを表示すれば，営利目的の使用も含め，複製・再配布・改変が認められています． 例えば，椙山女学園大学の地図をオープンストリートマップで表示してみます． 上記のGoogle Mapsと比較しても，遜色ないことが分かるでしょう．
加えて，オープンストリートマップの最も大きな特徴は，オープンストリートマップのアカウント登録さえすれば， 誰しもが自由に地図を編集することができるという点です． つまり，オープンストリートマップは，オンライン地図のサービスであることに加え，無料地図の共同作成プロジェクトでもあるわけです． オープンストリートマップを編集する人のことを マッパー と呼び， 複数のマッパーで街歩きをしながらオープンストリートマップを編集するイベントを マッピングパーティ と呼びます． 全国各地でマッピングパーティは開催されていますので，興味があれば参加してみることをお勧めします．
今回は日進市の子育て支援施設のオープンデータとオープンストリートマップを組み合わせ， 独自のオンラインマップを作成する方法について学習していきましょう．
子育て支援施設の地図  それでは，Google Colaboratoryで，オープンストリートマップを利用した日進市の子育て支援施設の地図を作成しましょう．
ノートブックの作成 まずは，ノートブックを作成します． ノートブックの名前は chapter3.ipynb に設定します．

オープンストリートマップを利用したオンライン地図を作成するためのライブラリにLeaflet.jsがあります． このLeaflet.jsをPythonで利用するための機能を提供するライブラリがfoliumです． ここでは，foliumをインストールします．
!pip install folium foliumとpandasをインポートします．
import folium import pandas as pd オープンストリートマップの表示 椙山女学園大学・星ヶ丘キャンパスを中心とした地図を表示しています． 星ヶ丘キャンパスの緯度・経度をlat，lonに代入します．</description>
    </item>
    
    <item>
      <title>オンラインマップを利用したGeoJSONデータのプロット</title>
      <link>https://mukai-lab.info/pages/classes/seminar_fundamental_areas/chapter4/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://mukai-lab.info/pages/classes/seminar_fundamental_areas/chapter4/</guid>
      <description>GeoJSON  これまでcsv形式のオープンデータを利用してきました，よりウェブに相性が良いデータ形式があります． それが，JSON形式（.json） です． JSONは，「じぇいそん」と読み，ブラウザで動作するプログラミング言語の JavaScript で用いられるデータ形式ですが， 現在はPythonを始めとした様々なプログラミング言語でサポートされています（Pythonでは辞書に対応する）．
下記のCSV形式のデータを例に考えてみましょう．
町名,男,女,総数,世帯数 赤池町,1693,1647,3340,1315 浅田町,2593,2431,5024,2086 上記のデータをJSON形式に変換すると下記になります． JSON形式では，データは string（文字列） と value（値） の組で表現されます． 例えば，&amp;ldquo;町名&amp;quot;という文字列と，&amp;ldquo;赤池町&amp;quot;という値が組になっていることがわかります． また，[ ] は配列を表しており，0番目の要素に赤池町のデータ，1番目の要素に浅田町のデータが格納されます． 要素は「,」で区切られますが，最後の要素には必要ありません．
json = [ { &amp;#34;町名&amp;#34;: &amp;#34;赤池町&amp;#34;, &amp;#34;男&amp;#34;: 1693, &amp;#34;女&amp;#34;: 1647, &amp;#34;総数&amp;#34;: 3340, &amp;#34;世帯数&amp;#34;: 1315 }, { &amp;#34;町名&amp;#34;: &amp;#34;浅田町&amp;#34;, &amp;#34;男&amp;#34;: 2593, &amp;#34;女&amp;#34;: 2431, &amp;#34;総数&amp;#34;: 5042, &amp;#34;世帯数&amp;#34;: 2086 } ] print(json[0]) print(json[1]) {&amp;#39;町名&amp;#39;: &amp;#39;赤池町&amp;#39;, &amp;#39;男&amp;#39;: 1693, &amp;#39;女&amp;#39;: 1647, &amp;#39;総数&amp;#39;: 3340, &amp;#39;世帯数&amp;#39;: 1315} {&amp;#39;町名&amp;#39;: &amp;#39;浅田町&amp;#39;, &amp;#39;男&amp;#39;: 2593, &amp;#39;女&amp;#39;: 2431, &amp;#39;総数&amp;#39;: 5042, &amp;#39;世帯数&amp;#39;: 2086} このJSON形式を基本として，点，線，多角形などの空間データを表現するために用いられるのが GeoJSON 形式です． GeoJSONは，「じおじぇいそん」と読み， Leefletを始めとした様々な地図サービスで利用可能です． geojson.</description>
    </item>
    
    <item>
      <title>オープンストリートマップを利用したオープンデータの可視化①・uMap</title>
      <link>https://mukai-lab.info/pages/classes/seminar_fundamental_areas/chapter3_2020/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://mukai-lab.info/pages/classes/seminar_fundamental_areas/chapter3_2020/</guid>
      <description>オープンストリートマップとは  行政が公開しているオープンデータには， 施設の位置を表す緯度，経度の情報が含まれることが多くあります． 前回利用した日進市の子育て支援施設のオープンデータにも，施設の名称や住所に加えて，緯度・経度の情報が含まれていました． オンライン地図を利用して，これらの位置情報を可視化することで，新たな気付きを得ることが可能です．
オンライン地図として最も有名なサービスはGoogleが提供しているGoogle Mapsでしょう． Google Mapsは，滑らかな地図の表示はもちろん，ストリートビュー，ジオコーディング，ルート検索などの機能も充実しています． ここで，ジオコーディングとは住所や地名などを緯度・経度に変換する技術を指しています． 例えば，椙山女学園大学の地図をGoogle Mapで表示してみます． ウェブページにGoogle Mapsを埋め込むには，共有をクリックし， 地図を埋め込むのタブに表示されているソースコードをコピペするだけで完成です．
Google Mapsはとても便利なのですが，利用規約が厳しいことが知られています． クレジット表示が必要なことは当然ですが，非営利であっても印刷物での使用には大きな制限があります． 新聞，雑誌，レポートなどの目的では問題ありませんが，ガイドブックや印刷広告には使用することができません． これは，行政にとっては致命的であり，自治体を紹介する印刷広告を作成しようとしても，Google Mapsを掲載することができません． そこで，代わりに用いられるのがオープンストリートマップ(OpenStreetMap: OSM)です． オープストリートマップはクリエイティブ・コモンズ CC-BY-SA 2.0と呼ばれる ライセンスで提供されており，適切にクレジットを表示すれば，営利目的の使用も含め，複製・再配布・改変が認められています． 例えば，椙山女学園大学の地図をオープンストリートマップで表示してみます． 上記のGoogle Mapsと比較しても，遜色ないことが分かるでしょう．
加えて，オープンストリートマップの最も大きな特徴は，オープンストリートマップのアカウント登録さえすれば， 誰しもが自由に地図を編集することができるという点です． つまり，オープンストリートマップは，オンライン地図のサービスであることに加え，無料地図の共同作成プロジェクトでもあるわけです． オープンストリートマップを編集する人のことをマッパーと呼び， 複数のマッパーで街歩きをしながらオープンストリートマップを編集するイベントをマッピングパーティと呼びます． 全国各地でマッピングパーティは開催されていますので，興味があれば参加してみることをお勧めします． 日進市においては，平成29年12月9日に「ブラニッシン〜いまのにっしん，世界に発信！〜」という マッピングパーティが開催され，向も参加しました．
今回は日進市のオープンデータとオープンストリートマップを組み合わせ， 独自のオンライン地図を作成する方法について学習していきましょう．
GeoJSON  ここで，オープンデータの条件である「機械判読に適したデータ形式」について考えてみます． オンライン地図にオープンデータを表示するには，当然，コンピュータが読み取ることが出来る形式を用いる必要があります． これまでに，xlsx形式，csv形式を紹介しましたが，よりウェブに相性が良いデータ形式があります． それが，**JSON形式（.json）**です． JSONは，「じぇいそん」と読み，ブラウザで動作するプログラミング言語のJavaScriptで用いられるデータ形式です （JavaScript以外のプログラミング言語でも対応していることが多い）．
下記のCSV形式のデータを例に考えてみましょう．
町名,男,女,総数,世帯数赤池町,1693,1647,3340,1315浅田町,2593,2431,5024,2086上記のデータをJSON形式に変換すると下記になります． JSON形式では，データは**string（文字列）とvalue（値）の組で表現されます． 例えば，&amp;ldquo;町名&amp;quot;という文字列と，&amp;ldquo;赤池町&amp;quot;という値が組になっていることがわかります． また，[ ]**は配列を表しており，0番目の要素に赤池町のデータ，1番目の要素に浅田町のデータが格納されます． 要素は「,（カンマ）」で区切られますが，最後の要素には必要ありません（間違えやすいので要注意）．
[ { &amp;#34;町名&amp;#34;: &amp;#34;赤池町&amp;#34;, &amp;#34;男&amp;#34;: 1693, &amp;#34;女&amp;#34;: 1647, &amp;#34;総数&amp;#34;: 3340, &amp;#34;世帯数&amp;#34;: 1315 }, { &amp;#34;町名&amp;#34;: &amp;#34;浅田町&amp;#34;, &amp;#34;男&amp;#34;: 2593, &amp;#34;女&amp;#34;: 2431, &amp;#34;総数&amp;#34;: 5042, &amp;#34;世帯数&amp;#34;: 2086 }	] このJSON形式を基本として，点，線，多角形などの空間データを表現するために用いられるのが， GeoJSON形式です． GeoJSONは，「じおじぇいそん」と読み， uMap，Leeflet， OpenLayersなどの様々な地図サービスで利用可能です．</description>
    </item>
    
    <item>
      <title>オープンストリートマップを利用したオープンデータの可視化②・Leaflet</title>
      <link>https://mukai-lab.info/pages/classes/seminar_fundamental_areas/chapter4_2020/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://mukai-lab.info/pages/classes/seminar_fundamental_areas/chapter4_2020/</guid>
      <description>Leafletとは  前回はuMAPというサービスを利用して， 日進市のオープンデータをオープンストリートマップに重ねて表示しました． uMAPを用いると，ブラウザ上で手軽にオリジナルの地図を作成することができますが， 作成された地図は静的で，ユーザとのインタラクションに応じて動的に変化させることはできません． そこで，今回はLeafletを利用して，オリジナルの地図を作成することに挑戦しましょう． Leafletは，「りーふれっと」と読み，プログラミング言語であるJavaScriptのライブラリの一つです． オープンソースで開発されており，BSD 2-Clauseライセンスであるため， クレジットさえ表示すれば，商用利用・改変・配布が可能です． Leafletを用いると，デスクトップPCやモバイル環境に適したオンライン地図を表示することができます． JavaScriptで制御可能であるため，ユーザとのインタラクションに応じて動的に地図を変更することが可能です． もちろん，前回紹介したGeoJSON形式のデータの取り込みも可能です． 今回は，このLeafletを用いて日進市の観光マップを作成します．
オープンデータの準備  日進市のオープンデータミュージアムにある 観光情報データを利用します． ここでは，名称と緯度・経度の情報を利用することにします． 下記はCSV形式で表現されたデータです．
名称,緯度,経度岩崎城址公園,35.1455654,137.0420547愛知牧場,35.1306941,137.0876883五色園,35.1557573,137.0682229レトロでんしゃ館,35.1228602,137.0221455旧市川家住宅,35.12896,137.033636今回は，上記のテキスト情報だけでなく，下記の5つの画像ファイルを利用します． これらは日進市のイベント情報を提供しているぐるぐるNISSHINに掲載されていますが， オープンデータではないことに注意してください（授業向けに許可を得て利用しています）． 全ての画像ファイルをダウンロードしておいてください．
上記の観光情報と画像ファイル名を，下記のようにGeoJSON形式に変換します． 画像ファイル名はpropertiesに記載しています． ここでは，経度・緯度の順番で指定することに注意してください．
{ &amp;#34;type&amp;#34;: &amp;#34;FeatureCollection&amp;#34;, &amp;#34;features&amp;#34;: [ { &amp;#34;type&amp;#34;: &amp;#34;Feature&amp;#34;, &amp;#34;geometry&amp;#34;: { &amp;#34;type&amp;#34;: &amp;#34;Point&amp;#34;, &amp;#34;coordinates&amp;#34;: [137.0420547,35.1455654] }, &amp;#34;properties&amp;#34;: { &amp;#34;名称&amp;#34;: &amp;#34;岩崎城址公園&amp;#34;, &amp;#34;画像&amp;#34;: &amp;#34;iwasaki.jpg&amp;#34; } }, { &amp;#34;type&amp;#34;: &amp;#34;Feature&amp;#34;, &amp;#34;geometry&amp;#34;: { &amp;#34;type&amp;#34;: &amp;#34;Point&amp;#34;, &amp;#34;coordinates&amp;#34;: [137.0876883,35.1306941] }, &amp;#34;properties&amp;#34;: { &amp;#34;名称&amp;#34;: &amp;#34;愛知牧場&amp;#34;, &amp;#34;画像&amp;#34;: &amp;#34;bokujyou.</description>
    </item>
    
    <item>
      <title>オープンデータを利用した人口データの可視化</title>
      <link>https://mukai-lab.info/pages/classes/seminar_fundamental_areas/chapter1/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://mukai-lab.info/pages/classes/seminar_fundamental_areas/chapter1/</guid>
      <description>オープンデータとは  平成２４年，日本において公共データの活用促進を目的として電子行政オープンデータ戦略が策定されました． この戦略では，「公共データ活用の推進」「公共データ活用のための環境整備」が具体的な施策とされており， これらの施策の鍵となるのがオープンデータです．
オープンデータは下記に従うことを条件としています．
 機械判読に適したデータ形式 二次利用が可能な利用ルールで公開  つまり，行政（地方自治体）が保持している統計データや施設データなどを， 誰もが再利用や再頒布ができることを条件に，コンピュータに扱いやすい形式で公開されたデータをオープンデータと呼びます． 企業や個人のデータでも上記に従えばオープンデータですが，ここでは，行政のデータにターゲットを絞ります（オープンガバメントデータと呼ぶこともあります）． 一般に，再利用や再頒布が可能なソフトウェアのことはオープンソースと呼ばれることも合わせて覚えておきましょう．
ここで，ポイントとなるのは，「機械判読に適したデータとは何か？」ということです． 一般に小規模のデータを管理するときには，エクセル を採用することが多いです． 文化情報学部では，１年後期に開講されている「コンピュータと情報 Ⅱ」において，エクセルの使い方を学習します． たしかに，エクセルは，デザイン（書式）や関数など様々な機能を提供しており，人間にとってはとても便利なソフトウェアです． しかし，これらのデータをコンピュータで処理しようとするとき，これらの機能が却って冗長となり，コンピュータによる判読が難しい状況が起こります．
具体例をみてみましょう． まずは，エクセル形式（.xlsx）で表現された日進市の人口のデータ（jinkou.xlsx）です． タイトル部分に太字，表部分に罫線などのデザイン（書式）が設定されていることが分かります． これらは，エクセルを利用している人間が見るためのデザインであり，データの本質ではありません． また，エクセル形式の実態は，XMLや画像などで構成されるZIPファイルであり， エクセルなどの専用のソフトウェアでしか開くことはできません．

次に，CSV形式（.csv）で表現された日進市の人口のデータ（jinkou.csv）です． CSVは「しーえすぶい」と読み，オープンデータで頻繁に採用されるデータ形式です． データが「,（カンマ）」で区切られて表現されるだけで，エクセルのようなデザイン（書式）は含みません． このため，一般的なエディタ（メモ帳）でも開くことができます（エクセルでも開けます）． エクセル形式に比べると，人間にとっては理解しにくいですが，コンピュータの判読には優れています．
﻿町名,男,女,総数,世帯数 赤池町,1693,1647,3340,1315 浅田町,2593,2431,5024,2086 梅森町,1017,1034,2051,876 野方町,171,173,344,143 蟹甲町,171,200,371,152 折戸町,1404,1381,2785,1073 今回の授業では，日進市のオープンデータポータルサイトで公開されている CSV形式のデータをプログラミング言語のPythonで可視化することを目的とします．
公開されているオープンデータ  オープンデータはウェブで公開されるのが一般的であり， 総務省が運用するData.go.jpがオープンデータのカタログサイトとして知られています． このサイトでは，国土交通省，経済産業省などの組織別のデータセット，また，行財政や観光などのトピックに関するデータ・セットが提供されています． 例えば，観光 というキーワードで検索すると，「平成28年度 国際経済調査事業報告書」，「平成28年度 商店街インバウンド・空き店舗実態調査」などのデータセットがヒットします（平成30年2月28日現在）． しかし，残念ながら，これらの多くはPDF形式での提供であり，「機械判読に適したデータ」ではありません． 現状では，まだまだオープンデータの整備は不十分と言えるでしょう．
この他，内閣府のまち・ひと・しごと創生本部が提供している地域経済分析システム（RESAS）が注目されています． RESAS（りーさす）は，総務省が提供している統計情報 e-Statのオープンデータなどを可視化するためのシステムです． 地方自治体の現状や課題を発見することを目的としており，情報を直感的にわかりやすく見える化することができます． 例えば，2015年の愛知県名古屋市の 人口マップ を下記のように可視化することができます． マウスで各市区町村をホバーすると人口が表示され，名古屋市千種区は164,696人であることが分かります． また，人口推移や人口ピラミッドなどのグラフも簡単に描画することができます． このようにデータを可視化して，分かりやすく伝えることも，オープンデータの活用に必要な要素です．



愛知県下においては，オープンデータに関する取り組みを精力的に進める自治体の一つに 日進市 があります．日進市のウェブサイトでは，オープンデータポータルサイトを開設しており， 住民向け情報（暮らしの情報），事業者向け情報，行政活動情報，観光情報の区分に分けてオープンデータを公開しています． また，平成28年度には，瀬戸市，尾張旭市，豊明市，日進市，みよし市，長久手市，東郷町の7市町で 「7市町オープンデータ検討会」を組織し，連携してオープンデータの整備を始めています． これまでに，7市町が共通のフォーマットで，子育て支援施設，教育機関などのデータを各自治体のウェブサイトで公開しています． 今回は日進市のオープンデータポータルサイトで公開されている 人口データ を加工して利用します． 下記のリンクをダウンロードして確認してください．</description>
    </item>
    
    <item>
      <title>オープンデータを利用した天候データの相関分析</title>
      <link>https://mukai-lab.info/pages/classes/seminar_fundamental_areas/chapter2/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://mukai-lab.info/pages/classes/seminar_fundamental_areas/chapter2/</guid>
      <description>相関分析とは  相関分析とは，2つの変数XとYの関係性を分析する方法です． 例えば，暑い日にはアイスクリームの売上数が増加すると考えられます． このとき，「X:気温」と「Y:アイスクリームの売上数」には関係がありそうです． 一般に，相関分析には相関係数と呼ばれる評価指標が用いられます（正確にはピアソンの積率相関係数と呼ばれる）． 相関係数は-1から1の範囲で与えられ，1に近いほど正の相関，-1に近いほど負の相関を示します．
相関係数は次の式で定義されます． 上記の例で考えると$x_i=\{x_1, x_2, \cdots, x_n\}$は気温を表し， $y_i=\{y_1, y_2, \cdots, y_n\}$はアイスクリームの売上を表します． また，相関係数の式は，xとyの共分散 $\sigma_{xy}$， xの標準偏差 $\sigma_x$， yの標準偏差 $\sigma_y$を用いて表すことも可能です．
$$ 相関係数=\frac{\sum (x_i - \bar{x})(y_i - \bar{y})}{\sqrt{\sum (x_i - \bar{x})^2} \cdot \sqrt{\sum (y_i - \bar{y})^2}} = \frac{\sigma_{xy}}{\sigma_x \cdot \sigma_y} $$
   相関係数 相関の強さ     0.7～1.0 強い正の相関   0.4～0.7 正の相関   0.2～0.4 弱い正の相関   -0.2～0.2 相関なし   -0.4～-0.2 弱い負の相関   -0.</description>
    </item>
    
    <item>
      <title>カメラ映像の表示</title>
      <link>https://mukai-lab.info/pages/classes/programming_1/chapter10/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://mukai-lab.info/pages/classes/programming_1/chapter10/</guid>
      <description>スケッチの作成  Processingを起動して，新規にスケッチを保存しましょう． メニューから[ファイル]-[名前を付けて保存]をクリックして，「スケッチフォルダを名前を付けて保存」を開きます． ファイル名に「Project10」を入力し，[保存]をクリックしましょう． 保存先に「Project10」という名前のフォルダが作成されていることを確認してください．

Videoライブラリの導入  Processingでは Videoライブラリ を導入することで， カメラからの映像をウィンドウに表示することができるようになります． まずは，メニューから[スケッチ]-[ライブラリをインポート]-[ライブラリを追加]をクリックして， 「Contribution Manager」を開きます． ここで， video をキーワードに検索すると， 「 Video|GStreamer-based video library for Processing 」が表示されるので， このライブラリを選択してインストールしましょう．

次に，[スケッチ]-[ライブラリをインポート]-[Video]をクリックして， Videoライブラリをインポート（プログラムで利用可能な状態にすること）します． ソースコードの１行目に「 import processing.video.*; 」と表示されていることを確認してください．
 カメラ映像の表示  カメラから入力した映像は Capture クラスを利用します． まずは， setup() 関数において， Capture クラスの list() 関数を呼び出し， 利用可能なカメラの一覧を String 型の配列で取得します． これをコンソールに出力し，利用可能なカメラの種類を確認してください．
 例えば，コンソールには下記のような一覧が表示されます． この中から， サイズ（size） が 320x240 となっているカメラ番号を覚えておいてください． この例では， 3 番が該当します． ウィンドウのサイズも320x240に合わせます． ちなみに， フレームレート（fps） は，1秒間に更新される画像（フレーム）数を意味しています． つまり，フレームレートが高いほど，滑らかな動画となります．
[0] name=FULL HD 1080P Webcam,size=640x480,fps=30 [1] name=FULL HD 1080P Webcam,size=160x120,fps=30 [2] name=FULL HD 1080P Webcam,size=176x144,fps=30 [3] name=FULL HD 1080P Webcam,size=320x240,fps=30 [4] name=FULL HD 1080P Webcam,size=352x288,fps=30 [5] name=FULL HD 1080P Webcam,size=640x360,fps=30 [6] name=FULL HD 1080P Webcam,size=800x600,fps=30 [7] name=FULL HD 1080P Webcam,size=960x720,fps=30 [8] name=FULL HD 1080P Webcam,size=1024x576,fps=30 [9] name=FULL HD 1080P Webcam,size=1280x720,fps=30 次に， Capture クラスのインスタンスcamを下記のように初期化します． 引数には先程確認したカメラ番号を指定することに注意してください． start()関数を呼び出すことで，カメラ映像の取得を開始します．</description>
    </item>
    
    <item>
      <title>グラフの表示</title>
      <link>https://mukai-lab.info/pages/classes/graduation_preperation_1/chapter6/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://mukai-lab.info/pages/classes/graduation_preperation_1/chapter6/</guid>
      <description>グラフ表示 -- グラフ表示  今回はオープンソースのグラフ描画ライブラリであるChart.jsを利用して，グラフを描くことに挑戦してみましょう． Chart.jsは HTML5 の Canvas要素 にグラフを描くことが可能なライブラリで，「折れ線グラフ」「縦棒グラフ」「円グラフ」などの８種類がグラフが利用できます（2016年12月16日現在）． また，レスポンシブにも対応しているため，PCだけでなくスマーフォンでも美しく描画されるという特徴があります． まずは，導入用のパッケージをGitHubからダウンロードしましょう． ダウンロードしたら sampleフォルダ にある様々なグラフを表示してみましょう． グリグリとアニメーションしながらグラフが表示されると思います．
JSON形式 -- JSON形式  グラフの元となるデータは JSON(Javascript Object Notation) と呼ばれる形式で記述します． JSONで表されたデータは，JavaScriptのオブジェクトに対応していて，JSON形式のテキストからオブジェクトを生成することができます． 一般にデータはCSVなどの形式で記述されることが多いですが， JavaScriptでテキストファイルを読み込むことは仕様上難しいことが多いため， JSONを利用する方法が採用されます．
ここでは，日進市のオープンデータミュージアムに掲載されているオープンデータからJSON形式のデータを作成することにします． 下記はオープンデータミュージアムで公開されていた 町別人口推移 から一部を抜粋したCSV形式のデータです．
city,population 赤池町,1195 浅田町,1899 梅森町,804 野方町,133 蟹甲町,158 一行目の「city」「population」は項目名であり，二行目からが実際のデータです． 例えば，赤池町は1,195人，浅田町は1,899人です． このCSV形式のデータをJSON形式に変換するには，iPentec が提供しているオンラインの変換ツールを利用すると簡単です．
変換ツールのページを開いたら「入力（CSV）」に上記のCSVデータを張り付けて， 「CSV➡JSON変換」のボタンをクリックします． すると下記のようなJSON形式のデータが出力されます．
[ { &amp;#34;city&amp;#34;: &amp;#34;赤池町&amp;#34;, &amp;#34;population&amp;#34;: &amp;#34;1195&amp;#34;}, { &amp;#34;city&amp;#34;: &amp;#34;浅田町&amp;#34;, &amp;#34;population&amp;#34;: &amp;#34;1899&amp;#34;}, { &amp;#34;city&amp;#34;: &amp;#34;梅森町&amp;#34;, &amp;#34;population&amp;#34;: &amp;#34;804&amp;#34;}, { &amp;#34;city&amp;#34;: &amp;#34;野方町&amp;#34;, &amp;#34;population&amp;#34;: &amp;#34;133&amp;#34;}, { &amp;#34;city&amp;#34;: &amp;#34;蟹甲町&amp;#34;, &amp;#34;population&amp;#34;: &amp;#34;158&amp;#34;} ] 今回はこのJSON形式のデータを利用してグラフを作成しましょう．</description>
    </item>
    
    <item>
      <title>コンタクト</title>
      <link>https://mukai-lab.info/contact/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://mukai-lab.info/contact/</guid>
      <description>プロフィール  氏名 向 直人（むかい なおと） 所属 椙山女学園大学 文化情報学部 文化情報学科 職位 准教授 最終学歴 名古屋大学大学院情報科学研究科 博士課程後期修了 学位 博士（情報科学） 専門分野 知能情報学，社会システム工学，交通工学 所属学会　 情報処理学会 人工知能学会 日本データベース学会    アクセス 向研究室は椙山女学園大学・星ヶ丘キャンパスの文化情報学部棟・2Fです．
 講演・原稿執筆依頼 講演や原稿執筆の依頼は椙山女学園大学までご連絡ください．
椙山女学園大学・星が丘キャンパス
〒464-8662 名古屋市千種区星が丘元町17番3号 TEL：052-781-1186（代） FAX：052-781-8831 SNS 記事に関するご質問やご意見はFacebookまたはTwitterでご連絡ください．
 Facebook Twitter  </description>
    </item>
    
    <item>
      <title>シビックテック</title>
      <link>https://mukai-lab.info/pages/projects/civictech/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://mukai-lab.info/pages/projects/civictech/</guid>
      <description>アーバンデータチャレンジ（UDC）と呼ばれる全国規模のコンテストの一環で，オープンデータを活用したアプリやサービスの開発を目的としています． 向はUDCの愛知ブロックのコーディネータの１人であり，これまでにアイデアソンなどのイベントを本学で実施しています． 愛知ブロックの主体となっているのは，有志によって活動しているCode for Nagoyaなどの組織であり，社会人や他大学の学生と一緒に研究活動を実施しています．
 自治体が公開しているオープンデータを利用したアプリの開発 アイデアソンやハッカソンの計画・実施  坂道ナビ naoto-github/EasyRouteMap
  犯罪予測マップ naoto-github/WebCrimeMapPrediction
  </description>
    </item>
    
    <item>
      <title>データベース</title>
      <link>https://mukai-lab.info/pages/classes/database/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://mukai-lab.info/pages/classes/database/</guid>
      <description>科目名: データベース
開講学期: 秋学期
科目種別: 講義
テーマ: データベースの基本概念の習得とシステム構築
概要 システムの中核となる関係データベースを基本に， 構造記述・意味記述，関係代数などの理論を学習する． また，データベース管理システムの１つであるSQLiteを用いて， SQLによるデータベースの検索・更新・関数などの機能について実習する． 後半は大規模データの処理に適したNoSQLと呼ばれる新しい概念に関して解説する．
内容／スケジュール  データベースとは リレーションと第1正規形 主キーと外部キー 関係代数演算 情報無損失分解と関数従属性 第2正規形と第3正規形 SQL(1)・データベースの作成 SQL(2)・データの更新 SQL(3)・データの検索 SQL(4)・関係代数演算 SQL(5)・トランザクション NoSQL(1)・Key-Valueストア型データベース NoSQL(2)・ドキュメント指向データベース データベースを利用したウェブサイトの構築  補足資料  高次の正規化 インデックス  旧資料(2020年度まで)  SQL(1)・データベースの作成(SQLite版) SQL(2)・データの更新(SQLite版) SQL(3)・データの検索(SQLite版) SQL(4)・関係代数演算(SQLite版) SQL(5)・トランザクション(SQLite版)  参考書籍</description>
    </item>
    
    <item>
      <title>トリガを用いた発話</title>
      <link>https://mukai-lab.info/pages/tech/robohon/robohon2/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://mukai-lab.info/pages/tech/robohon/robohon2/</guid>
      <description>サンプルアプリ  ロボホンの開発キットRoBoHoN Software Development Kitには， 下記のサンプルアプリが同梱されています． 今回は基本的な音声UIの使い方を理解するためSampleSimpleのソースコードを解析し， 改良してみましょう．
 SampleSimple 音声UIを使った基本的な機能のアプリ SampleScenario シナリオで使える変数やタグなどのアプリ SampleProjector プロジェクターを利用したアプリ SampleAddressBook 電話帳を利用したアプリ SampleCamera カメラを利用したアプリ SampleDance ダンスを利用したアプリ SampleMultilingual 多言語対応を実装したアプリ  まずは，Android Studio で上記のサンプルを読み込み，プロジェクトとして展開します． Android Studioを起動したら，[File]-[Open]-[Open File or Project]を選択し， 開発キットに含まれる SampleSimple のフォルダをクリックします． ビルドが終了したら，Run Appをクリックして実行してみましょう．
実行するとロボホンの背面には「ACCOST」「RESOLVE VARIABLE」「SET_MEMORY_P」「GET_MEMORY_P」「FINISH APP」の５つのボタンが表示されています． ここで，「ACCOST」ボタンをタップすると，「アプリから発話開始するサンプルだよ」とロボホンが発話します． ちなみに，ACCOSTとは，アプリから強制的にトピック（発話やモーション）を実行することを意味します．

 アプリトリガによる発話  最初に，ボタンなどアプリからのアクションをトリガとして，トピックを実行するアプリトリガによる発話について学びます． まずは「ACCOST」ボタンに該当するソースコードを確認していきましょう． 一般にアンドロイドのアプリはActivityクラスを継承して開発します． Activityクラスにはライフサイクルがあり，アプリを起動すると下図のようにメソッドを実行します．

ここで，「ACCOST」ボタンに関する振る舞いは，onCreate()メソッドの内部にあり，下記のように記述されています． 最初に，リソースIDを利用して，変数voiceAccostButtonに，Buttonクラスのオブジェクトを代入し，ボタンをタップしたときのイベントリスナーを登録しています． ボタンがタップされると，VoiceUIVariableListHelper クラスのインスタンスに実行したいACCOSTを登録し，VoiceUIManagerUtil クラスのupdateAppInfoメソッドで発話を実行しています． ここで，ScenarioDefinitions.ACC_ACCOST には，実行するACCOSTの名称である jp.co.sharp.sample.simple.accost.t1 が代入されています．
 ここでのポイントは，実行するACCOSTの定義です． 具体的な定義は，シャープ株式会社が独自に定義している HVML(Hyper Voice Markup Language) というXMLファイルに記述します． ここでは，assetsフォルダに含まれるjp_co_sharp_sample_simple_accost.</description>
    </item>
    
    <item>
      <title>ファイル入出力</title>
      <link>https://mukai-lab.info/pages/classes/applied_programming/chapter6/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://mukai-lab.info/pages/classes/applied_programming/chapter6/</guid>
      <description>プロジェクトの準備 --プロジェクトの準備  Eclipseで新規にプロジェクトを作成しましょう． メニューから[ファイル]-[新規]-[Javaプロジェクト]をクリックして，「新規Javaプロジェクトの作成」を開きます． ここでは，プロジェクト名に”Project6”を入力して，[完了]をクリックしましょう． パッケージ・エクスプローラに作成したプロジェクトが表示されていることを確認してください．

続いてソースファイルを作成しましょう． メニューから[ファイル]-[新規]-[クラス]をクリックして，「新規Javaクラス」を開きます． ここでは，名前に”MyClass”を入力し，public static void main(String[] args)(V)にチェックを入れ，[完了]をクリックしましょう． パッケージ・エクスプローラに作成したソースファイルが表示されていることを確認してください．

ストリーム --ストリーム  プログラムからファイルに保存されているデータを「読み込む」ことや「書き込む」ことができます． ファイルに何かしらの操作を行う場合は，ストリームという仕組みを利用します． ストリームとは，「データの流れ」を意味しており，水道管の中を水が流れる様子に似ています． ファイルに蛇口を取り付けて，その蛇口を捻ると，ファイルに保存されているデータが少しずつ流れてくるイメージです． ここでは，10人の身長と体重が保存されたファイルからデータを読み込んでみましょう． データは氏名，身長[cm]，体重[kg]で構成され，それぞれ「,（カンマ）」で区切られていることに注意してください． このようにカンマで区切られたファイルをCSV（Comma-Separated Values）形式と呼びます． ファイルをダウンロードしたら，Eclipseのプロジェクトの中にコピーしておいてください．
 ファイルの読み込み --ファイルの読み込み  measure.csvから文字列データを読み込むには下記のように記述します． ファイルの読み込みにはFileReaderクラスとBufferedReaderクラスを利用しますが， ここではファイルに取り付ける蛇口がFileReader， 蛇口から流れてくるホースの役割がBufferedReaderクラスと考えてください． line=br.readLine()でファイルから1行ずつ読み込み，System.out.println(line)でコンソール出力しています． ファイルの終端に到達すると，readLine()はnullという値を返すため， while文でlineがnullになるまで，ファイルからの読み込みを繰り返しています．
 実は上記のコードだけではエラーが残ったままです． このエラーを取り除くには例外処理が必要です． 例外とはプログラムの実行中に発生する想定外の事態を意味しており， 例えば「対象のファイルが存在しない」「空っぽ（null）の変数を利用しようとした」などの状態が該当します． ファイル読込に利用するFileReaderとBufferedReaderはこの例外処理が必要なクラスです． 例外処理は下記のように，例外の発生の可能性のある命令をtry{}で囲み，例外発生時の命令をcatch(例外の種類){}に記述します．
try{ 実行する命令 }catch(例外の種類){ 例外発生時に実行する命令 } 下記のコードを参考に例外処理を施してmeasure.csvから文字列データを読み込んでみましょう． ここで，e.printStackTrace();は例外の原因を突き止めるために，例外に関する情報を遡って表示する命令です． また，IOExceptionは入出力に関する例外を意味しています． プログラムの実行後に，コンソールの出力結果を確認してください．
 CSV形式の処理 --CSV形式の処理  前述したようにCSV形式のファイルは「,（カンマ）」で区切られています． カンマで区切られた文字列（トークン）を取り出すにはStringTokenizerというクラスを利用します． 下記のコードを参考にトークン毎に取り出して，コンソールに出力してみましょう． ここで，new StringTokenizer(line, &amp;quot;,&amp;quot;)は， 変数lineに代入されている文字列を「,（カンマ）」で分割して取得することを表しています． また，身長と体重は整数のため，Integer.</description>
    </item>
    
    <item>
      <title>プログラミング</title>
      <link>https://mukai-lab.info/pages/classes/programming/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://mukai-lab.info/pages/classes/programming/</guid>
      <description>科目名: プログラミング
講義室: 名古屋校舎教室
開講学期: 春学期
科目種別: 講義
テーマ: プログラムの基本的な構造の理解とコードの実装
概要 「プログラミングは難しい」と言う先入観を払拭し，「創造すること」の楽しさを体験することを目標とする．AIやデータサイエンスの実装に用いられるPythonのコードエディタMuを利用することで，視覚的に実行結果を捉えながら，プログラミングの基礎を修得する. グラフィックスを表現するTurtleライブラリや，ゲーム開発を目的としたPygame Zeroライブラリを利用する．
内容／スケジュール  コードエディタ「Mu」の確認 Turtle① Turtleグラフィックスの基本 Turtle② 変数と繰り返し Turtle③ 乱数と条件分岐 Turtle④ データ型と関数 Turtle⑤ イベントの処理 Turtle⑥ フラクタル図形 Pygame Zero① Pygame Zeroの基本 Pygame Zero② フレーム処理とクラス Pygame Zero③ スプライトとイベント処理 Pygame Zero④ アニメーションとサウンド Pygame Zero⑤ マップの作成  参考書籍</description>
    </item>
    
    <item>
      <title>プログラミング1</title>
      <link>https://mukai-lab.info/pages/classes/programming_1/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://mukai-lab.info/pages/classes/programming_1/</guid>
      <description>授業科目区分: 専門教育科目
単位数: 2単位
開講学科: 文化情報学科/メディア情報学科
学年: 2年次
関連科目: プログラミング2，プログラミング応用
授業テーマ: ビジュアルデザインのためのプログラミング言語「Processing」の修得
授業内容 「Processing」は，キャセイ・レアスとベンジャミン・フライによって開発されたビジュアルデザインのためのプログラミング言語である．開発者は，コンピュータとの相互作用とのなかで，楽しくプログラミングすることを目的にこの言語を開発した．この授業では，図形を描くことから始め，アニメーション，拡張現実（AR）など，視覚的に楽しいプログラミングを体験すると共に，変数や配列などプログラミングには必須の知識を学ぶ．
授業計画  Processingの開発環境の確認 基本図形の描画 変数と繰り返し 条件分岐 アニメーションの表示 イベントの処理 画像処理 オブジェクト指向 ３Dグラフィックス カメラ映像の表示 OpenCVを利用した顔検出 ARToolkitを利用した拡張現実  動画ファイル版  カメラ映像の表示(動画ファイル版) OpenCVを利用した顔検出（動画ファイル版） ARToolkitを利用した拡張現実（動画ファイル版)  参考書籍</description>
    </item>
    
    <item>
      <title>プログラミング応用（JavaScript）</title>
      <link>https://mukai-lab.info/pages/classes/applied_programming_wa/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://mukai-lab.info/pages/classes/applied_programming_wa/</guid>
      <description>授業科目区分: 専門教育科目
単位数: 2単位
開講学科: 文化情報学科
学年: 3年次
関連科目: プログラミング1，プログラミング2
授業テーマ: JavaScriptを利用したWebアプリの開発
授業内容 ウェブを介してブラウザで実行可能なアプリケーションはWebアプリと呼ばれる．動画共有サービスの「YouTube」や，Webメールの「Gmail」，SNSの「Twitter」などはWebアプリの代表である．本講義では，Webアプリを構成するHTML，CSS，JavaScriptの基本を学ぶ．また，機械学習ライブラリのml5.jsを利用してAI技術を組み込んだアプリを開発する．開発環境にはオンラインで実装が可能なCodePenを採用する．
授業計画  Webアプリの開発 HTML&amp;amp;CSSの基本 JavaScript①・変数とデータ型 JavaScript②・配列と繰り返し JavaScript③・条件分岐 JavaScript④・関数 JavaScript⑤・オブジェクト指向 Vue.js①・データバインディング Vue.js②・フォーム処理 Vue.js③・コンポーネント p5.js①・図形描画とイベント p5.js②・アニメーションと衝突処理  旧資料 jQuery
 jQuery①・DOM操作 jQuery②・フォーム処理  ml5.js
 AIを活用したWebアプリ①・画像分類 AIを活用したWebアプリ②・顔検出 AIを活用したWebアプリ③・ハンドポーズの検出  参考書籍</description>
    </item>
    
    <item>
      <title>プログラミング応用（Java）</title>
      <link>https://mukai-lab.info/pages/classes/applied_programming/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://mukai-lab.info/pages/classes/applied_programming/</guid>
      <description>授業科目区分: 専門教育科目
単位数: 2単位
開講学科: 文化情報学科 学年: 3年次
関連科目: プログラミング1，プログラミング2
授業テーマ: オブジェクト指向言語「Java」の修得
授業内容 「Java」は，サン・マイクロシステムズが開発したオブジェクト指向のプログラミング言語である．Javaはプラットフォームに依存せず携帯電話から家電製品まで広く動作する特徴を備えている．安全性を保持するためのオブジェクト指向という概念を中心に学び，最後にはオリジナル作品を制作する．
授業計画  Javaの開発環境の確認 式と演算子 条件分岐 配列と繰り返し 乱数生成とキーボード入力 ファイル入出力 オブジェクト指向① クラスとメソッド オブジェクト指向② 継承とインターフェイス JavaFX1 入力フィールドとボタン JavaFX2 レイアウトとグラフィックス JavaFX3 マウスとキーボード JavaFX4 アニメーション  参考書籍</description>
    </item>
    
    <item>
      <title>プロジェクト</title>
      <link>https://mukai-lab.info/projects/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://mukai-lab.info/projects/</guid>
      <description>向研究室は他大学や非営利団体と連携しながら「運転支援」「シビックテック」「障害支援」の研究プロジェクトに取り組んでいます． 共同研究や連携イベントの開催をご希望される場合はお気軽にお問い合わせください．
運転支援
シビックテック
障害者支援</description>
    </item>
    
    <item>
      <title>マウスとキーボード</title>
      <link>https://mukai-lab.info/pages/classes/applied_programming/chapter11/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://mukai-lab.info/pages/classes/applied_programming/chapter11/</guid>
      <description>プロジェクトの準備 --プロジェクトの準備  Eclipseで新規にプロジェクトを作成しましょう． メニューから[ファイル]-[新規]-[Javaプロジェクト]をクリックして，「新規Javaプロジェクトの作成」を開きます． ここでは，プロジェクト名に”Project11”を入力ます． また，JREは&amp;rdquo;プロジェクト固有のJREを使用&amp;ldquo;を選択します． 最後に，[完了]をクリックしましょう． パッケージ・エクスプローラに作成したプロジェクトが表示されていることを確認してください．

Applicationクラスを継承したMyApplicationクラスを作成しましょう． メニューから[ファイル]-[新規]-[クラス]をクリックして，「新規Javaクラス」を開きます． まず，名前に”MyApplication”を入力します． 次にスーパークラスを設定するために，[参照]ボタンから「スーパークラスの選択」を開き， 一致する項目からjavafx.application.Applicationを選択して，[OK]をクリックします． 最後に[完了]をクリックしましょう．

Applicationクラスの抽象メソッドであるstartメソッドをオーバーライドしておきます． 下記コードを参考に，タイトルをProject 11，幅を500px，高さを500pxに設定しましょう． プログラムの実行後にウィンドウが表示されることを確認してください．
 
プログラム実行時の注意  JavaFXはmainメソッドがなくともプログラムの実行が可能という特徴を持っています． しかし，Eclipseの現バージョンでは未対応のため，下記のコードをMyApplicationクラスに記述する必要があります． プログラム実行の前に，必ず下記のコードをソースコードに挿入してください．
 マウス・イベント --マウス・イベント  今回はマウス操作に応じてキャンバスに絵を描くことに挑戦していきましょう． 前準備として，下記のコードを参考にCanvasクラスをウィンドウに配置してください． レイアウトペインとしてVBoxクラスを利用しています． プログラムの実行後に表示されるウィンドウを確認してください．
 
キャンバス上でのマウスのクリックを検知するには， setOnMouseClicked()メソッドを利用します． このメソッドの引数にはラムダ式を利用して下記のように記述します． ラムダ式の左側のeventはMouseEventクラスのインスタンスで， マウスの状態や位置などの情報を保持しています． 一方，ラムダ式の右側のpaint(event);はマウスがクリックされたときに呼び出されるメソッドです．
canvas.setOnMouseClicked(event -&amp;gt; paint(event)); 下記のコードを参考に，マウスがクリックされると，クリックされた位置に塗りつぶしの円を描いてみましょう（色はデフォルトの黒）． 円を描くコードはpaint(event)メソッドとして定義していることに注意してください． マウスの位置はMouseEventクラスのgetX()メソッドとgetY()メソッドで取得しています． プログラムの実行後に，キャンバスをクリックすると，円が描かれることに確認してください．
 
キーボード・イベント --キーボード・イベント  ウィンドウ上でのキー入力を検知するには，setOnKeyPressed()メソッドを利用します． このメソッドの引数にはラムダ式を利用して下記のように記述します． ラムダ式の左側のeventはKeyEventクラスのインスタンスで， 押されたキーの状態や種類などの情報を保持しています． 一方，ラムダ式の右側のchange(event)はキーが押されたときに呼び出されるメソッドです．
scene.setOnKeyPressed(event -&amp;gt; change(event)); 下記のコードを参考に，塗りつぶしの色を，F1を押すと赤，F2を押すと青，F3を押すと黒に切り替えられるようにしましょう． 押されたキーの種類は列挙型KeyCodeで表され，getCode()メソッドで取得することができます（例，F1キーはF1という表記になる）． setFill()メソッドを利用して，キーがF1のときColor.</description>
    </item>
    
    <item>
      <title>レイアウトとグラフィックス</title>
      <link>https://mukai-lab.info/pages/classes/applied_programming/chapter10/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://mukai-lab.info/pages/classes/applied_programming/chapter10/</guid>
      <description>プロジェクトの準備 --プロジェクトの準備  Eclipseで新規にプロジェクトを作成しましょう． メニューから[ファイル]-[新規]-[Javaプロジェクト]をクリックして，「新規Javaプロジェクトの作成」を開きます． ここでは，プロジェクト名に”Project10”を入力します． また，JREは&amp;rdquo;プロジェクト固有のJREを使用&amp;ldquo;を選択します． 最後に，[完了]をクリックしましょう． パッケージ・エクスプローラに作成したプロジェクトが表示されていることを確認してください．

Applicationクラスを継承したMyApplicationクラスを作成しましょう． メニューから[ファイル]-[新規]-[クラス]をクリックして，「新規Javaクラス」を開きます． まず，名前に”MyApplication”を入力します． 次にスーパークラスを設定するために，[参照]ボタンから「スーパークラスの選択」を開き， 一致する項目からjavafx.application.Applicationを選択して，[OK]をクリックします． 最後に[完了]をクリックしましょう．

Applicationクラスの抽象メソッドであるstartメソッドをオーバーライドしておきます． 下記コードを参考に，タイトルをProject 10，幅を500px，高さを500pxに設定しましょう． プログラムの実行後にウィンドウが表示されることを確認してください．
 
プログラム実行時の注意  JavaFXはmainメソッドがなくともプログラムの実行が可能という特徴を持っています． しかし，Eclipseの現バージョンでは未対応のため，下記のコードをMyApplicationクラスに記述する必要があります． プログラム実行の前に，必ず下記のコードをソースコードに挿入してください．
 レイアウト --レイアウト  テキストフィールドやボタンなどのコントロールをレイアウトするにはレイアウトペインを利用します． 前回は垂直に並べるVBoxクラスを利用しましたが， 今回はアプリケーションのレイアウトに向いているBorderPaneクラスを利用してみましょう． BorderPaneクラスはウィンドウを中央，上，下，左，右に5分割してコントロールを配置します．
ここでは，ウィンドウの左右にボタン， そして，ウィンドウの中央にキャンバスを配置します． キャンバスを作成するには，下記のようにCanvasクラスをインスタンス化します（Canvasクラスの詳細は後述）． キャンバスの幅と高さを400pxに設定しています．
Canvas canvas = new Canvas(400, 400); 次に，下記のようにBorderPaneクラスをインスタンス化し，中央にコントロールを配置します． 中央，上，下，左，右に配置するにには，それぞれ，setCenter()メソッド，setTop()メソッド， setBottom()メソッド，SetLeft()メソッド，setRight()メソッドを利用します．
BorderPane pane = new BorderPane(); pane.setCenter(canvas); 下記のコードを参考に，ウィンドウの左右のボタン，ウィンドウの中央にキャンバスを配置してください． プログラムの実行後に表示されるウィンドウを確認してください．
 
これまでに紹介したVBox，BorderPane以外にも，水平に配置するHBox， 左から右に配置するFlowPane，行列に分割して配置するGridPaneなどのレイアウトペインがあります． 詳細はオラクルが提供するドキュメントを参考にしてください．
グラフィックス --グラフィックス  ウィンドウに文字や図形などのグラフィックスを表示するにはCanvasクラスを利用します． キャンバスに何かを描くときは，getGraphicsContext2D()メソッドを利用してGraphicsContextクラスのインスタンスを取得します． GraphicsContextクラスには下記のようなメソッドが用意されています．</description>
    </item>
    
    <item>
      <title>ロボホンの開発環境の構築</title>
      <link>https://mukai-lab.info/pages/tech/robohon/robohon1/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://mukai-lab.info/pages/tech/robohon/robohon1/</guid>
      <description>ロボホンとは  ロボホン（RoBoHoN）はシャープ株式会社が開発する人型のロボットであり，音声UIを利用して自然言語で会話が出来ることを特徴としています． ロボホンのOSはグーグル社が開発するAndroidであり，Android用のアプリ開発と同様にロボホンのアプリを制作することができます． ロボホンの開発に必要なRoBoHoN Software Development Kitが公開されており， ガイドラインに従って音声UIを利用したアプリを開発することが可能です． ここで，ガイドラインとは，ロボホンの世界観を維持するための，ロボホンの キャラクター ， 話し方 ， ユーザとの関係性 のことを指しています． 今回は，ロボホンのアプリ開発に必要な環境の構築方法に関して解説します．
開発環境  ロボホンアプリの開発には下記の環境が必要です． ココロプランには，「ビジネス基本プラン」「ビジネスプラン2000」など数種類が設定されており， プランに応じて月毎の会話上限が定められています． アプリ開発で頻繁に音声UIを利用する場合は高額なプランも検討する必要があります．
 ロボホン本体（現状ではエミュレータは存在しない） ネットワーク環境（音声UIを利用するため） ココロプランの契約（本体購入時に同時契約）  開発プラットフォームとしては，Android Studioを利用します（ロボホンのOSはAndroid 5.0です）． また，Android Studio のバージョンは 1.5 以降が必要とされており，今回は現時点での最新版である 2.3.3.0を採用します(2017年9月18日)． ファイルサイズは約1.9GBと，かなり大きいので注意してください．

Android Studioのインストール・パッケージをダウンロードしたら，インストールを始めましょう． インストールが完了したらロボホンのアプリ開発に必要なパッケージを追加でインストールします． まずは，バージョン 1.5 の Android SDKです． Settingsのメニューから[Appearance&amp;amp;Behavior]-[System Settings]-[Android SDK]を選択し， Android 5.0 (Lollipop) にチェックを入れて Apply をクリックします．

同様にAndroid SDK Build-Toolsを追加します． バージョンは21.0.0以降にチェックを入れて Apply をクリックします（Show Package Detailsをクリックするとバージョンの選択が可能です）．

開発したアプリをデバッグする際に，音声対話に失敗することを回避するために， Instant Run の設定を無効化します． Settingsのメニューから[Build, Execution, Developemnt]を選択し，全てのチェックをはずします． これで，Android Studio の準備は完了です．</description>
    </item>
    
    <item>
      <title>ローカルストレージ</title>
      <link>https://mukai-lab.info/pages/classes/graduation_preperation_1/chapter5/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://mukai-lab.info/pages/classes/graduation_preperation_1/chapter5/</guid>
      <description>ローカルストレージとは -- ローカルストレージとは  従来のウェブブラウザでは，データを保存する仕組みとして， クッキー(Cookie) と呼ばれる方法が主に利用されていました． しかし， クッキー は保存できるデータサイズが4キロバイトしかなく，ウェブページの更新毎に読込む必要がありました． そこで，HTML5では，クッキーに代わる新たな仕組みとして ウェブストレージ（Web Strage） が導入されました． ウェブストレージでは，5メガバイトのデータの保存が可能であり，クッキーのように自動で読込みが行われないため， より安全なデータの送受信が可能です． ウェブストレージ には下記の２種類があります．
 セッションストレージ（Session Storage） ローカルストレージ（Local Storage）  前者の セッションストレージ は，ブラウザのウィンドウ毎に，データが記録されるストレージであり，ウィンドウが閉じられると，そのデータは失われるという特徴があります． 後者の ローカルストレージ は，永続的にブラウザにデータが記録されるストレージであり，オリジン（ドメインとポートの組み合わせ）で区別されるという特徴があります． Monacaのアプリでは，このローカルストレージを利用することで，データを永続的に保存しておくことができます． つまり，ローカルストレージにデータを記録しておけば，アプリを終了してもデータが失われることがありません． そこで，今回はローカルストレージを利用した辞書アプリを作成してみましょう．
キー・バリュー・ストア型データベース（KVS） -- キー・バリュー・ストア型データベース  企業等で利用されているデータベースの大部分は 関係データベース と呼ばれる仕組みを採用しています． 一方で，関係データベース はSNSなど膨大な情報を高速に処理するには不向きです． そこで，キー・バリュー・ストア型データベース に代表されるNoSQLと呼ばれる仕組みが部分的に利用されるようになってきました． ローカルストレージ も，この キー・バリュー・ストア型データベース と同じ構造を持ちます． その構造は極めてシンプルで，キー（Key） と バリュー（Value） の一対のペアでデータを記録するという方法です． 例えば，下記のように英単語を キー ，そして，その和訳を バリュー として記録しておければ， 英単語（キー） から， 和訳（バリュー） を検索することができます．
   Key Value     Apple りんご   Banana バナナ   Grapes ぶどう    プロジェクトの作成 -- プロジェクトの作成  今回は，英単語 と 和訳 を登録するオリジナルの辞書アプリを作成しましょう． ダッシュボードから【新規プロジェクトの作成】-【Onsen UI】-【Onsen UI V2 JS Navigation】を選択します． プロジェクト名を 辞書アプリ ，説明を ローカルストレージを利用した辞書アプリ とします． プロジェクトを作成したら MonacaクラウドIDE の画面を開きましょう．</description>
    </item>
    
    <item>
      <title>主成分分析</title>
      <link>https://mukai-lab.info/pages/classes/advanced_studies_seminar_2/chapter13/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://mukai-lab.info/pages/classes/advanced_studies_seminar_2/chapter13/</guid>
      <description>主成分分析とは -- 主成分分析とは  展開演習２の多変量解析と呼ばれる手法を取り上げます． その名が示すように複数の変数を対象に相関や共通性を見つけることが目的となります． 今回は，その中でも，複数の変数を合成して，次元（要素数）を圧縮する主成分分析に注目します． 主成分分析を完全に理解するには数学的な知識が必要となりますが，ここではR言語を利用して直観的に理解することを目指します． このような分析手法は，理解 も重要ですが，使える ことが最も重要です． 対象のデータとして，算数と理科の成績のデータ（CSV形式）を使用するので，事前にダウンロードしておきましょう．
 ファイルをダウンロードしたら，read.csv関数を利用して， 変数scoreにデータフレームとして読み込んでおきましょう．
score &amp;lt;- read.csv(&amp;#34;score2.csv&amp;#34;) スクリプトの作成 -- スクリプトの作成  コードを入力し保存するためのスクリプトを作成しましょう． [ファイル]-[新しいスクリプト]をクリックし，Rエディタを表示します． 次に，[ファイル]-[保存]をクリックして，スクリプトを保存します． このとき，ファイル名はchapter13としてください． また，ファイルの保存場所と作業ディレクトリをデスクトップに変更しておきます．
合成変数 -- 合成変数  主成分分析では，分散を最大化するような合成変数を求めることが目的となります． 合成変数f(X)は，算数の得点をx_1， 理科の得点をx_2とすると， 下記の式で与えられます．
f(X) = w_1 \times x_1 + w_2 \times x_2  それぞれの得点に，重みw_1，w_2を掛けただけの簡単な式です． それでは，この重みの意味を考えていましょう． まずは，w_1=1，w_2=0の場合はどうでしょうか．
x &amp;lt;- as.matrix(score[,2:3]) w1 &amp;lt;- matrix(c(1,0),nrow=2,ncol=1) &amp;gt; x %*% w1 [,1] [1,] 68 [2,] 78 [3,] 59 [4,] 65 [5,] 74 [6,] 29 [7,] 40 [8,] 71 [9,] 33 [10,] 53 [11,] 46 [12,] 27 [13,] 57 [14,] 48 [15,] 90 結果は算数の得点となります． これは理科の得点という情報を削って，新しい合成変数を生成したと考えることができます． これは，下記のように，本来は２次元のデータを，算数という１次元の軸に射影したとみなせます．</description>
    </item>
    
    <item>
      <title>乱数生成とキーボート入力</title>
      <link>https://mukai-lab.info/pages/classes/applied_programming/chapter5/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://mukai-lab.info/pages/classes/applied_programming/chapter5/</guid>
      <description>プロジェクトの準備 -- プロジェクトの準備  Eclipseで新規にプロジェクトを作成しましょう． メニューから[ファイル]-[新規]-[Javaプロジェクト]をクリックして，「新規Javaプロジェクトの作成」を開きます． ここでは，プロジェクト名に”Project5”を入力して，[完了]をクリックしましょう． パッケージ・エクスプローラに作成したプロジェクトが表示されていることを確認してください．

続いてソースファイルを作成しましょう． メニューから[ファイル]-[新規]-[クラス]をクリックして，「新規Javaクラス」を開きます． ここでは，名前に”MyClass”を入力し，public static void main(String[] args)(V)にチェックを入れ，[完了]をクリックしましょう． パッケージ・エクスプローラに作成したソースファイルが表示されていることを確認してください．

乱数生成 -- 乱数生成  サイコロの出た目のように規則性がなく予測不能な数値のことを乱数と呼びます． コンピュータではその性質から完全な乱数を生成することは出来ないため， 擬似乱数と呼ばれる乱数とほぼ同じ特徴を持った値を生成します． 0以上，かつ，n未満を条件とした整数の乱数を生成するには下記のように記述します． RandomはJavaのライブラリに含まれるクラスの1つですが詳細は省略します．
Random r = new Random(); int x = r.nextInt(n); 下記のコードを参考に，int型の変数xを宣言し，0～2までの乱数を代入してみましょう． プログラムの実行後に，コンソールの出力結果を確認してください． 実行毎に出力される値が変化することが分かります．
 乱数を利用しておみくじを作成してみましょう． 下記のコードを参考に，変数xの値に応じて，ランダムに”大吉”，”吉”，”凶”をコンソールに出力させてみましょう． プログラムの実行後に，コンソールの出力結果を確認してください．
 キーボード入力 -- キーボード入力  ユーザから入力を受け取る方法の1つがキーボードです． キーボードから文字列を受け取るには下記のように記述します． ScannerはJavaのライブラリに含まれるクラスの1つですが詳細は省略します．
Scanner s = new Scanner(System.in); String text = s.nextLine(); s.close(); 下記のコードを参考に，変数nameにキーボードから入力した文字列を代入してみましょう． ここで，System.out.print()は，System.out.println()と同様に文字列をコンソールに出力する命令ですが，改行しないという点が異なります． また，コンソールへの出力の際には，文字列を連結するための演算子「+」を利用していることに注意が必要です．
 キーボードから整数を受け取るには下記のように記述します．
Scanner s = new Scanner(System.</description>
    </item>
    
    <item>
      <title>卒業研究指導1</title>
      <link>https://mukai-lab.info/pages/classes/graduation_preperation_1/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://mukai-lab.info/pages/classes/graduation_preperation_1/</guid>
      <description>授業科目区分: 専門教育科目 単位数: 2単位 開講学科: 文化情報学科 学年: 4年次 関連科目: 卒業研究指導2，卒業研究 授業テーマ: Monacaを利用したスマートフォンアプリの制作
授業内容 Monacaはクラウドで「HTML5ハイブリッドアプリ」を開発する環境の一つである． アプリの開発に必要な「コーディング」「デバッグ」「ビルド」などの一連の作業を ブラウザ（Chrome）で実行することが可能となっている 本授業では，Monacaを利用して，位置情報アプリやカメラアプリなどの 開発を経験しながら，オリジナル・アプリの制作を目指す． 事前に，Monacaのアカウントを作成し， 各自のスマートフォンにMonacaデバッガーをインストールしておくこと．
授業計画  Monacaでアプリ開発① Vue.jsの利用 Monacaでアプリ開発② Onsen UIの利用 Monacaでアプリ開発③ v-forとv-ifの利用 Monacaでアプリ開発④ Leafletの利用 Monacaでアプリ開発⑤ Chart.jsの利用  旧資料  Onsen UI① コンポーネント Onsen UI② テキスト入力 Onsen UI③ テーマローラー Onsen UI④ ジェスチャー操作 ローカルストレージ グラフの表示 地図の表示  参考書籍</description>
    </item>
    
    <item>
      <title>因子分析</title>
      <link>https://mukai-lab.info/pages/classes/advanced_studies_seminar_2/chapter14/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://mukai-lab.info/pages/classes/advanced_studies_seminar_2/chapter14/</guid>
      <description>因子分析とは -- 因子分析とは  因子分析は，主成分分析と同じ多変量解析の手法の一つです． 主成分分析は観測された変数を合成することが目的であるのに対し， 因子分析は観測された変数そのものが 潜在変数（因子） の合成であるとみなします． 下図は，主成分分析と因子分析の違いを表しています． 主成分は，全ての変数を合成することで求められます． 一方，因子は，独自因子 と 共通因子 に分かれており， 独自因子 は特定の変数に影響するのに対し，共通因子 は複数の変数に影響を与えます．

主成分分析は，次元を圧縮することで，データを可視化することに向いていますが，変数間の関係を分析することは苦手です． 一方，因子分析は得られた 因子 は変数間の関係を表しており，データの分析に適しています． しかし，因子分析は，主成分分析より数学的に難解であり，その仕組を完全に理解することは容易ではありません． 因子分析だけで本が一冊書けてしまう程であり，統計だけではなく，行列，ベクトルなどの知識が不可欠です． 今回も，理解 より 使える ことを重要視して，因子分析を学びましょう． 対象のデータとして，５教科の **成績のデータ（CSV形式）**を使用するので，事前にダウンロードしておきましょう．
 ファイルをダウンロードしたら，read.csv関数を利用して， 変数scoreにデータフレームとして読み込んでおきましょう．
score &amp;lt;- read.csv(&amp;#34;score.csv&amp;#34;) スクリプトの作成 -- スクリプトの作成  コードを入力し保存するためのスクリプトを作成しましょう． [ファイル]-[新しいスクリプト]をクリックし，Rエディタ を表示します． 次に，[ファイル]-[保存]をクリックして，スクリプトを保存します． このとき，ファイル名はchapter14としてください． また，ファイルの保存場所と作業ディレクトリをデスクトップに変更しておきます．
主成分得点と因子得点 -- 主成分得点と因子  ここで，もう一度，主成分分析と因子分析の違いを整理しておきましょう． 主成分得点は下記の式で表すことができます． ここで，x_1，x_2は， 国語や算数の得点など 変数 を表しており，
w_1，w_2は， それら変数の 重み であると共に，主成分を表すベクトルでした．
f(X) = w_1 \times x_1 + w_2 \times x_2  一方，因子分析は下記の式で表すことができます． ここで，f_1(X)，f_2(X)は因子得点と呼ばれます． この因子得点は，共通因子の影響を得点に換算した推定値であり，個体ごとに得点が決まります． また，w_1，w_2は，因子得点の重みであり，因子負荷量 と呼びます． 主成分を表すベクトルとは異なり，||w|| = 1という条件は満たしません（ベクトルの長さにも意味があります）． 注意すべきは，独自因子のeであり，これが主成分分析との大きな違いを生みます （e=0とすると主成分分析と同じアプローチになる）．</description>
    </item>
    
    <item>
      <title>地図の表示</title>
      <link>https://mukai-lab.info/pages/classes/graduation_preperation_1/chapter7/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://mukai-lab.info/pages/classes/graduation_preperation_1/chapter7/</guid>
      <description>地図の表示 -- 地図の表示  今回は地図サービスとして有名なGoogle MapsのウェブAPIであるGoogle Maps Javascript APIを利用して地図アプリを制作してみましょう． 現在のAPIのバージョンは3.27であり，APIを利用するには，Googleアカウントにログインした状態で，Google API Consoleで認証情報を登録する必要があります（2017年1月7日時点）． まずは，Google API Consoleにアクセスし，ライブラリのリンクをクリックし， Google Maps JavaScript API を有効にします

次にAPIを利用するための認証情報である APIキー を作成します． 認証情報のリンクをクリックし，APIキー を選択します．

生成された APIキー をコピーしておきましょう． 後でウェブページに埋め込みます．
プロジェクトの作成 -- プロジェクトの作成  今回も日進市のオープンデータミュージアムを利用して世帯数のデータを地図上に表示するアプリを作成しましょう． ダッシュボードから【新規プロジェクトの作成】-【Onsen UI】-【Onsen UI V2 JS Minimum】を選択します． プロジェクト名を 地図アプリ ，説明を Google Maps APIを利用した日進市の世帯数の地図 とします． プロジェクトを作成したら MonacaクラウドIDE の画面を開きましょう．

Google Maps APIを利用した地図の表示 -- Google Maps APIを利用した地図の表示  それでは，Google Maps Javascript APIを利用して地図を表示させましょう． まずは地図を表示するための div要素 を作成します．
&amp;lt;div id=&amp;#34;map&amp;#34;&amp;gt;&amp;lt;/div&amp;gt; 上記のdiv要素に加え，html要素，body要素のサイズを明確に指定しておく必要があります． そこで， style.</description>
    </item>
    
    <item>
      <title>基幹演習</title>
      <link>https://mukai-lab.info/pages/classes/seminar_fundamental_areas/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://mukai-lab.info/pages/classes/seminar_fundamental_areas/</guid>
      <description>授業科目区分: 専門教育科目
単位数: 1単位
開講学科: 文化情報学科
学年: 2年次
授業テーマ: オープンデータを活用し，簡易な地図サービスを構築する
授業内容 自治体が提供しているオープンデータを基にデータの可視化や分析の方法を学習します． また，オープンストリートマップを活用し，簡易な地図サービスを構築します． これらは，シビックテック と呼ばれる活動の一環であり， これを機会に学外のアイデアソンやハッカソンのイベントに積極的に参加して欲しいです．
授業計画  オープンデータを利用した人口データの可視化 オープンデータを利用した天候データの相関分析 オンラインマップを利用したCSVデータのプロット オンラインマップを利用したGeoJSONデータのプロット オリジナルのオンラインマップの作成  旧資料（2020年度まで）  Excelを利用した7市町オープンデータの分析① グラフ作成 Excelを利用した7市町オープンデータの分析② 相関分析 オープンストリートマップを利用したオープンデータの可視化① uMap オープンストリートマップを利用したオープンデータの可視化② Leaflet オリジナル地図の発表  参考書籍</description>
    </item>
    
    <item>
      <title>基本図形の描画</title>
      <link>https://mukai-lab.info/pages/classes/programming_1/chapter2/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://mukai-lab.info/pages/classes/programming_1/chapter2/</guid>
      <description>スケッチの作成  Processingを起動して，新規にスケッチを保存しましょう． メニューから[ファイル]-[名前を付けて保存]をクリックして，「スケッチフォルダを名前を付けて保存」を開きます． ファイル名に「Project2」を入力し，[保存]をクリックしましょう． 保存先に「Project2」という名前のフォルダが作成されていることを確認してください．

ウィンドウのサイズ  図形はウィンドウ内の ピクセル に描画します． 各ピクセルは座標で示され，Processingではウィンドウの左上が原点となります． 左端からの距離が X座標 ，上端からの距離が Y座標 を表します． まずは，size()という命令文を用いて，ウィンドウのサイズを決めましょう． ここでは，300×300ピクセルを指定します． 下記を参考にコードを入力したら，Runボタンをクリックしてください． 指定したサイズのウィンドウが表示されることを確認してください．
 
基本図形の描画  Proceessingには基本的な図形を描く命令文が用意されています． 図形の描画など一連の処理をひとまとめにして，名前を付けたものを 関数 と呼びます（println()やsize()も関数です）．
点の描画 指定した座標に点を描くにはpoint()関数を利用します． point()関数の括弧の内側には，点を描くX座標とY座標を指定します． このように，関数の括弧の内側で指定する値のことを， 引数 と言います． ここでは，X座標が50，Y座標が50の位置に点を描いてみましょう． 下記を参考にコードを入力したら，Runボタンをクリックしてください． 指定した位置に点が描かれていることを確認してください．
point(x,y);  
線の描画 ２つの座標を結ぶ線を描くにはline()関数を利用します． 引数には２つの座標を指定します． ここでは，座標(50,100)から座標(50,200)に線を描いてみましょう． 下記を参考にコードを入力したら，Runボタンをクリックしてください． 指定した位置に線が描かれていることを確認してください．
line(x1, y1, x2, y2);  
長方形の描画 長方形を描くにはrect()関数を利用します． 引数には基準となる左上の座標と幅，高さを指定します． ここでは，座標(100,50)を基準に，幅100，高さ100の長方形を描いてみましょう． 下記を参考にコードを入力したら，Runボタンをクリックしてください． 指定した位置に長方形が描かれていることを確認してください．
rect(x, y, width, height);  
円の描画 円を描くにはellipse()関数を利用します． 引数には基準となる中心の座標と幅，高さを指定します（幅，高さを同じ値にすると正円になる）． ここでは，座標(150,200)を中心に，半径40の円を描いてみましょう． 下記を参考にコードを入力したら，Runボタンをクリックしてください． 指定した位置に円が描かれていることを確認してください．</description>
    </item>
    
    <item>
      <title>基礎演習</title>
      <link>https://mukai-lab.info/pages/classes/seminar_core_areas_learning/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://mukai-lab.info/pages/classes/seminar_core_areas_learning/</guid>
      <description>授業科目区分: 専門教育科目
単位数: 1単位
開講学科: 文化情報学科
学年: 1年次
授業テーマ: 情報に関する基礎的な知識や技術の習得
授業内容 大学での専門的な学習を行うためのトレーニングを目的とする． データ分析などに用いられるプログラミング言語 Python に注目する． 初学者向けのお絵かきライブラリである Turtle を利用して，フラクタル図形など様々な図形を描くことに挑戦する． また，オンラインでコーディングが可能な Google Colaboratory を利用する．
授業計画  Pythonの基礎・Turtleで図形を描いてみよう Pythonの基礎・制御構文で図形を描いてみよう Pythonの基礎・関数で図形を描いてみよう Pythonの基礎・フラクタル図形を描いてみよう  旧資料(2020年度)  Vue.jsを利用したWebアプリの開発・おみくじアプリ Vue.jsを利用したWebアプリの開発・お絵かきアプリ Vue.jsを利用したWebアプリの開発・検索アプリ  旧資料(2019年度)  Excelを利用した統計処理・相関係数 Excelを利用した統計処理・2項分布 Excelを利用した統計処理・正規分布  参考図書    参考書籍-- </description>
    </item>
    
    <item>
      <title>変数と繰り返し</title>
      <link>https://mukai-lab.info/pages/classes/programming_1/chapter3/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://mukai-lab.info/pages/classes/programming_1/chapter3/</guid>
      <description>スケッチの作成  Processingを起動して，新規にスケッチを保存しましょう． メニューから[ファイル]-[名前を付けて保存]をクリックして，「スケッチフォルダを名前を付けて保存」を開きます． ファイル名に「Project3」を入力し，[保存]をクリックしましょう． 保存先に「Project3」という名前のフォルダが作成されていることを確認してください．

データ型  Processingでは，「1」や「2」などの 整数 ，「0.1」や「1.1」などの 小数 をデータとして扱うことができます． これらデータの種類は データ型 で明確に区別されます． 例えば，整数は int というデータ型，小数は float というデータ型に該当します． 下記表に利用頻度の高いデータ型をまとめます． 取り敢えず表中の int ， float ， boolean ， String だけはしっかりと覚えておきましょう（正確にはStringはクラスでありデータ型ではない）．
   データの種類 データ型 例     整数 int 1, 2, 3   小数 float 0.1, 1.1, 10.1   真理値 boolean true, false   文字列 String &amp;ldquo;ABC&amp;rdquo;, &amp;ldquo;あいう&amp;rdquo;    変数  データを記憶しておくための箱が 変数 です． 変数を使用するには事前に 変数宣言 が必要です． 変数宣言はデータ型 変数名;と記述します． データ型とは int や float のことを指しています． 変数名は「変数に付ける名前」のことで，自由に設定が可能ですが， 「小文字で始まるわかりやすい名前」を設定することが望ましいとされています． 変数にデータを記憶させるには，変数=代入するデータ;と記述します． 変数にデータを記憶させることを 代入 と呼びます．</description>
    </item>
    
    <item>
      <title>対応のある2群のt検定</title>
      <link>https://mukai-lab.info/pages/classes/advanced_studies_seminar_2/chapter12/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://mukai-lab.info/pages/classes/advanced_studies_seminar_2/chapter12/</guid>
      <description>対応のある2群とは -- 対応のある2群とは  前回は独立な2群（対応のない2群）の検定を考えました． 今回は，対応のある2群 の検定に注目します． 対応のある2群 とは，2つの標本に含まれる対象に，何らかの対応関係があることを意味しています． 例えば，下記のように，同じ4人の被験者に対して，2種類の条件下で測定された2群のデータは，「対応のある2群」です．
条件1: x_1 = \{a,b,c,d\} \\ 条件2: x_2 = \{a&#39;,b&#39;,c&#39;,d&#39;\}  「独立な2群の検定」には，新しい検定統計量が必要でしたが， 「対応のある2群の検定」では，2群のデータの「変化量」に着目することで， 標準的なt検定の検定統計量を適用することが可能です．
スクリプトの作成 -- スクリプトの作成  コードを入力し保存するためのスクリプトを作成しましょう． [ファイル]-[新しいスクリプト]をクリックし，Rエディタを表示します． 次に，[ファイル]-[保存]をクリックして，スクリプトを保存します． このとき，ファイル名はchapter12としてください． また，ファイルの保存場所と作業ディレクトリをデスクトップに変更しておきます．
対応のある2群のt検定 -- 対応のある2群のt検定  それでは，下記の問題について考えていきましょう．
向研究室の学生を対象に実施した情報数学に関するテストの得点はx_1であった． その後，向による熱心な指導を行い，再度，情報数学に関するテストを実施したところ， その得点はx_2となった． 指導の前後における得点の平均値に有意な差はあるか． （どちらも同じ母集団からランダムサンプリングした標本だろうか）．
指導前: x_1 = \{63,75,72,67,71\} \\ 指導後: x_2 = \{82,70,78,81,79\}   ここでは，指導の前後という対応関係があることから，得点の 変化量 に注目します． 変化量はD = X_2 - X_1で与えられます．
変化量の母集団: D = X_2 - X_1\\ 変化量の標本: d = x_2 - x_1 = \{19,-5,6,14,8\}  この変化量が，平均\hat{\mu}， 分散\hat{\sigma}^2の正規分布に従うと仮定します．</description>
    </item>
    
    <item>
      <title>展開演習2</title>
      <link>https://mukai-lab.info/pages/classes/advanced_studies_seminar_2/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://mukai-lab.info/pages/classes/advanced_studies_seminar_2/</guid>
      <description>授業科目区分: 専門教育科目
単位数: 1単位
開講学科: 文化情報学科
学年: 3年次
関連科目: 統計の世界，データ解析入門
授業テーマ: R言語を利用したデータマイニング技術の修得
授業内容 オープンソースの統計解析ソフトウェアであるR言語を利用して，統計学の基礎から，機械学習などの応用まで幅広く学習する． 平均や分散などの基本統計量や，二項分布や正規分布などの基本的な確率分布を復習しておくこと． また，R言語は，SPSSのようなグラフィカル・ユーザ・インターフェースではなく， キーボードによるコマンド入力が必要となる． このため，本授業の履修者は，基本的なPCスキルを身に着けていることを前提とする．
授業計画  R言語の基本的な操作 R言語のデータ構造 R言語によるデータの視覚化 平均と分散 相関係数 2項分布 正規分布 母集団と標本 標準正規分布を用いた検定 t分布を用いた検定 独立な2群のt検定 対応のある2群のt検定 主成分分析 因子分析  参考書籍</description>
    </item>
    
    <item>
      <title>平均と分散</title>
      <link>https://mukai-lab.info/pages/classes/advanced_studies_seminar_2/chapter4/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://mukai-lab.info/pages/classes/advanced_studies_seminar_2/chapter4/</guid>
      <description>基本統計量 -- 基本統計量  統計量とは，観測したデータそのものではなく，それらのデータの特徴を代表的に表す値のことを表します． そのなかでも，基本統計量 は，平均，中央値，分散，標準偏差 などを指し， データの特徴を把握するための基本的な指標となります． 今回は，これら基本統計量を，公式や関数を利用して計算してみましょう． 対象のデータとして成績のデータ（CSV形式）を使用します． このデータは15人の生徒の国語，算数，理科，英語，社会の得点で構成されています．
 ファイルをダウンロードしたら，read.csv関数を利用して， 変数scoreにデータフレームとして読み込んでおきましょう（作業ディレクトリはデスクトップに変更）．
score &amp;lt;- read.csv(&amp;#34;score.csv&amp;#34;) 変数scoreの出力は下記のようになります．
&amp;gt; score 氏名 国語 算数 理科 英語 社会 1 青木 達也 60 68 72 39 71 2 石井 健二 65 78 82 37 75 3 北村 真子 84 59 85 87 84 4 河野 尚子 50 65 65 39 78 5 高木 健 72 74 83 30 83 6 西川 知里 50 29 67 62 72 7 福島 萌子 84 40 65 86 66 8 古川 翔太 78 71 82 34 88 9 山内 香菜 77 33 65 73 88 10 渡辺 太郎 76 53 75 60 71 11 浅野 渉 68 46 77 66 86 12 星野 弘 61 27 74 70 67 13 中谷 章 86 57 72 73 65 14 小泉 美沙 68 48 73 51 68 15 木下 萌子 78 90 100 53 79 スクリプトの作成 -- スクリプトの作成  コードを入力し保存するためのスクリプトを作成しましょう． [ファイル]-[新しいスクリプト]をクリックし，Rエディタを表示します． 次に，[ファイル]-[保存]をクリックして，スクリプトを保存します． このとき，ファイル名はchapter4としてください． また，ファイルの保存場所と作業ディレクトリをデスクトップに変更しておきます．</description>
    </item>
    
    <item>
      <title>式と演算子</title>
      <link>https://mukai-lab.info/pages/classes/applied_programming/chapter2/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://mukai-lab.info/pages/classes/applied_programming/chapter2/</guid>
      <description>プロジェクトの準備 -- プロジェクトの準備  Eclipseで新規にプロジェクトを作成しましょう． メニューから[ファイル]-[新規]-[Javaプロジェクト]をクリックして，「新規Javaプロジェクトの作成」を開きます． ここでは，プロジェクト名に”Project2”を入力して，[完了]をクリックしましょう． パッケージ・エクスプローラに作成したプロジェクトが表示されていることを確認してください．

続いてソースファイルを作成しましょう． メニューから[ファイル]-[新規]-[クラス]をクリックして，「新規Javaクラス」を開きます． ここでは，名前に”MyClass”を入力し，public static void main(String[] args)(V)にチェックを入れ，[完了]をクリックしましょう． パッケージ・エクスプローラに作成したソースファイルが表示されていることを確認してください．

リテラルとは -- リテラルとは  Javaに限らず一般的なプログラム言語では，「1」や「2」などの 数値，「ABC」や「あいう」などの 文字列 をデータとして扱うことが可能です． ソースコードにおいて使用されるこれらの数値や文字列のデータを リテラル と呼びます． Javaでは，整数 や 小数 など，リテラルの種類を表す データ型 が存在します． 例えば，「1」や「2」などの整数は，int というデータ型に該当します． 下記表に利用頻度の高いデータ型をまとめるので確認してください．
   リテラルの種類 データ型 例     整数 int 1, 2, 3   小数 double 0.1, 1.1, 10.1   真理値 boolean true, false   文字列 String &amp;ldquo;ABC&amp;rdquo;, &amp;ldquo;あいう&amp;rdquo;    この他にも，64ビットの大きさの整数を表すlongや，32ビットの大きさの小数を表すfloatなどのデータ型がありますが， 取り敢えずは表中のint，double，boolean，Stringだけはしっかりと覚えておきましょう（正確にはStringはクラスでありデータ型ではない）． 文字列データを表記する際は，対象となる文字列を「&amp;quot;（ダブルクォート）」で囲む必要がありますので注意が必要です．</description>
    </item>
    
    <item>
      <title>技術記事</title>
      <link>https://mukai-lab.info/tech/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://mukai-lab.info/tech/</guid>
      <description>Application  CrimeHeatmap MEME VISUALIZER StageMaker TableToSQL InsectMap WeatherPainApp  Atom  Atomに必須のプラグイン紹介  BITalino  BITalinoで光センサー BITalinoで筋電位センサー  CARLA Simulator  CARLAシミュレータの導入 CARLAでセマンティック・セグメンテーション  Codecomabat  CodeCombatでプログラミング学習  Emotiv  Emotivで脳波を可視化 Cotexで脳波データを取得 脳波データをフーリエ解析  enchant.js  MOONBlockでゲームプログラミング  Games  ひよこマン 水差し問題 ハノイの塔 8パズル  GitHub  GitHubの基本的な使い方 GitHub Pagesでの独自ドメインの設定 Git Bashのホームディレクトリの変更 ssh-Agentでパスフレーズの省略  Hugo  sedでJekyllからHugoに変換  Japan Search  ジャパンサーチからSPARQLでデータ取得  Java  Java 8における「Access Restriction」の回避  Jekyll  Jekyllデフォルトテンプレートの自動リンク Jekyllにおけるシンタックスハイライト Liquidを利用したファイルの埋め込み Jekyllでオープン・グラフ・プロトコル（OGP）の設定  Leaflet  オープンストリートマップでオリジナル地図を作成しよう  macOS  MacOSのセットアップ MacでEmacs  Processing  Processingではじめての画像処理  RoBoHoN  ロボホンの開発環境の構築 トリガを用いた発話 QRコードの読み取り ロブリックでロボホンをプログラミング！  Tableau  Tableauでオープンデータを可視化 Tableauで色々なグラフを作成しよう Tableauのダッシュボードを活用しよう Tableauのマップ機能でGoogle Fitを可視化  Tobii Eyetracker  Tobii Eye Trackerを利用した視線の認識 OpenCVを利用した視線位置の描画  Turtle Graphics  js-turtleで図形を描こう!</description>
    </item>
    
    <item>
      <title>授業資料</title>
      <link>https://mukai-lab.info/classes/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://mukai-lab.info/classes/</guid>
      <description>椙山女学園大学  基礎演習 基幹演習 人工知能 データベースシステム プログラミング1（Processing） プログラミング応用（JavaScript） プログラミング応用（Java） 展開演習1 展開演習2 知能情報システム データベース演習 卒業研究指導1  愛知大学  プログラミング（Python） 経営データ解析Ⅱ  中部大学  データベース  </description>
    </item>
    
    <item>
      <title>条件分岐</title>
      <link>https://mukai-lab.info/pages/classes/applied_programming/chapter3/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://mukai-lab.info/pages/classes/applied_programming/chapter3/</guid>
      <description>プロジェクトの準備 -- プロジェクトの準備  Eclipseで新規にプロジェクトを作成しましょう． メニューから[ファイル]-[新規]-[Javaプロジェクト]をクリックして，「新規Javaプロジェクトの作成」を開きます． ここでは，プロジェクト名に”Project3”を入力して，[完了]をクリックしましょう． パッケージ・エクスプローラに作成したプロジェクトが表示されていることを確認してください．

続いてソースファイルを作成しましょう． メニューから[ファイル]-[新規]-[クラス]をクリックして，「新規Javaクラス」を開きます． ここでは，名前に”MyClass”を入力し，public static void main(String[] args)(V)にチェックを入れ，[完了]をクリックしましょう． パッケージ・エクスプローラに作成したソースファイルが表示されていることを確認してください．

制御構文とは -- 制御構文とは  制御構文とは実行する命令文の順序を変化させるための構文です． 一般的に命令文はソースコードの「上から順に１つずつ」実行されるのが基本です． この「上から順に１つずつ」実行する制御を順次と呼びます． この他，条件によって異なる命令文を実行する制御を条件分岐， 条件を満たすまで同じ命令文を繰り返す制御を繰り返しと呼びます． 今回はこの条件分岐に関して学習します． 条件分岐を理解するには，条件を表現するための条件式を学ぶ必要があります． 次章では，まず条件式に関して確認していきましょう．
条件式とは -- 条件式とは  条件式とは，主に比較演算子や論理演算子を用いて表現され， 真（true）または偽（false）のどちらかの値を返す論理式のことです． この真（true）や偽（false）という値はboolean型となることに注意してください． 例えば，int型の変数xに代入されている値が数値3と一致するかどうかを条件式で表現するには，x == 3と表します． ここで，「==」は左辺と右辺が等しいかを判定する比較演算子です． 条件式で用いられる比較演算子を下記にまとめます．
   比較演算子 意味 例     A==B AとBは等しい x==3   A!=B AとBは等しくない x!=3   A&amp;gt;B AはBより大きい x&amp;gt;3   A&amp;gt;=B AはBと等しいか大きい x&amp;gt;=3   A&amp;lt;B AはBより小さい x&amp;lt;3   A&amp;lt;=B AはBと等しいか小さい A&amp;lt;=3    下記のコードを参考にint型の変数xを宣言して3を代入し， 上記の比較演算子の結果を確認してみましょう． プログラムの実行後に，コンソールの出力結果を確認してください．</description>
    </item>
    
    <item>
      <title>条件分岐</title>
      <link>https://mukai-lab.info/pages/classes/programming_1/chapter4/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://mukai-lab.info/pages/classes/programming_1/chapter4/</guid>
      <description>スケッチの作成  Processingを起動して，新規にスケッチを保存しましょう． メニューから[ファイル]-[名前を付けて保存]をクリックして，「スケッチフォルダを名前を付けて保存」を開きます． ファイル名に「Project4」を入力し，[保存]をクリックしましょう． 保存先に「Project4」という名前のフォルダが作成されていることを確認してください．

乱数の生成  規則性がないランダムな値のことを 乱数 と呼びます． コンピュータは完全な乱数を生成することは出来ないため， アルゴリズムに従って疑似的な乱数を生成します（ 疑似乱数 と呼ばれます）． コンピュータゲームにおける「トランプを配る」「サイコロを振る」などはこの疑似乱数を利用しています． Processingで疑似乱数を先生するにはrandom()関数を利用します． random()関数の引数には，生成する乱数の 下限（low） と 上限（high） を指定します． また，生成された乱数はfloat型のデータとなることに注意が必要です．
次に示すようにrandom()関数を利用して，0以上10未満の範囲で乱数を生成してみましょう．
 ここでは，for文を利用して，半径10の円を100箇所に描きましょう． 各円は，random()関数を利用して，ランダムな位置に配置します（ellipse()の引数はfloat型でもOK）． 下記を参考にコードを入力したら，Runボタンをクリックしてください． 実行毎に配置が変わる円が描かれていることを確認してください．
 
比較演算子  for文の 繰り返し条件 に記述されるi&amp;lt;10などは条件式と呼ばれます． また，「 &amp;lt; 」は 比較演算子 と呼ばれ，左辺と右辺を比較した結果， 真（true） または 偽（false） のどちらかを返す論理演算の一つです． この真（true）や偽（false）は boolean型 であることに注意してください． 例えば，変数aの値が5であるとき「a &amp;lt; 3」の結果は false となります． 比較演算子を下記表にまとめます．
   比較演算子 意味 例     A==B AとBは等しい x==3   A!</description>
    </item>
    
    <item>
      <title>標準正規分布を用いた検定</title>
      <link>https://mukai-lab.info/pages/classes/advanced_studies_seminar_2/chapter9/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://mukai-lab.info/pages/classes/advanced_studies_seminar_2/chapter9/</guid>
      <description>検定とは -- t検定とは  検定とは「標本から推定された母数が，確率的に正しいかどうか」を判断することを意味します． 検定は，統計的仮説検定とも呼ばれ，推測統計でも利用頻度の高い重要なテクニックです． 検定を行うための手順は下記のようになります．
1．母数に関する帰無仮説と対立仮説を立てる．
2. 検定統計量を選択する．
3. 信頼区間（棄却域）を決める．
4. 標本から検定統計量を計算する．
5. 検定統計量が棄却域に含まれれば，帰無仮説を棄却して，対立仮説を採用する．棄却域に含まれなければ，帰無仮説を採択する．
難しい単語がたくさん出てきましたが，これは追々説明していきます． ここでは，母集団が正規分布であり，母平均，母分散が既知であるときに適用可能な標準正規分布を用いた検定を考えます． この，標準正規分布を用いた検定 は Z検定 とも呼ばれます．
スクリプトの作成 -- スクリプトの作成  コードを入力し保存するためのスクリプトを作成しましょう． [ファイル]-[新しいスクリプト]をクリックし，Rエディタを表示します． 次に，[ファイル]-[保存]をクリックして，スクリプトを保存します． このとき，ファイル名はchapter9としてください． また，ファイルの保存場所と作業ディレクトリをデスクトップに変更しておきます．
検定の目的 -- 検定の目的  まずは下記の具体例を考えていきましょう．
文化情報学部の学生Xに情報数学に関するテストを行ったところ， その得点の平均\hat{\mu}は60， 分散\hat{\sigma}^2は100であった． このうち，向研究室に所属する5人の学生xの得点は下記であった． 向研究室に所属する学生xは， 文化情報学部の学生Xと， 同様の傾向があるか（母集団からランダムサンプリングした学生だろうか）．
x = \{63,75,72,67,71\}   母集団は「文化情報学部の学生X」， 標本は「向研究室に所属する学生x」と考えることができます． また，「標本平均の分布」をmとします． いずれも正規分布に従うと仮定すると，母集団の分布と，標本平均の分布は下記のようになります．
X \sim N(60,100)  m \sim N(60,100/5) = N(60,20)  ここで，標本の平均を求めてみましょう．
x &amp;lt;- c(63,75,72,67,71) &amp;gt; mean(x) [1] 69.</description>
    </item>
    
    <item>
      <title>正規分布</title>
      <link>https://mukai-lab.info/pages/classes/advanced_studies_seminar_2/chapter7/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://mukai-lab.info/pages/classes/advanced_studies_seminar_2/chapter7/</guid>
      <description>正規分布 -- 正規分布  正規分布 は，ガウス分布 とも呼ばれ，平均値に近い値の頻度が高く， 平均値から離れるほど頻度が低くなるという特徴を持った確率分布のことです． 例えば，「身長」や「体重」などの分布が正規分布に従うことが知られており， その他にも様々な社会現象や自然現象に当てはまると考えられています． また，分布が数学的に扱いやすい性質を持っていることから， 統計分析によく用いられ，最も重要な 確率分布 と言っても間違いありません． 今回は，サンプルデータを基に正規分布のグラフを描く事から始め，正規分布を利用して特定の区間の生起確率を求める方法を学びます．
スクリプトの作成 -- スクリプトの作成  コードを入力し保存するためのスクリプトを作成しましょう． [ファイル]-[新しいスクリプト]をクリックし，Rエディタを表示します． 次に，[ファイル]-[保存]をクリックして，スクリプトを保存します． このとき，ファイル名はchapter7としてください． また，ファイルの保存場所と作業ディレクトリをデスクトップに変更しておきます．
正規分布のグラフ -- 正規分布のグラフ  気象庁が公開している 愛知県名古屋市の９月の最高気温のデータを対象に考えていきます． このデータは，1891年から2016年までの，愛知県名古屋市の9月の最高気温を表しています．
年,最高気温 1891,28.7 1892,28.1 1893,28.6 1894,28.4 1895,28.3 1896,27.7 1897,27.3 1898,28 1899,25.4 1900,28.9 ...,... 2016,29.3 ファイルをダウンロードしたら，read.csv 関数を利用して， 変数tempにデータフレームとして読み込んでおきましょう（作業ディレクトリはデスクトップに変更）．
temp &amp;lt;- read.csv(&amp;#34;temperature.csv&amp;#34;) 次に，hist関数を利用して，最高気温のヒストグラムを表示しましょう． 範囲は25から32までとし，区間は0.5とします． seq関数は，規則性のある数列ベクトルを生成する関数であり， ここでは，25から32まで，0.5ずつ増やした数列（{25.0,25.5,26.0,26.5,&amp;hellip;,32}）を生成します．
hist(temp[,2],breaks=seq(25,32,0.5)) 
グラフを確認すると， 区間28-8.5 が最頻値となっていることが分かります． また，この区間から離れるにつれて緩やかに頻度が減り， 全体としては左右対称な 釣鐘型 と呼ばれる分布をしています． しかし，このグラフは，縦軸が頻度を表すヒストグラムであり，確率分布ではありません． そこで，hist 関数の引数にfreq=FALSE を設定し，縦軸を 確率密度 に変更します．</description>
    </item>
    
    <item>
      <title>母集団と標本</title>
      <link>https://mukai-lab.info/pages/classes/advanced_studies_seminar_2/chapter8/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://mukai-lab.info/pages/classes/advanced_studies_seminar_2/chapter8/</guid>
      <description>母集団と標本 -- 母集団と標本  統計の醍醐味の一つが「推測統計」です． 推測統計では，対象となるデータが大規模であるために，その一部を取り出したデータから推測するということを行います． このとき，対象となるデータ全体のことを母集団，取り出した一部のデータのことを標本といいます． 例えば，日本国民全体の平均身長を調べるためには，莫大な費用と時間がかかってしまいます． そこで，多少の正確さは犠牲にして，一部の国民を対象として調査し，全体を予測するということが現実的な方法です． ここでは，母集団が正規分布であると仮定して，母集団と標本の関係を明らかにしていきます． これからは，ある母集団（または標本）Xが， 平均\mu，分散\sigma^2に従うとき， 下記のように表記しますので注意してください． ここで，Nは，Normal Distribution（正規分布）の頭文字です．
X \sim N(\mu,\sigma^2)  スクリプトの作成 -- スクリプトの作成  コードを入力し保存するためのスクリプトを作成しましょう． [ファイル]-[新しいスクリプト]をクリックし，Rエディタを表示します． 次に，[ファイル]-[保存]をクリックして，スクリプトを保存します． このとき，ファイル名はchapter8としてください． また，ファイルの保存場所と作業ディレクトリをデスクトップに変更しておきます．
母数の推定 -- 母数の推定  母集団の特徴を表す基本統計量は母数と呼ばれます． 平均，分散などがその代表であり，母集団の平均を母平均\hat{\mu}， 母集団の分散を母分散 \hat{\sigma}^2と呼びます． また，母集団から抽出された標本の平均を標本平均 \mu， 標本の分散（不偏分散）を標本分散 \sigma^2と呼びます． テキストによっては，これらの定義が異なることもあるので注意してください．
それでは，母集団から抽出した標本を用いて，母数の値を推定してみましょう． このとき，推定する母数が「1つの値」となっている場合は，点推定 と呼びます． ここでは，平均\hat{\mu}=100， 分散\hat{\sigma}^2=100に従う母集団を考えます （標準偏差は\hat{\sigma}=10）．
X \sim N(100,100)  上記の正規分布に従った下記の10000の乱数を生成し，母集団Xとします． ファイル をダウンロードしたら，read.csv関数を利用して， 変数Xにデータフレームとして読み込んでおきましょう（作業ディレクトリはデスクトップに変更）．
89.74776 96.49404 98.46421 98.99935 93.35153 105.0311 123.9603 98.72574 105.1024 83.61765 ... ファイルを読み込んだら，母集団Xの平均と分散を求めてみましょう．
X &amp;lt;- read.</description>
    </item>
    
    <item>
      <title>独立な2群のt検定</title>
      <link>https://mukai-lab.info/pages/classes/advanced_studies_seminar_2/chapter11/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://mukai-lab.info/pages/classes/advanced_studies_seminar_2/chapter11/</guid>
      <description>平均値差の検定とは -- 平均値差の検定とは  これまでは，母集団Xと標本xの関係に注目して検定を行いました． これからは，２つの標本（標本x_1，標本x_2）の関係に注目し， それぞれの平均値の有意な差があるかどうかを検定します． ２つの標本を検定する場合，下記の条件によって適用する手法が異なります．
 独立な2群（対応のない2群） 対応のある2群  独立な2群（対応のない2群） とは，ある母集団から２つの標本を抽出したとき， それぞれの標本に含まれる対象が互いに無関係であることを意味しています． 例えば，下記のように，母集団Xから8人の被験者を抽出して， これをランダムに4人の2群に分けた場合は，「独立な2群」です．
x_1 = \{a,b,c,d\} \\ x_2 = \{e,f,g,h\}  一方，対応のある2群 とは，2つの標本に含まれる対象に，何らかの対応関係があることを意味しています． 例えば，下記のように，同じ4人の被験者に対して，2種類の条件下で測定された2群のデータは，「対応のある2群」です．
条件1: x_1 = \{a,b,c,d\} \\ 条件2: x_2 = \{a&#39;,b&#39;,c&#39;,d&#39;\}  今回は，前者の 独立な2群（対応のない2群） のt検定を解説します．
スクリプトの作成 -- スクリプトの作成  コードを入力し保存するためのスクリプトを作成しましょう． [ファイル]-[新しいスクリプト]をクリックし，Rエディタを表示します． 次に，[ファイル]-[保存]をクリックして，スクリプトを保存します． このとき，ファイル名はchapter11としてください． また，ファイルの保存場所と作業ディレクトリをデスクトップに変更しておきます．
t検定の前提条件 -- t検定の前提条件  独立な2群の平均値差の検定にもt検定を利用します． ただし，t検定を適用するには，下記の条件を満たす必要があります．
 ランダムサンプリングにより標本が抽出されている 母集団の分布が正規分布である 母集団の分散が等質である  上記の条件1，2はこれまでの前提と同じですが，条件3が新しく追加されました． もし，条件3を満たさない場合は，t検定の代わりに，Welchの検定 を利用する必要があります． Welchの検定に関しては割愛します． ここでは，上記の全ての条件を満たしていると仮定して話を進めます．
独立な2群のt検定 -- 独立な2群のt検定  それでは，下記の問題について考えていきましょう．</description>
    </item>
    
    <item>
      <title>画像処理</title>
      <link>https://mukai-lab.info/pages/classes/programming_1/chapter7/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://mukai-lab.info/pages/classes/programming_1/chapter7/</guid>
      <description>スケッチの作成  Processingを起動して，新規にスケッチを保存しましょう． メニューから[ファイル]-[名前を付けて保存]をクリックして，「スケッチフォルダを名前を付けて保存」を開きます． ファイル名に「Project7」を入力し，[保存]をクリックしましょう． 保存先に「Project7」という名前のフォルダが作成されていることを確認してください．

画像の準備  Processingは JPG形式 や PNG形式 などの画像ファイルを取り込んで表示することができます． 下記の三種類の画像（hana.jpg，night.jpg，umi.jpg）の内から一つを選び，画像をダウンロードしてください（画像提供：フリー写真素材 Futta.NET）． いずれの画像もサイズは640×480ピクセルです． また，ダウンロードした画像は「スケッチフォルダ（Project7）」の中に配置しましょう． これ以降，本資料ではhana.jpgを例に取り説明していきます．
画像の表示  画像ファイルを読み込むには， PImage という型（本当はクラス）で変数を宣言し， loadIMage()関数を利用して，変数に画像データを代入します．
PImage img; img = loadImage(ファイル名); また，ウィンドウに画像を表示するにはimage()関数を用います． image()関数の引数には， PImage 型の変数に加え，表示する位置 (x,y) を指定します． 初期設定では，画像の表示位置は，画像の左上隅の座標が基準となることに注意してください．
image(img, x, y); 下記を参考にコードを入力したら，Runボタンをクリックしてくだい． ウィンドウに指定した画像が表示されることを確認してください（ウィンドウのサイズは画像サイズと同じ640×480ピクセルとします）．
 
画像をクリッピング（画像の一部を切り取ること）するには，copy()関数を利用します． 例えば，画像の左上の1/4の領域を切り取り，幅・高さを2倍にするには下記のように記述します． (0,0)は元画像の左上隅の座標，(320,240)は切り取る領域の幅と高さを意味しており，これらの値で指定された領域が切り取られます． また，2度目の(0,0)は切り取った画像を表示する位置，(640, 480)は切り取った画像の幅と高さ（この場合は拡大）を意味しています．

copy(img, 0, 0, 320, 240, 0, 0, 640, 480); 下記を参考にコードを入力したら，Runボタンをクリックしてくだい． ウィンドウに切り取られた画像が拡大して表示されることを確認してください．
 
クリッピング機能を利用して 虫眼鏡 を実現してみましょう． マウスをドラッグすると，マウス位置にある画像部分だけがズームして表示されます． mouseDragged()関数では，image()関数で画像を表示した後に， copy()関数を利用して100×100ピクセルの領域を切り取り， 200×200ピクセル（2倍）に拡大して表示しています． また，mouseReleased()関数では，image()関数を実行し，元の画像を表示しています． 下記を参考にコードを入力したら，Runボタンをクリックしてくだい． ドラッグすると画像が拡大して表示されることを確認してください．</description>
    </item>
    
    <item>
      <title>相関係数</title>
      <link>https://mukai-lab.info/pages/classes/advanced_studies_seminar_2/chapter5/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://mukai-lab.info/pages/classes/advanced_studies_seminar_2/chapter5/</guid>
      <description>相関分析 -- 相関分析  相関分析とは，2種類のデータの関係性を測るための方法を指します． 例えば，夏の熱い日には，アイスクリームがよく売れるとします． このとき，温度と，アイスクリームの売上には相関があると言えます． 今回は，このようなデータの相関を調べるに共分散と相関係数を学びましょう． 対象のデータは，前回と同じ成績のデータ（CSV形式）を使用します． このデータは15人の生徒の国語，算数，理科，英語，社会の得点で構成されています．
 ファイルをダウンロードしたら，read.csv関数を利用して， 変数scoreにデータフレームとして読み込んでおきましょう（作業ディレクトリはデスクトップに変更）．
score &amp;lt;- read.csv(&amp;#34;score.csv&amp;#34;) 変数scoreの出力は下記のようになります．
&amp;gt; score 氏名 国語 算数 理科 英語 社会 1 青木 達也 60 68 72 39 71 2 石井 健二 65 78 82 37 75 3 北村 真子 84 59 85 87 84 4 河野 尚子 50 65 65 39 78 5 高木 健 72 74 83 30 83 6 西川 知里 50 29 67 62 72 7 福島 萌子 84 40 65 86 66 8 古川 翔太 78 71 82 34 88 9 山内 香菜 77 33 65 73 88 10 渡辺 太郎 76 53 75 60 71 11 浅野 渉 68 46 77 66 86 12 星野 弘 61 27 74 70 67 13 中谷 章 86 57 72 73 65 14 小泉 美沙 68 48 73 51 68 15 木下 萌子 78 90 100 53 79 スクリプトの作成 -- スクリプトの作成  コードを入力し保存するためのスクリプトを作成しましょう． [ファイル]-[新しいスクリプト]をクリックし，Rエディタを表示します． 次に，[ファイル]-[保存]をクリックして，スクリプトを保存します． このとき，ファイル名はchapter5としてください． また，ファイルの保存場所と作業ディレクトリをデスクトップに変更しておきます．</description>
    </item>
    
    <item>
      <title>経営データ解析Ⅱ</title>
      <link>https://mukai-lab.info/pages/classes/management_data_analysis/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://mukai-lab.info/pages/classes/management_data_analysis/</guid>
      <description>科目名: 経営データ解析Ⅱ 講義室: 名古屋校舎教室
開講学期: 秋学期
科目種別: 講義
テーマ: 統計解析ツールを利用したデータ分析力の養成
概要 日常生活において重要な意思決定に迫られたとき，客観的に問題を捉え最適な行動を選択するには，統計に基づくデータ分析が有用である．本授業では，与えられた問題に対し論理的な解決を導出するための統計的アプローチを身に付ける． 統計解析のためのツールとして，プログラミング言語のPythonを活用し，開発環境にはJupyter Labを用いる．
内容／スケジュール  Pythonの基本 Pythonを利用した統計処理①・相関係数 Pythonを利用した統計処理②・2項分布 Pythonを利用した統計処理③・正規分布 統計的仮説検定①・t検定 統計的仮説検定②・t検定（平均値差の検定） 統計的仮説検定③・ANOVA 線形計画法①・最適生産計画 線形計画法②・最短経路問題 最小二乗法①・関数近似 最小二乗法②・成長曲線 多変量解析①・主成分分析 多変量解析②・クラスタ分析 統計的推定①・最尤推定法 統計的推定②・ベイズの定理  参考書籍</description>
    </item>
    
    <item>
      <title>脳波データをフーリエ解析</title>
      <link>https://mukai-lab.info/pages/tech/emotiv/emotiv3/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://mukai-lab.info/pages/tech/emotiv/emotiv3/</guid>
      <description>フーリエ変換とは  前回までにCortexを利用してEmotiv Epoc+で計測したデータをPythonから取得する方法を説明しました． 一般に，脳波の生データから情報を読み取ることは困難であり，周波数成分に変換することが必要になります． この周波数成分の変換に必要な技術が鬼門のフーリエ変換（Fourier Transform: FT） です． 大学の工学部ではカリキュラムの１つとなっているフーリエ変換（フーリエ級数）に躓いた人も多いのではないでしょうか（何を隠そう向もその一人です）． ここでは，あまり深く考えず，フーリエ変換は 時間領域 から 周波数領域 に変換する仕組みだと理解しておけば十分です．
例を挙げて考えてみましょう． Emotivのサンプリングレートは 128Hz であることから，1秒間に 128個の信号が計測されることに注意してください． 仮に計測された脳波が，下記のグラフのような信号だったとします． この信号には，1秒間に 3周期分 のSin関数が含まれています． グラフの横軸が 時間 であることから，このデータは 時間領域 に存在しています．

これを，フーリエ変換（高速フーリエ変換）すると下記のグラフになります． このグラフの横軸は 周波数 であり，このデータは 周波数領域 に存在しています． 周波数 が 3 のところに，縦棒がありますよね． この結果は，先のグラフには 周期3 の信号が含まれていることを表しています．

フーリエ変換の凄いところは，異なる周期の信号が混ざっていても，それぞれの周波数成分の強さが取得できることです． 次に，下記のグラフの信号を考えます この信号には，1秒間に 5周期分 のSin関数が含まれています． また，その振幅は先の信号と比べて 1/2 の大きさです．

この信号を，先の周期3の信号に加えます（本当に足し算するだけ）． すると，下図のようなグラフになります． これだけで，複雑なグラフになり，人間には理解できないレベルに到達します．

さぁ，フーリエ変換の出番です． 上の周期3と周期5のグラフを加えた信号を変換すると，下記のグラフになります． 周期3 の振幅は 1，また，周期5 の振幅が 0.5 となっていることが読み取れますね． フーリエ級数を発明したジョゼフ・フーリエは本当に天才だと思います（真面目）．

脳波データの記録  それでは，前回までに実装したプログラムを利用して脳波データを取得しましょう． 準備として，数値計算ライブラリのNumpyと，描画ライブラリのmatplotlib.</description>
    </item>
    
    <item>
      <title>運転支援</title>
      <link>https://mukai-lab.info/pages/projects/driving/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://mukai-lab.info/pages/projects/driving/</guid>
      <description>愛知工業大学・愛知大学と共同で交通事故データの分析に関する研究を実施しています． 交通事故データは愛知県警から提供されたものであり，日時や車種など事故の発生状況がまとめられています． これを統計的に分析し，事故の発生原因となる要素を特定することで，事故数の減少を目指します． 本研究は名古屋大学が中心となった「エージェントを介した運転支援研究プロジェクト」とも連携しています．
 交通事故データ（愛知県警）の分析 ロボット（RoBoHoN）を利用した運転支援 交通シミュレータ（UC-Win/Road，CARLAなど）を利用したシステム開発  ロボホンによる運転支援   ロボホンによる事故推定   </description>
    </item>
    
    <item>
      <title>配列と繰り返し</title>
      <link>https://mukai-lab.info/pages/classes/applied_programming/chapter4/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://mukai-lab.info/pages/classes/applied_programming/chapter4/</guid>
      <description>プロジェクトの準備 -- プロジェクトの準備  Eclipseで新規にプロジェクトを作成しましょう． メニューから[ファイル]-[新規]-[Javaプロジェクト]をクリックして，「新規Javaプロジェクトの作成」を開きます． ここでは，プロジェクト名に”Project4”を入力して，[完了]をクリックしましょう． パッケージ・エクスプローラに作成したプロジェクトが表示されていることを確認してください．

続いてソースファイルを作成しましょう． メニューから[ファイル]-[新規]-[クラス]をクリックして，「新規Javaクラス」を開きます． ここでは，名前に”MyClass”を入力し，public static void main(String[] args)(V)にチェックを入れ，[完了]をクリックしましょう． パッケージ・エクスプローラに作成したソースファイルが表示されていることを確認してください．

配列とは -- 配列とは  変数は数値や文字列などのデータを1つだけしか記憶できません． しかし，複数のデータを一つのグループとして扱いたい場合があります． 例えば，5人の学生が受けた試験の得点を記憶することを考えてみましょう． 変数を利用して記録する場合は，5つの変数を用意しなければならず面倒です． このようなときに便利なのが配列です． 配列は同じデータ型の複数の値を1つの配列名で記憶することができます． 配列を宣言するにはデータ型[] 配列名 = new データ型[要素数];と記述します． 配列に記憶されるデータは要素と呼ばれ，各要素には添え字という番号で参照します．
下記のコードを参考に，配列scoreを宣言して，5人の得点を記録してみましょう． 配列の添え字は0番から始まることに注意してください． プログラムの実行後に，コンソールの出力結果を確認してください．
 配列の要素を初期化するには，上記のように各要素に値を代入する方法の他に， 「{}」を利用してデータ型[] 配列名 = {78, 84, 94, 64, 82};と記述する方法もあります．
下記のコードを参考に，配列scoreの初期化を行いましょう． プログラムの実行後に，コンソールの出力結果を確認してください．
 また，配列の要素数を取得するには配列名.lengthと記述します． 下記のコードを参考に，配列scoreの要素数をコンソールに出力してください． プログラムの実行後に，コンソールの出力結果を確認してください．
 for文 -- for文  制御構文の1つであり，条件を満たすまで同じ命令文を繰り返す制御が繰り返しです． 今回はこの繰り返しについて学習します． 指定した回数だけ命令を繰り返すにはfor文を利用します． for文は下記のように記述します． 「()」内には，変数の初期化，繰り返し条件，変数の更新を記述します． 例えば，int型の変数iを宣言し，iの値を1ずつ増やしながら，10回同じ命令を繰り返すには， for(int i=0; i&amp;lt;10; i++)と記述します． ここでi++は値を1だけ増やすという演算子であり，i=i+1と同じ処理です．</description>
    </item>
    
    <item>
      <title>障害者支援</title>
      <link>https://mukai-lab.info/pages/projects/challenged/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://mukai-lab.info/pages/projects/challenged/</guid>
      <description>株式会社仙拓の佐藤仙務氏との共同プロジェクトです． 佐藤仙務氏は，脊髄性筋萎縮症（SMA）を患う障碍者の１人であり，「寝たきり社長」という愛称で有名な企業家です． 本学では，向が顧問を務める障碍者支援サークルYELLTECHのアドバイザーを務めておられ， 共同で障碍者の自立を支援するためのソフトウェアの開発を行っています． これまでに，港特別支援学校や一宮特別支援学校を訪問し，視線入力装置などのデモを実施しています．
 視線（Tobii Eye Tracker，JINS MEME）や脳波（Emotiv）を利用した開発 スマートスピーカー（Alexa）を利用した開発  HIDE AND ZOO 〜視線入力で動物クイズ〜   定常状態視覚誘発電位を利用したコミュニケーション支援   筋電位を利用したコミュニケーション支援   </description>
    </item>
    
  </channel>
</rss>