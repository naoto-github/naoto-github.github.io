<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Pages on MLAB</title>
    <link>https://mukai-lab.info/pages/</link>
    <description>Recent content in Pages on MLAB</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>ja</language>
    <lastBuildDate>Sat, 08 Jun 2019 11:47:14 +0900</lastBuildDate>
    
	<atom:link href="https://mukai-lab.info/pages/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Tableauで色々なグラフを作成しよう</title>
      <link>https://mukai-lab.info/pages/tech/tableau/tableau2/</link>
      <pubDate>Sat, 08 Jun 2019 11:47:14 +0900</pubDate>
      
      <guid>https://mukai-lab.info/pages/tech/tableau/tableau2/</guid>
      <description>グラフの種類前回は棒グラフを作成しましたが，Tableauでは様々な種類のグラフが利用できます． それぞれ適した用途があり，ケース・バイ・ケースで使い分けることが重要です．
 棒グラフ（量的データを並べて比較） 折れ線グラフ（時系列データの比較） 円グラフ（割合に関するデータの比較） 積み上げ棒グラフ（量的データの内訳も比較） 散布図（説明変数と非説明変数の関係） バブルチャート（3つの指標で比較） レーダーチャート（対象の特性を比較）  ここでは，使用頻度が高い 積み上げ棒グラフ，円グラフ，散布図，折れ線グラフ に注目し， オープンデータを利用してグラフを作成してみましょう．
積み上げ棒グラフまずは積み上げ棒グラフを作成しましょう． データソースは前回と同じ　町別人口・世帯数　を用いて， 男と女の人口を積み上げ棒グラフで表示します．
ここでは，メジャーネーム と メジャーバリュー を利用します． これらは，複数のディメンションやメジャーを，一つにまとめて扱うときに利用します． まずは，町名 を列， メジャーバリュー を行に設定します． このときの，棒グラフの高さは，$高さ=世帯数+男+女+総数+レコード数$を表しています．

次に，メジャーバリュー にフィルタを設定します． フィルタとは特定のメジャーのみを選択する機能のことです． ここでは，男 と 女 にチェックを入れます． これで，棒グラフの高さは，$高さ=男$と$高さ=女$となり，重なって表示されます．


最後に，メジャーネーム を色に設定することで，積み上げ縦棒グラフの完成です． ワークシート名や並び替えなどグラフの表現を整えていきましょう．
 ワークシート名を 男女人口 に変更 データを 降順 で並べ替え メジャーネームをデータラベルに設定  
円グラフ次は円グラフを作成しましょう． データソースは，今回も 町別人口・世帯数 です． 地域毎の世帯数を棒グラフで表示します．
最初にワークシートを追加しておきます． 一つのワークシートに，一つのグラフを作成するのが基本であり， 複数のワークシートをまとめるには，ダッシュボード を利用します（次回に説明します）．</description>
    </item>
    
    <item>
      <title>Tableauでオープンデータを可視化</title>
      <link>https://mukai-lab.info/pages/tech/tableau/tableau/</link>
      <pubDate>Fri, 07 Jun 2019 17:16:17 +0900</pubDate>
      
      <guid>https://mukai-lab.info/pages/tech/tableau/tableau/</guid>
      <description>データサイエンティストデータサイエンティスト という職業をご存知でしょうか． データサイエンティストとは，企業や組織での意思決定が必要な場面において，データに基づき合理的な判断を下す人を指します． データサイエンティストには，数学，統計学，情報科学，プログラミング など高度な知識が必要であり， 一部の専門家のみがその役割を担ってきました． 一方で，大量のデータを分析するためのソフトウェア，いわゆる「 BI(Business Intelligence)ツール 」が成熟・普及することで， 専門家ではなくともデータの可視化，データの集計・分析が容易となりました． BIツールには，Tableau， Qlik Sense， Actionista，などがありますが， ここでは，IT調査企業であるGartnerが， Learders（成熟したサービスを提供する製品・企業） に選出した Tableau を採用し， データの可視化にチャレンジしてみましょう．
TableauTableau（日本語ではタブローと表記）とはどんなBIツールでしょうか． このBIツールは，アメリカに本社を置く Tableau Software が開発しており， 世界で42,000社以上，また，日本で2,000社以上の企業が利用していると言われています（2016年8月現在）． 本学にも導入される予定であり，教員・学生・事務職員によるIR（Institute Research）において活用される見込みです． PC向けのソフトウェアは Tableau Desktop という名称であり，一般には年間の利用料金が必要ですが， アカデミックプログラムが別途用意されており， 教員と学生は，なんと 無料 で利用可能です（14日間の無料トライアルもある）． 組織内のデータ分析はもちろん，将来のデータサイエンティストを育てるための学習ツールとしても最適と言えるでしょう．
ここで，他のBIツールと比較したTableauの特徴をまとめます．
 プログラミングが不要（ドラッグ&amp;amp;ドロップで操作） 様々なファイル形式（xlsx，csv，etc.），サーバー（MySQL, Googleスプレッドシート, etc.）に対応 可視化のパターンが豊富（ツリーマップ，パレート図，etc.）  一般に，高度なデータ分析には R， Python と呼ばれるプログラミング言語が用いられますが， Tableauではプログラミングの知識は一切不要です． また，組織で蓄積されているであろう Excel や CSV などのファイルはもちろん， データベース・サーバーにも接続可能です． さらに，分析結果を伝えるためには不可欠な データの可視化 にもTableauは優れています． 上記の特徴から，手元にあるデータを利用して，初学者が気軽に学び始めることが出来ます．
オープンデータ早速，Tableauでデータ分析を始めたいところですが， まずは対象とするデータを用意しなくてはいけません． ここでは，自治体が公開しているオープンデータを利用してみましょう． オープンデータとは下記条件に従って公開されているデータを指しています．</description>
    </item>
    
    <item>
      <title>回帰③・基底関数</title>
      <link>https://mukai-lab.info/pages/classes/intelligence_information_system/chapter5/</link>
      <pubDate>Tue, 04 Jun 2019 10:16:04 +0900</pubDate>
      
      <guid>https://mukai-lab.info/pages/classes/intelligence_information_system/chapter5/</guid>
      <description>基底関数これまでは回帰式として線形関数（一次式）を採用してきました．
$$f(x) = w_0 + w_1 x $$
しかし，下記のようなデータを対象とする場合は，直線ではなく曲線を用いた方が，傾向を正しく表現できそうです． このデータは，愛知県衛生研究所が公開しているインフルエンザの発症数です． 変数$x$は 経過週 ，変数$y$は インフルエンザの報告数（定点当たり） を表しています．
x = np.array([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20]) #週 y = np.array([0.26,0.25,0.19,0.34,0.89,1.78,2.51,4.81,10.97,18.02,19.28,32.42,62.12,62.18,62.60,49.18,32.57,25.93,21.17,14.68]) #報告数 
このような場合は，基底関数 を利用します． 線形関数の$x$を，任意の$\phi(x)$という基底関数に置き換えるという方法です． 基底関数には，どんな関数を用いても良いのですが，よく用いられるのは， 多項式基底 や ガウス基底 と呼ばれる関数です． 今回は，これら 基底関数 を利用した回帰について学びます．
ノートブックの作成Jupyter Notebook を起動し，新規にノートブックを作成してください． ノートブックのタイトルは Notebook5 とします． ノートブックの作成方法は第１回の資料を参照してください． また，numpy と matplotlib.</description>
    </item>
    
    <item>
      <title>回帰②・最急降下法</title>
      <link>https://mukai-lab.info/pages/classes/intelligence_information_system/chapter4/</link>
      <pubDate>Sun, 02 Jun 2019 17:07:40 +0900</pubDate>
      
      <guid>https://mukai-lab.info/pages/classes/intelligence_information_system/chapter4/</guid>
      <description>解析解と数値解前回は2変数の関係性を表す 回帰式 と， その回帰式の当てはまり具合を評価するための 最小二乗法 について学びました． 回帰式の形を決める傾き $a$ と切片 $b$ の最適値は， numpy の polyfit 関数を利用して求めましたが，どのように最適値を求めているのでしょうか． 今回はその秘密に迫ってみたいと思います．
回帰式のパラメータ（$a$と$b$のこと）を求める方法には２通りあり， 方程式を解くことによって得られる厳密な解を 解析解， 繰り返しの計算によって得られる近似的な解を 数値解 と呼びます． 特定の処理を繰り返すことが得意なコンピュータでは， 後者の 数値解 を求める方法が良く用いられます． ここでは，数値解を求めるための最もシンプルな方法である 最急降下法（Steepest Descent Method） について学びます．
ノートブックの作成Jupyter Notebook を起動し，新規にノートブックを作成してください． ノートブックのタイトルは Notebook4 とします． ノートブックの作成方法は第１回の資料を参照してください． また，numpy と matplotlib.pyplot を導入しておいてください．
import numpy as np import matplotlib.pyplot as plt 最急降下法最急降下法は，目的関数（2乗誤差）の傾き（勾配）を求め， 誤差が小さくなる方向へパラメータを更新するという手法です． 理解するためには 微分 が必要となりますが， 決して難しい計算ではないため，焦らず落ち着いて考えていきましょう．
データ 対象とするデータは前回と同じ，気温 と アイスクリーム のデータを用います． いずれも，numpyのndarray型でリストを作成しておきます．</description>
    </item>
    
    <item>
      <title>回帰①・線形回帰</title>
      <link>https://mukai-lab.info/pages/classes/intelligence_information_system/chapter3/</link>
      <pubDate>Fri, 31 May 2019 09:37:19 +0900</pubDate>
      
      <guid>https://mukai-lab.info/pages/classes/intelligence_information_system/chapter3/</guid>
      <description>機械学習の分類機械学習は大別して３種類あるとされています．
 教師あり学習（Supervised Learning） 教師なし学習（Unsupervised Learning） 強化学習（Reinforcement Learning）  教師あり学習 は，未知のデータに対する分類や予測などの問題において， 過去のデータに対して正解（教師）が事前に与えられている学習方法です． 過去のデータの正解が分かっているため，未知のデータに対しては， 過去のデータとの類似性を基に判断することになります． 例えば，特定の顔写真をデータとして学習させると， 未知の写真に対して，一致するかどうかを判定できるようになります．
教師なし学習 は，正解（教師）が事前に与えられない学習方法です（もしくは明確な正解が存在しない）． よって，分類や予想ではなく，データに潜む傾向や特徴を抽出する目的で用いられます． データマイニングと呼ばれる研究分野にも関係が深いです． 例えば，POS（Point of Sales）データなどから， 商品売上の傾向（「おむつとビール」が有名）を明らかにすることが出来ます．
強化学習 は，ロボット（エージェント）が，環境や経験からの情報を基に， 最適な行動ルールを獲得するための学習方法です． 一般には，マルコフ決定過程（Marcov Decision Process）というプロセスに従って学習は進行します． 例えば，自動運転自動車が，他の車両や歩行者を回避するための運転操作を， 自動的に獲得することができます．
ノートブックの作成Jupyter Notebook を起動し，新規にノートブックを作成してください． ノートブックのタイトルは Notebook3 とします． ノートブックの作成方法は第１回の資料を参照してください．

回帰今回は，教師あり学習に分類される回帰 に焦点を当てます． 回帰分析 とは，2変数（もしくはそれ以上）の関係性を 数式 で表すという手法です． 例えば，過去の「気温」と「アイスクリームの売上」のデータを基に， それらの関係性を表す数式を導き，将来の売上を予測することができます．
ここでは，下記に示す10日間分のデータで考えましょう． 変数xは気温，変数yはアイスクリームの売上を表しています．
x = [12, 20, 13, 24, 28, 30, 31, 24, 18, 33] # 気温 y = [21, 35, 22, 29, 37, 46, 50, 27, 25, 49] # アイスクリームの売上 このデータを散布図にしてみます． Pythonでグラフを作成するには，Matplotlib といライブラリを用います． ライブラリを導入するには import matplotlib as pltとします． ここで，as plt は，ライブラリのエイリアス（別名）として， plt を用いることを意味しています（省略も可能です）． 横軸を気温，縦軸を売上として，散布図を描くには，plt.</description>
    </item>
    
    <item>
      <title>Pythonの基本</title>
      <link>https://mukai-lab.info/pages/classes/intelligence_information_system/chapter2/</link>
      <pubDate>Wed, 29 May 2019 12:51:03 +0900</pubDate>
      
      <guid>https://mukai-lab.info/pages/classes/intelligence_information_system/chapter2/</guid>
      <description>PythonとはPython はオランダ出身のプログラマーGuido Van Rossum氏が1991年に開発したプログラミング言語です． C言語やJavaに比べ，文法がシンプルであり，高い可読性を持っています． 例えば，多くのプログラミング言語では，コードの固まり（ブロック）を {}（中括弧） で表現することが多くあります． 一方，Pythonでは，字下げ（インデント） を利用して，ブロックを表現します． また，本授業でテーマとなっている機械学習など，豊富なライブラリが利用可能であり， パッケージ管理ツール（Anacondaなど）を利用して，手軽に導入可能という特徴もあります． コーディング，実行，デバッグ という一連のプロセスも簡単であり， 手を動かしながら学ぶには最適なプログラミング言語と言えるでしょう． 今回は，強化学習を学ぶ前準備として，Python の基本的な文法について学びます．
ノートブックの作成Jupyter Notebook を起動し，新規にノートブックを作成してください． ノートブックのタイトルは Notebook2 とします． ノートブックの作成方法は第１回の資料を参照してください．

四則演算一般的な四則演算が利用可能です． セルに加算（+），減算（-），乗算（*），除算（/），剰余（%），累乗（**）を入力して，結果を確認してみましょう． 乗算・除算などは，我々が通常用いている$\times$や$\div$などの演算子とは異なることに注意してください．
   演算 演算子 例     加算 + 3 + 2 -&amp;gt; 5   減算 - 3 - 2 -&amp;gt; 1   乗算 * 3 * 2 -&amp;gt; 6   除算 / 3 / 2 -&amp;gt; 1.</description>
    </item>
    
    <item>
      <title>機械学習とは</title>
      <link>https://mukai-lab.info/pages/classes/intelligence_information_system/chapter1/</link>
      <pubDate>Sat, 18 May 2019 14:57:09 +0900</pubDate>
      
      <guid>https://mukai-lab.info/pages/classes/intelligence_information_system/chapter1/</guid>
      <description>機械学習とはこの授業では， 機械学習 の理論と実践を学びます． 機械学習は「データから規則性やルールを抽出する」ための手法の総称です． 近年，注目される人工知能の基礎技術として知られる ディープラーニング も機械学習の一つです． その応用範囲は幅広く，顔検出，手書き文字の認識，商品の推薦，株価の予測などに用いられています．
例えば，Facebookでは，機械学習を用いて自動的に顔を検出し，個人を識別する仕組みが導入されていることが，よく知られています． 下記のように画像をアップロードするだけで，過去の画像データから，個人を認識しラベリングがなされます．

この他にも，画像を特徴付ける単語をリストアップするClarifai， 存在しない人の顔写真を生成するThis Person does Not Exist， 音楽を自動生成するAmper Musicなど，数多くのサービスが生み出されています．
機械学習の多くは，確率分布など統計的な手法が用いられており， 数学の知識がないと理解できないことも多く，初学者にはハードルが高い分野です． 一方で，Python や R などのプログラミング言語では， 機械学習のためのライブラリが充実しており，機械学習を実装するための環境は整っています． そこで，本授業では，Python の実装が容易なJupyter Notebookを活用し， 理論だけを学ぶのではなく，アルゴリズムの実装までを経験することで，機械学習を実践的に活用できるようになることを目標とします．
AnacondaのインストールPythonの実装に用いるJupyter Notebookは， PythonのディストリビューションであるAnacondaにバンドルされています． そこで，Anacondaのインストーラをダウンロードし，PCにインストールしましょう． インストーラは Python 3.x Version の 64-Bit Graphical Installer を選択し，ダウンロードしてください．
インストールを始める前に，ファイルをインストールするためのフォルダを作成します． Hドライブ に， MyAnaconda という名前でフォルダを作成してください（本学のPC環境では個人のファイルはHドライブに保存する）．
それでは，インストーラを実行しましょう． 環境によっては，インストールにかなりの時間を要しますので注意してください（本学の環境だと１時間弱かかるかも）． インストールするフォルダは，上記で作成した H:\Anaconda とします（3.1GBとかなり大きな容量です）．

次に，オプションを設定するダイアログ（Adcanved Installation Options）では， ２箇所のチェックボックスがありますが，いずれもチェックを外してください． ちなみに，上は「インストールしたAnacondaのパスの環境変数への追加」， 下は「同時にインストールされるPythonの他のアプリでの利用」の設定です．

インストールが終了すると，下記のダイアログが表示されます． ２箇所のチェックボックスのチェックを外し， Finish で終了してください．</description>
    </item>
    
    <item>
      <title>知能情報システム</title>
      <link>https://mukai-lab.info/pages/classes/intelligence_information_system/</link>
      <pubDate>Sat, 18 May 2019 12:38:55 +0900</pubDate>
      
      <guid>https://mukai-lab.info/pages/classes/intelligence_information_system/</guid>
      <description> 授業科目区分： 専門教育科目
単位数: 2単位
開講学科: 文化情報学科
学年: 3年次
関連科目: 人工知能
授業テーマ: 機械学習の理解と実装
授業内容 人工知能の基礎となる機械学習を学び，実践的な問題に適用するための応用力を身に付ける． 機械学習はデータから法則や傾向を抽出するための手法であり，ディープラーニングと呼ばれる画像認識技術も機械学習の一つである. 機械学習の実装には，多様なライブラリが利用可能なPython（Jupyter Notebook）を採用する．
授業計画  機械学習とは Pythonの基本 回帰①・線形回帰 回帰②・最急降下法 回帰③・基底関数 分類とは 分類①・線形判別分析(LDA) 分類②・k近傍法 分類③・決定木 クラスタリングとは クラスタリング①・k-means法 クラスタリング②・混合ガウス分布 ディープラーニングとは ディープラーニングの応用①・手書き数字の認識 ディープラーニングの応用②・写真の物体認識  課題提出方法 Google Classroomから提出すること． 提出の際は大学から提供されたユーザIDでログインが必要なことに注意すること．
参考書籍     </description>
    </item>
    
    <item>
      <title>MacでEmacs</title>
      <link>https://mukai-lab.info/pages/tech/emacs/emacs/</link>
      <pubDate>Wed, 15 May 2019 19:50:00 +0900</pubDate>
      
      <guid>https://mukai-lab.info/pages/tech/emacs/emacs/</guid>
      <description>Atomへの乗り換えを検討しましたが，やっぱりEmacsが便利なことも多いです．そこで，MacでEmacsを利用する上で，必要最低限な設定をメモしておきます．
インストール Macにインストール可能なEmacsは複数あるが，railwaycat氏のemacs-macがしっくりくる． インストール方法は，この計算物理屋の研究備忘録を参考にした（Mojabe10.14.4の環境では，なぜかcask版は実行できなかった）．
% brew tap railwaycat/emacsmacport % brew install emacs-mac パッケージのインストール Emacsのパッケージをインストールするには，Melpaのレポジトリを登録しておく．.emacs.elに下記のように記述する（もうLispなんて忘れたわい）．
(add-to-list &amp;#39;package-archives &amp;#39;(&amp;#34;melpa-stable&amp;#34; . &amp;#34;https://stable.melpa.org/packages/&amp;#34;) t) その後で，M-x list-packagesをして，パッケージを選択すればOK．
Neo Tree Atomのようにファイルやフォルダをツリーで表示する． C-tでツリーの表示・非表示を切り替える．
(global-set-key &amp;#34;\C-t&amp;#34; &amp;#39;neotree-toggle) Markdown Mode マークダウン・ファイルのハイライトに用いる．
テーマの設定 テーマをtango-darkに設定．
(load-theme &amp;#39;tango-dark t) キーバインディングの設定 Ctr-uでUndo．
(global-set-key &amp;#34;\C-u&amp;#34; &amp;#39;undo) Meta-/でComment．
(global-set-key &amp;#34;\M-/&amp;#34; &amp;#39;comment-line) キーバインディングの競合の解消 デフォルトのキーバインディングでは， set-mark-command にC-SPC が割り当てられていますが，マック標準のキーバインディングと競合しており動作しません． この場合，【システム環境設定】→【キーボード】→【ショートカット】→【入力ソース】で，チェックを外すと解消されます．</description>
    </item>
    
    <item>
      <title>Atomに必須のプラグイン紹介</title>
      <link>https://mukai-lab.info/pages/tech/atom/atom_plugin/</link>
      <pubDate>Sat, 11 May 2019 13:42:38 +0900</pubDate>
      
      <guid>https://mukai-lab.info/pages/tech/atom/atom_plugin/</guid>
      <description>GitHubが開発するオープンソスのエディタがAtomです． 様々なプラットフォームがサポートされており，WindowsやMacなどの異なる環境でも，同じ操作感覚で利用が可能です． これまで，Windows環境下では Atom，Mac環境下では emacs を採用していたのですが， キーボード・ショートカットなどの違いにウンザリして， Atom に統一することにしました． そこで，今回は，Atom を日常的にエディタとして利用するために必須のプラグインをご紹介したいと思います．
japanese-menu メニューバーやコンテキストメニューを日本語化してくれるプラグインがJapanese Menuです． 日本人であれば取り敢えず入れておいて損はないでしょう．
atomic-emacs キーボード・バインディングをemacs風に変更してくれるプラグインがAtomic Emacsです． emacsに慣れている人には必須のプラグインです． これを入れないなら素直にemacsを使います． killing &amp;amp; Yanking (コピー &amp;amp; ペースト)のバインディングも覚えておきましょう．
Ctrl + k (Kill Line) Ctrl + w (Kill Region) Ctrl + y (Yank Line) その他，よく利用するキー・バインディングです．
Ctrl + SPACE (Set Mark) Ctrl + / (Undo) Alt + ; (Toggle Comment) Alt + x (Command Palette) project-manager 複数のプロジェクトを切り替えながら作業するときに便利なプラグインがProject Managerです． プロジェクトのリストを表示するキー・バインディングは覚えておきましょう．
Alt + Shift + p (List Projects) markdown-writer 忘れがちなマークダウン記法の入力を強力にサポートしてれるプラグインがMarkdown-Writer for Atomです． 残念ながら，キーバインディングが，emacsと重複していることも多く，全ての機能をフルに活用するのは難しいのですが， チートシート（CHEATSHEET） だけでも何気に有り難いです．</description>
    </item>
    
    <item>
      <title>sedでJekyllからHugoに変換</title>
      <link>https://mukai-lab.info/pages/tech/hugo/2019-05-07-hugo_sed/</link>
      <pubDate>Tue, 07 May 2019 13:11:49 +0900</pubDate>
      
      <guid>https://mukai-lab.info/pages/tech/hugo/2019-05-07-hugo_sed/</guid>
      <description> JekyllからHugoに移行する際に，用いたsedワンライナーを記録しておきます． Hugoにはマークダウンの変換用のスクリプトが付属していますが，細かな修正はどうしても必要になります． sed を用いると効率的にテキストの置換が可能です． また，下記コマンドを実行すると結果は標準出力に流れますが， -i -e オプションを付けることでファイルを上書きします．
H1要素を独自のショートコード（title-logo）に置換 % sed &amp;#34;s/^# .*&amp;gt;\(.*\)/\{\{&amp;lt; title-logo title=\&amp;#34;\1\&amp;#34; &amp;gt;\}\}/g&amp;#34; FILE JekyllのLiquid構文をショートコード（gist）に置換 % sed &amp;#34;s/^{% gist \(.*\)\/\(.*\)%}//g&amp;#34; FILE インデントを削除 % sed &amp;#34;s/^ \(.*\)/\1/g&amp;#34; FILE</description>
    </item>
    
    <item>
      <title>授業資料</title>
      <link>https://mukai-lab.info/pages/classes/</link>
      <pubDate>Sun, 05 May 2019 21:10:11 +0900</pubDate>
      
      <guid>https://mukai-lab.info/pages/classes/</guid>
      <description> 椙山女学園大学  基礎演習 基幹演習 プログラミング1 プログラミング応用 展開演習2 知能情報システム 卒業研究指導1  愛知大学  プログラミング  </description>
    </item>
    
    <item>
      <title>技術メモ</title>
      <link>https://mukai-lab.info/pages/tech/</link>
      <pubDate>Sat, 04 May 2019 19:13:02 +0900</pubDate>
      
      <guid>https://mukai-lab.info/pages/tech/</guid>
      <description> Tableau  Tableauでオープンデータを可視化 Tableauで色々なグラフを作成しよう  Emotiv  Emotivで脳波を可視化 Cotexで脳波データを取得 脳波データをフーリエ解析  Tobii Eyetracker  Tobii Eye Trackerを利用した視線の認識 OpenCVを利用した視線位置の描画  RoBoHoN  ロボホンの開発環境の構築 トリガを用いた発話 QRコードの読み取り  Unity  NyARToolkit for Unityの導入 NyARToolkit for Unityで画像を表示 NyARToolkit for Unityで3Dモデルを表示 NyARToolkit for Unityで3Dモデルのアニメーション NyARToolkit for UnityでNFTを利用したマーカーの認識 Google VR SDKを利用した360°画像ビューアー Google VR SDKで視線の検知  Codecomabat  CodeCombatでプログラミング学習  enchant.js  MOONBlockでゲームプログラミング  Processing  Processingではじめての画像処理  Jekyll  Jekyllデフォルトテンプレートの自動リンク Jekyllにおけるシンタックスハイライト Liquidを利用したファイルの埋め込み Jekyllでオープン・グラフ・プロトコル（OGP）の設定  GitHub  Github Pagesでの独自ドメインの設定 Git Bashのホームディレクトリの変更  Atom  Atomに必須のプラグイン紹介  Emacs  MacでEmacs  Java  Java 8における「Access Restriction」の回避  Hugo  sedでJekyllからHugoに変換  </description>
    </item>
    
    <item>
      <title>Java 8における「Access Restriction」の回避</title>
      <link>https://mukai-lab.info/pages/tech/java/2016-02-25-javafx/</link>
      <pubDate>Thu, 25 Feb 2016 06:18:31 +0000</pubDate>
      
      <guid>https://mukai-lab.info/pages/tech/java/2016-02-25-javafx/</guid>
      <description>Eclipse環境でJavaFX（javafxパッケージ）をインポートしようとすると， 「Access Restriction」エラーとなってしまいコンパイルできません． JavaFXはJava 8では標準のGUIライブラリとして統合されたはずなのに， なんでだー となったので回避方法を調べてみました．
Eclipseのツールバーから[ウィンドウ]-[設定]-[Java]-[コンパイラー]-[エラー/警告]を選択します． ここで下記のように「使用すべきではない制限されたAPI」の「禁止された参照」を 無視 に設定します． これで問題なくインポートできるはずです．</description>
    </item>
    
    <item>
      <title>Jekyllでオープン・グラフ・プロトコル（OGP）の設定</title>
      <link>https://mukai-lab.info/pages/tech/jekyll/2016-02-23-ogp/</link>
      <pubDate>Tue, 23 Feb 2016 00:27:33 +0000</pubDate>
      
      <guid>https://mukai-lab.info/pages/tech/jekyll/2016-02-23-ogp/</guid>
      <description>フェイスブックでシェアされたときに表示される画像は，オープン・グラフ・プロトコル（OGP）で制御されています． OGPの設定がなければ，自動で適当な画像が選択されますが，意図しない画像が選択されることも多いです． そこで，Jekyllで採用されている「YAML Front Matter」を利用してOGPを設定する方法をメモしておきます．
まずは，ブログ記事などのファイルの先頭に， 下記のようにimageという変数を用意して，参照する画像を設定しておきます．
--- layout: default image: &amp;#34;https://i.gyazo.com/cdf2b2e7be4e80421f55152a4b348a7a.png&amp;#34; --- これで page.image という記述で設定された値を取得することができるようになります． 次に，&amp;rdquo;_includes/head.html&amp;rdquo;に下記のように page.image を利用してOGPの設定をします． このとき，条件文を利用することで page.image が設定されている場合に限ってOGPの設定を有効にしています． OGPは&amp;lt;meta property=&amp;quot;og:image&amp;quot; content=&amp;quot;参照画像&amp;quot;&amp;gt;と記述します．
 これで，フェイスブックでシェアされたときの画像が設定されます． もし画像が反映されない場合は，フェイスブックのキャッシュが原因かもしれません． この場合は，Open Graph Object Debuggerでキャッシュを削除してみましょう．</description>
    </item>
    
    <item>
      <title>Git Bashのホームディレクトリの変更</title>
      <link>https://mukai-lab.info/pages/tech/github/2016-02-17-git-bash/</link>
      <pubDate>Wed, 17 Feb 2016 02:34:43 +0000</pubDate>
      
      <guid>https://mukai-lab.info/pages/tech/github/2016-02-17-git-bash/</guid>
      <description>WindowsでGit環境を構築するとお世話になるであろう Git Bash のホームディレクトリの変更に関してメモします． GitHubのレポジトリはZ:\GitHubに設置しているため，このZ:\GitHubをホームディレクトリに設定することを目指します．
まずは，WindowsとはいえBash であることに変わりはないので，C:\Users\Naoto.bashrcを作成して，環境変数$HOMEの設定を変更してみます．
HOME=/z/GitHub/ これで問題解決と思いきや，Git Bash を実行してみると下記のように，起動時のディレクトリは/c/Users/Naotoのままです． ちなみに，環境変数$HOME自体は設定されていて，cdコマンドを実行すると/z/GitHub/に移動します．

そこで，アプローチを変更して， Git Bash のショートカットアイコンのプロパティを変更してみます． プロパティには 作業フォルダ という項目があり，ここにZ:\GitHub設定します． また，リンク先には &amp;ndash;cd-to-home という引数が設定されているので削除しておきます．

これでGit Bashのショートカットアイコンから起動してみると， 下記のように無事にホームディレクトリを変更することができました．</description>
    </item>
    
    <item>
      <title>Liquidを利用したファイルの埋め込み</title>
      <link>https://mukai-lab.info/2016/02/10/include/</link>
      <pubDate>Wed, 10 Feb 2016 08:45:44 +0000</pubDate>
      
      <guid>https://mukai-lab.info/2016/02/10/include/</guid>
      <description>JekyllではテンプレートエンジンとしてLiquidを採用しています． このLiquidでは タグ や フィルタ という機能を利用して， ウェブページ制作における無駄を減らすすことが可能です．
ここでは，複数のページに共通で利用されるコードの断片を他のファイルから読み込んで埋め込む方法を紹介します． 埋め込むコードを common.html として作成し， _includes ディレクトリに配置します． 後はMDファイルやHTMLファイルに下記のように記述するだけです．
 その他，Gistで公開しているソースコードも下記の方法で公開可能です．
 ただし，jekyll-gistを事前にインストールし， さらに，_config.yml に下記の設定を加えておく必要があるようです． この _config.yml の設定は忘れがちになるので特に注意が必要です．
 </description>
    </item>
    
    <item>
      <title>Github Pagesでの独自ドメインの設定</title>
      <link>https://mukai-lab.info/pages/tech/github/2016-02-08-domain/</link>
      <pubDate>Mon, 08 Feb 2016 09:13:03 +0000</pubDate>
      
      <guid>https://mukai-lab.info/pages/tech/github/2016-02-08-domain/</guid>
      <description>ブログを立ち上げたので独自ドメインを取得してみることにしました． ドメインはお名前.comで，トップレベルドメインには「.info」を選択しました． １年間の契約でなんと「269円（手数料込）」！ メジャーなトップレベルドメインではないとはいえ，この安さに驚きました（普段，ドメイン取得することないからなぁ）．
さて，ホスティングしているGithub Pagesを独自ドメインで公開する方法ですが， 様々なサイトで詳しく情報が公開されており，検索すれば容易に発見できると思います． 他と重複する情報とはなりますが，念のためメモしておきたいと思います．
まずは，お名前.comの設定ですが， ドメインNaviでGithub PagesのDNSレコードの登録が必要です． 具体的には，下記のようにAレコードとして，192.30.252.153と192.30.252.154を登録するだけです． （参考：Github Help）

次に，自身のレポジトリの設定ですが， CNAME という名前をファイルを作成し， 転送先の独自ドメイン（ここでは muka-lab.info ）を入力します． 後は，このファイルを他のHTMLファイルなどと一緒にデプロイするだけです． これらの変更の適用には時間がかかるようなので， 少し時間を空けてから転送が成功するか確認しましょう．</description>
    </item>
    
    <item>
      <title>Jekyllにおけるシンタックスハイライト</title>
      <link>https://mukai-lab.info/pages/tech/jekyll/2016-02-05-highlight/</link>
      <pubDate>Fri, 05 Feb 2016 02:58:35 +0000</pubDate>
      
      <guid>https://mukai-lab.info/pages/tech/jekyll/2016-02-05-highlight/</guid>
      <description>Jekyllが得意とするシンタックスハイライトですが，設定でつまずいたのでメモしておきます． シンタックスハイライトにはrougeやpygmentsが利用されるようですが，ここではrougeを適用してみたいと思います． まずは，下記のコマンドでrougeをインストールします．
gem install rouge 次に，&amp;rdquo;_config.yml&amp;rdquo;でシンタックスハイライトにrougeを指定しておきます．
highlighter: rouge ここまでは，何てことないのですが，ここからつまずきました． シンタックスハイライトのスタイルは&amp;rdquo;_syntax-highlighting.scss&amp;rdquo;で設定されているようです． 色などを変更したい場合は，このファイルを修正すれば良いはずですが，何故か変更が適用されません．
マークダウンでハイライトするときは，ソースコードを``で囲みます． 変換後のhtmlを確認すると，該当箇所は下記のように，クラス属性にhighlighter-rougeが設定されています．
&amp;lt;code class=&amp;#34;highlighter-rouge&amp;#34;&amp;gt;&amp;lt;/code&amp;gt; 再度，&amp;rdquo;_syntax-highlighting.scss&amp;rdquo;を確認すると，クラス属性はhighlightとして設定されています． そこで，ファイル内のクラス属性をhighlighter-rougeに置換することで，シンタックスハイライトが適用されました． 試行錯誤の末，シンタックスハイライトの適用までこぎつけましたが，この辺り十分に理解できていないかもしれません．</description>
    </item>
    
    <item>
      <title>Jekyllデフォルトテンプレートの自動リンク</title>
      <link>https://mukai-lab.info/pages/tech/jekyll/2016-02-04-top_link/</link>
      <pubDate>Thu, 04 Feb 2016 09:26:26 +0000</pubDate>
      
      <guid>https://mukai-lab.info/pages/tech/jekyll/2016-02-04-top_link/</guid>
      <description>Jekyllのデフォルトテンプレートでは， トップページのヘッダ部の右にサイトに含まれるページのリンクを自動的に追加してくれます． これはとても便利な機能ではあるのですが，ページ数が増えてくると，特定のページは除いて欲しいというケースが発生します．
そこで，YAML Front Matterを利用して解決します． まずは，&amp;rdquo;_templates/page&amp;rdquo;に，top_linkという名前の変数を下記のように用意します． これで，新規に作成するページには，top_linkの行が自動的に追加されます．
 トップページに自動的にリンクを追加する場合は，ページを作成した後で，このtop_linkの値を&amp;rdquo;true&amp;rdquo;に設定しておきましょう． 次に，&amp;rdquo;_includes/header.html&amp;rdquo;に下記のようにtop_linkに関する条件文を追加します．
 これで，トップページの自動リンクをtop_linkという変数で制御できるようになります．</description>
    </item>
    
    <item>
      <title></title>
      <link>https://mukai-lab.info/pages/classes/applied_programming/chapter4/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://mukai-lab.info/pages/classes/applied_programming/chapter4/</guid>
      <description>image: https://i.gyazo.com/48c3004c139530db5cac1d01e17af0e2.png
title: 配列と繰り返し  
プロジェクトの準備 -- プロジェクトの準備Eclipseで新規にプロジェクトを作成しましょう． メニューから[ファイル]-[新規]-[Javaプロジェクト]をクリックして，「新規Javaプロジェクトの作成」を開きます． ここでは，プロジェクト名に”Project4”を入力して，[完了]をクリックしましょう． パッケージ・エクスプローラに作成したプロジェクトが表示されていることを確認してください．

続いてソースファイルを作成しましょう． メニューから[ファイル]-[新規]-[クラス]をクリックして，「新規Javaクラス」を開きます． ここでは，名前に”MyClass”を入力し，public static void main(String[] args)(V)にチェックを入れ，[完了]をクリックしましょう． パッケージ・エクスプローラに作成したソースファイルが表示されていることを確認してください．

配列とは -- 配列とは変数は数値や文字列などのデータを1つだけしか記憶できません． しかし，複数のデータを一つのグループとして扱いたい場合があります． 例えば，5人の学生が受けた試験の得点を記憶することを考えてみましょう． 変数を利用して記録する場合は，5つの変数を用意しなければならず面倒です． このようなときに便利なのが配列です． 配列は同じデータ型の複数の値を1つの配列名で記憶することができます． 配列を宣言するにはデータ型[] 配列名 = new データ型[要素数];と記述します． 配列に記憶されるデータは要素と呼ばれ，各要素には添え字という番号で参照します．
下記のコードを参考に，配列scoreを宣言して，5人の得点を記録してみましょう． 配列の添え字は0番から始まることに注意してください． プログラムの実行後に，コンソールの出力結果を確認してください．
 配列の要素を初期化するには，上記のように各要素に値を代入する方法の他に， 「{}」を利用してデータ型[] 配列名 = {78, 84, 94, 64, 82};と記述する方法もあります．
下記のコードを参考に，配列scoreの初期化を行いましょう． プログラムの実行後に，コンソールの出力結果を確認してください．
 また，配列の要素数を取得するには配列名.lengthと記述します． 下記のコードを参考に，配列scoreの要素数をコンソールに出力してください． プログラムの実行後に，コンソールの出力結果を確認してください．
 for文 -- for文制御構文の1つであり，条件を満たすまで同じ命令文を繰り返す制御が繰り返しです． 今回はこの繰り返しについて学習します． 指定した回数だけ命令を繰り返すにはfor文を利用します． for文は下記のように記述します． 「()」内には，変数の初期化，繰り返し条件，変数の更新を記述します． 例えば，int型の変数iを宣言し，iの値を1ずつ増やしながら，10回同じ命令を繰り返すには， for(int i=0; i&amp;lt;10; i++)と記述します． ここでi++は値を1だけ増やすという演算子であり，i=i+1と同じ処理です．</description>
    </item>
    
    <item>
      <title>2項分布</title>
      <link>https://mukai-lab.info/pages/classes/advanced_studies_seminar_2/chapter6/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://mukai-lab.info/pages/classes/advanced_studies_seminar_2/chapter6/</guid>
      <description>2項分布 -- 2項分布2項分布とは，結果が2通り（例，成功・失敗）となる試行を複数回行ったときの確率分布です． 例えば，「コインを投げる」という試行の結果は，表，または，裏のどちらかになります． 他にも，「サイコロを投げる」という試行の結果は，偶数，または，奇数のどちらかになります． このような試行はベルヌーイ試行と呼ばれ，ベルヌーイ試行を複数回行ったときの結果が2項分布に従います． 今回は，サンプルデータを基に2項分布のグラフを描く事から始め，2項分布を利用して生起確率を求める方法を学びます．
スクリプトの作成 -- スクリプトの作成コードを入力し保存するためのスクリプトを作成しましょう． [ファイル]-[新しいスクリプト]をクリックし，Rエディタを表示します． 次に，[ファイル]-[保存]をクリックして，スクリプトを保存します． このとき，ファイル名はchapter6としてください． また，ファイルの保存場所と作業ディレクトリをデスクトップに変更しておきます． このとき，グラフ描画に必要なggplot2も読み込んでおきましょう．
library(ggplot2) 2項分布のグラフ -- 2項分布のグラフまずは「コインを投げる」という試行に注目しましょう． 試行の結果は，表 と 裏 の2通りですが，ここでは便宜的に，1 と 0 で表現します． このとき，1 が出る確率は50%と仮定します．当然，0 が出る確率も50%です． この試行を10回繰り返して行ない，1 が出た数をカウントします．
乱数を生成するsample関数を用いて，上記の試行の結果を生成してみましょう． 引数には，「取り得る値のベクトル（ここでは，0または1）」，「乱数の個数（ここでは10回）」，「重複の許可」を設定します． 結果は下記のようになりました（乱数なので結果は毎回変わる）． 10回投げて，表が5回，裏も5回という結果です．
&amp;gt; sample(0:1,10,replace=TRUE) [1] 0 1 1 1 0 0 1 0 0 1 さらに，この試行（「コインを10回投げる」）を1000回繰り返し，配列に変換して変数coinに代入しましょう．
coin &amp;lt;- matrix(sample(0:1,10000,replace=TRUE),1000,10) coinは1000行，10列の配列になります． これが，試行を1000回繰り返した結果を表しています．
&amp;gt; coin[1:10,] [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] [,9] [,10] [1,] 0 1 0 1 0 1 0 1 1 1 [2,] 0 0 1 1 1 0 0 1 1 0 [3,] 1 0 0 0 1 1 0 1 1 1 [4,] 0 0 1 0 0 1 1 1 0 0 [5,] 0 1 0 1 0 1 1 0 0 0 [6,] 0 1 1 0 0 0 1 1 1 1 [7,] 0 0 1 1 1 1 1 0 1 1 [8,] 1 1 0 0 1 0 1 0 1 1 [9,] 1 0 0 0 0 1 1 0 1 0 [10,] 0 0 0 0 1 1 1 1 0 1 次に，各試行の表の出た回数をカウントし，ベクトルcountに代入します． 各行の総和を求めるにはrowSums関数を用います．</description>
    </item>
    
    <item>
      <title>3Dグラフィックス</title>
      <link>https://mukai-lab.info/pages/classes/programming_1/chapter9/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://mukai-lab.info/pages/classes/programming_1/chapter9/</guid>
      <description>スケッチの作成Processingを起動して、新規にスケッチを保存しましょう。 メニューから[ファイル]-[名前を付けて保存]をクリックして、「スケッチフォルダを名前を付けて保存」を開きます。 ファイル名に「Project9」を入力し、[保存]をクリックしましょう。 保存先に「Project9」という名前のフォルダが作成されていることを確認してください。

3次元グラフィックスProcessingは、これまで学んできた2Dグラフィックスだけでなく、3Dグラフィックスの描画も可能です。 3Dグラフィックスを描画するには、「P3D(Processing 3D)」または「OpenGL」の いずれかのレンダラを指定しますが、ここでは標準のP3Dを採用することにします。 P3Dを指定すると、2次元の座標系（x,y）が、３次元の座標系（x,y,z）に変更されます（z軸は奥行きを表します）。
まずは、下記のコードを参考に、size()関数でP3Dを指定しましょう。 また、rect()関数で、1辺の長さが200の正方形を描きまます。 ここで、translate()関数を利用して、原点をウィンドウ中央に変更していることに注意してください。 Runボタンをクリックしたら、正方形が画面中央に描かれることを確認してください。
 
このままでは、座標系が３次元に変更されているか確認出来ません。 そこで、マウスの動きに合わせて正方形を、X軸とY軸を中心に回転させてみましょう。 X軸まわりに回転させるにはrotateX()関数、Y軸まわりに回転させるにはrotateY()関数を利用します。 いずれも引数には回転する角度をラジアン角で指定します。
下記を参考にコードを入力したら、Runボタンをクリックしてください。 ドラッグしたままマウスを動かすと、正方形が回転することを確認してください。
 

立体的な図形の描画立体的な図形を描画してみましょう。 直方体を描画するにはbox()関数を利用します。 box()関数の引数には、直方体の幅（width）、高さ（height）、奥行き（depth）を指定します。 box()関数で描かれた直方体は原点を中心に描かれることに注意してください。
box(width, height, depth); 下記を参考にコードを入力したら、Runボタンをクリックしてください。 ドラッグしたままマウスを動かすと、直方体が回転することを確認してください。
 
球を描画するにはsphere()関数を利用します。 sphere()関数の引数には、半径（radius）を指定します。 sphere()関数で描かれた球は原点を中心に描かれることに注意してください。
sphere(radius); 下記を参考にコードを入力したら、Runボタンをクリックしてください。 ドラッグしたままマウスを動かすと、球が回転することを確認してください。
 
光源の設置立体的な図形に陰影をつけるには空間に光源を設置します。 光源には環境光、拡散光、点光源などの種類があります。
環境光は、全方向から図形に対して均一の光を照らします。 全方向から照らすため影は出来ないことから、他の光源と組み合わせて用いるのが一般的です。 環境光を設置するには、ambientLight()関数を用います。 引数には三原色（R、G、B）の光の強度を0～255の範囲で設定します。
ambientLight(R, G, B); 下記を参考にコードを入力したら、Runボタンをクリックしてください。 直方体全体の色が変化していることを確認してください。</description>
    </item>
    
    <item>
      <title>ARToolkitを利用した拡張現実</title>
      <link>https://mukai-lab.info/pages/classes/programming_1/chapter12/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://mukai-lab.info/pages/classes/programming_1/chapter12/</guid>
      <description>スケッチの作成Processingを起動して、新規にスケッチを保存しましょう。 メニューから[ファイル]-[名前を付けて保存]をクリックして、「スケッチフォルダを名前を付けて保存」を開きます。 ファイル名に「Project12」を入力し、[保存]をクリックしましょう。 保存先に「Project12」という名前のフォルダが作成されていることを確認してください。

NyARToolkitの導入ARToolkitは奈良先端科学技術大学院大学の加藤研究室によって 開発された拡張現実（Augumented Reality: AR）のためのソフトウェアです。 拡張現実とは、コンピュータを利用して、現実世界の一部に「仮想的な物体や情報」を重ねて表示することを指します。 このARToolkitのProcessing向けのライブラリが「NyARToolkit for Processing」です。
GitHubのリリースページから、 最新バージョンのNyARToolkitをダウンロードしましょう。 ダウンロードしたファイルはZIPで圧縮されているので解凍し、 解凍後のlibraryフォルダをコピーして、「スケッチフォルダ（Project12）」の中に配置しましょう。 コピーしたら、フォルダの名前をlibraryからcodeに変更します。 同様に、カメラの設定ファイルcamera_para.datも「スケッチフォルダ（Project12）」の中にコピーしておきます。


次に、ソースコードの先頭に「import jp.nyatla.nyar4psg.&amp;lowast;;」を入力してください。 また、今回もカメラ映像を利用するため、[スケッチ]-[ライブラリをインポート]-[Video]をクリックして、 Videoライブラリをインポートしておきます。
 カメラ映像の表示Captureクラスを利用して、カメラから入力した画像を表示しましょう。 下記を参考にコードを入力したら、Runボタンをクリックしてください。 ここでは、サイズ（size）が320x240、フレームレート（fps）が30となっている、 3番のカメラを使用していることに注意してください。 ウィンドウにカメラ映像が表示されることを確認してください。
 
拡張現実の表示ARToolkitを利用すると、ARマーカーと呼ばれる特定のパターンをカメラで読み取ることにより、 その位置を認識し、３Dオブジェクトを配置することができます。 ここでは、NYARToolkitに標準搭載されているNyIDを利用します。 NyIDには番号が設定されており、 ここではMODEL2の1番のNyIDを利用します。
まずは、下記のように、MultiMarkerクラスを利用して、利用するマーカーを設定します。 MultiMarkerクラスのインスタンスを作成するときは、カメラ映像の幅と高さに加え、 カメラのパラメータファイル（camera_para.dat）を指定します。 また、対象のNyIDを登録するには、addNyIDMarker()関数を利用します。 引数には「NyIDの番号」と「マーカーの物理サイズ（mm）」を指定します。
marker = new MultiMarker(this, 320, 240, &amp;#34;camera_para.dat&amp;#34;); marker.addNyIdMarker(1, 80); 次に、detect()関数で、カメラ映像からマーカーを検出し、 drawBackground()関数でカメラ映像を背景に設定します。 いずれの関数も引数にはCaptureクラスのインスタンスを渡します。
marker.detect(cam); marker.drawBackground(cam); 最後に、マーカーが検出された場合に、立方体をマーカー上に配置します。 ここで、beginTransform()関数によって、原点をカメラに映ったマーカーの中心に変更していることに注意してください。 endTransform()関数で、元の座標系に戻ります。</description>
    </item>
    
    <item>
      <title>CodeCombatでプログラミング学習</title>
      <link>https://mukai-lab.info/pages/tech/codecombat/codecombat/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://mukai-lab.info/pages/tech/codecombat/codecombat/</guid>
      <description>CodeCombatとはCodeCombatはRPG風のゲームを遊びながらプログラミングを学ぶことができるプラットフォームです。 オープンソースのコミュニティで運営されており、2013年に公開されて以降、500人以上のプログラマーがこのプロジェクトに関わって開発が続けられています。 IEやChromeなどのウェブブラウザさえあれば、プラットフォームに参加できることが特徴であり、50以上の言語に翻訳され、世界で5,000,000人以上のプレイヤーがこのプラットフォームでプログラミングを学んでいます(2016年11月18日現在)。 本格的にプラットフォームを利用するには、アカウント登録が必要ですが、今回はアカウント登録はしないで、プログラミングの基本的な文法を学ぶ「キースガードのダンジョン」に挑戦してみましょう。 この授業を受ける多くの皆さんは「プログラミングは難しい」という先入観を持っているのではないでしょうか。 この授業が終わった頃には「プログラミングは楽しい」と思ってもらえることを期待します。

学習コースの選択早速、CodeCombatでプログラミング学習を始めましょう。 まずは、下記のリンクをクリックしてブラウザでCodeCombatを開きます。
CodeCombat CodeCombatを開いたら、「今すぐプレイ」をクリックしましょう。 すると、学習コース（ダンジョン）を選択するページに遷移します。

プログラミングに必要な、文法、メソッド、パラメータなどの基本的なスキルを学ぶことが出来る学習コースが「キースガードのダンジョン」です。 キースガードのダンジョンの「ゲームスタート」をクリックしましょう。

キースガードのダンジョン ～始まりの回廊~キースガードのダンジョンは、40のステージで構成されています。 まず最初は「始まりの回廊」に挑戦します。 「始まりの回廊」をクリックしすると、このステージの概要が表示されます。 このステージの目的は「宝石を集めること」のようです。 「壁の針」がちょっと気になりますね。 では、ゲームスタートを選びましょう。


次に、ヒーロー（主人公）を選択する画面になります。 最初は４人しか選べませんが、ゲームを進めると選択できるヒーローが増えていきます。 好きなヒーローを選びましょう。 剣士の「サー・サーリン・サンダフィスト」を選択したとして説明を続けます。 また、この画面では学習するプログラミング言語を選択します。 ここでは、ウェブで用いられる「JAVASCRIPT」を選びましょう。 ヒーローとプログラミング言語の選択が終わったら「次へ」をクリックしましょう。

次に、武器や防具などを装備するイベントリの画面になります。 ここでは、ヒーローを上下左右に動かすための「質素な靴」を装備します。 靴のアイコンをダブルクリックすると装備することが可能です。 「質素な靴」を装備したら「ゲームスタート」をクリックしましょう。


さぁ、とうとうゲームが開始しました。 「レベルスタート」をクリックしましょう。 このステージの目標は「壁の針をよける」「宝石を集める」の２つです。 プログラムをコーディングして目標を達成しましょう。

マップを確認すると、ヒーローはスタート位置から右に進んだ後に、壁の針を避ける必要がありそうです。 ヒーローを下に進めるには「hero.moveDown()」というコードを入力すれば良さそうです。 では、6行目に上記のコードを追加して、「実行」をクリックしましょう。


これで、残るはヒーローの右にある宝石をゲットするだけです。 ヒーローを右に進めるには「hero.moveRight()」というコードを入力しましょう。 では、7行目に上記のコードを追加して、「実行」をクリックしましょう

宝石をゲットして、全ての目標を達成したため、ゲームクリアです。 「完了」をクリックしましょう。 獲得した経験値、ジェム、武器・防具を確認したら「次へ」をクリックします。


これで、最初のステージは終了です。 プログラミングに興味が湧いてきましたか。 ではその調子で次のステージに挑戦してみましょう。</description>
    </item>
    
    <item>
      <title>Cortexで脳波データの取得</title>
      <link>https://mukai-lab.info/pages/tech/emotiv/emotiv2/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://mukai-lab.info/pages/tech/emotiv/emotiv2/</guid>
      <description>CortexとはPython を経由して，Emotiv Epoc+ で計測したデータを取得してみましょう． データを取得するには，Emotivの標準APIであるCortexを利用します． 今回はPythonを利用しますが，このCortexは JSON と WebSockets で実装されているため， Python以外のプログラミング言語でも利用可能です． また，Cortexは，EmotivProと一緒にインストールされますが， Cortex UIというソフトウェアで動作確認が可能です． 下図のように対象のデバイスが検出されていればOKです． コンタクト・クオリティは今回も35%とパッとしません（笑）．

ライブラリの導入Pythonはウィンドウズ版のバージョン3.7.2を用いることにします． Cortexでは，データの送受信には WebSockets という技術を用います． ここでは，WebSockets のクライアント（データ受信側）として実装するため， websocket-client ライブラリをインストールしておきます．
$ pip install websocket-client また，WebSocketsのポート番号は 54231 です． URLには wss://localhost:54321 を指定します． ここで，wss はWebSocketsのプロトコルを表しています．
手順１：認証Cortexから脳波の生データを取得するには，クライアントIDとシークレットで認証が必要です． この，クライアントIDとシークレットは，EMOTIVのユーザページで事前に取得しておきましょう（ライセンス番号も必要）．
まずは，CORTEXで用いられるJSON-RPCについて簡単に説明します． 上述したように，サーバとクライアント間のデータのやりとりをJSON形式で行うという仕組みです． クライアントが送信するリクエストの基本フォーマットは下記です． ここで，プロトコルバージョンの jsonrpc は常に 2.0 を指定します． メソッドやパラメータには，認証（authorize）やデータ取得（subscribe）などの文字列を指定します．
{ &amp;#34;jsonrpc&amp;#34;: &amp;#34;2.0&amp;#34;, &amp;#34;method&amp;#34;: メソッド, &amp;#34;params&amp;#34;:{ パラメータ: 値 }, &amp;#34;id&amp;#34;: ID番号 } また，クライアントが受信するレスポンスの基本フォーマットは下記となります． サーバーからの応答結果は result に格納されています． また，リクエストと同じID番号が付与されています．</description>
    </item>
    
    <item>
      <title>Emotivで脳波を可視化</title>
      <link>https://mukai-lab.info/pages/tech/emotiv/emotiv/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://mukai-lab.info/pages/tech/emotiv/emotiv/</guid>
      <description>
EmotivとはEmotivは株式会社イノバテックが提供している小型の脳波計です． Epoc+，INSIGHT，EPOC flexなど複数の種類がありますが， ここでは，14チャネルの電極が装着されたEMOTIV EPOC+を対象に開発することを目的とします． この装置は，他の脳波計と比べ，スタイリッシュなデザインが特徴です． 頭に装着するだけで，未来感がビシビシ伝わってきます． 専用のアプリケーションであるEmotivPROで， 脳波データを取得・可視化するだけなら無料のラインセンスで利用可能です． しかし，脳波の生データをAPI（Cortex）を経由して取得するなど， 研究を目的として利用するためには，別途ライセンスの購入が必要です． 月額99ドルと決して安くはないため注意が必要です（年払いで割引されますが）．

EmotivPROを使ってみよう最初に，専用のアプリケーションであるEmotivPROを利用して， 脳波データを取得・可視化してみましょう． まずは，電極のフェルドパッドを生理食塩水で水和させます． この生理食塩水はコンタクトレンズなどにも用いられているものです． ここで，しっかりと水和させておかないと，センサーの感度が悪くなる可能性があります． 電極を時計回りに回すと取り外すことができますが， 力を入れ過ぎるとフェルト部分がはずれてしまうので要注意です．

それでは，ヘッドセットを頭に装着します． ヘッドセットを両手で持ち，頭上から下に向かってスライドさせます． このとき，左右の参照電極を，ちょうど耳たぶの裏の骨部分に配置します． 参照電極を用いた方法は単極導出と呼ばれ，この参照電極と他の電極との電位差が記録されます． この参照電極は，他の電極にも影響するため，正確な設置が必要です． また，前方の左右の電極は，眉毛から指３本だけ上にあるように配置します．

この電極の設置の質（コンタクト・クオリティ）はEmotivProの下記の画面で確認できますが，・・・，非常に難しい． 緑色の電極はコンタクト・クオリティが高いことを示しています． 電極の位置を微調整しても，コンタクト・クオリティは全体で28%がやっとでした． このあたりのコツをご存知でしたら，お教えください．

脳波を可視化しよう次は脳波を可視化してみましょう． ここで，脳波のサンプリングレートとA/D変換の分解能を確認しておきます． サンプリングレートは128Hz，また，分解能は16ビット（65536階調）です． 図中にEEGと表記がありますが，これはElectroencephalographの略で脳波（図）を意味しています （単に脳波をEEGと呼ぶことも多い）．

次に電極の位置番号を確認しておきます． 上述したようにEpoc+では，14チャネルの電極があり， それぞれ，AF3，AF4，F3，F4，F7，F8，FC5，FC6，T7，T8，P7，P8，O1，O2です． 図中の赤い丸で表現されている電極は，耳たぶの裏にある参照電極です． ここでは，コンタクト・クオリティの高いAF4，F3，P8の３箇所に注目します．

AF4，F3，P8の３箇所の電極の生データは下記です． 横軸は時間で単位は10[ms]，また，縦軸は電位を表し-100&amp;micro;V〜100&amp;micro;Vの範囲を取ります． 一般的にローデータから，脳波の意味を読み取ることは困難なため，高速フーリエ変換をして周波数成分を取り出します．

EmotivProはフーリエ変換した周波数スペクトルの表示も可能です． P8にフーリエ変換をした結果は下記のようになります． 周波数に応じて脳波は分類され，4〜8Hzはシータ波，8〜12Hzはアルファ波，13Hz以上はベータ波と呼ばれます． この結果では，若干ですがシータ波が有意なように見えます． シータ波は眠い状態で発生する波とされ，いかに寝不足かが分かる結果となりました（笑）．

今回はEmotivの基本的な使い方を解説しました． 次回はCortexと呼ばれるAPIを利用して，Pythonで脳波データを取得することに挑戦します．
参考書籍</description>
    </item>
    
    <item>
      <title>Excelを利用した7市町オープンデータの分析①・グラフ作成</title>
      <link>https://mukai-lab.info/pages/classes/seminar_fundamental_areas/chapter1/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://mukai-lab.info/pages/classes/seminar_fundamental_areas/chapter1/</guid>
      <description>オープンデータとは平成２４年，日本において公共データの活用促進を目的として電子行政オープンデータ戦略が策定されました． この戦略では，「公共データ活用の推進」「公共データ活用のための環境整備」が具体的な施策とされており， これらの施策の鍵となるのがオープンデータです．
オープンデータは下記に従うことを条件としています．
 機械判読に適したデータ形式 二次利用が可能な利用ルールで公開  つまり，行政（地方自治体）が保持している統計データや施設データなどを， 誰もが再利用や再頒布ができることを条件に，コンピュータに扱いやすい形式で公開されたデータをオープンデータと呼びます． 企業や個人のデータでも上記に従えばオープンデータですが，ここでは，行政のデータにターゲットを絞ります（オープンガバメントデータと呼ぶこともあります）． 一般に，再利用や再頒布が可能なソフトウェアのことはオープンソースと呼ばれることも合わせて覚えておきましょう．
ここで，ポイントとなるのは，「機械判読に適したデータとは何か？」ということです． 一般に小規模のデータを管理するときには，エクセル を採用することが多いです． 文化情報学部では，１年後期に開講されている「コンピュータと情報 Ⅱ」において，エクセルの使い方を学習します． たしかに，エクセルは，デザイン（書式）や関数など様々な機能を提供しており，人間にとってはとても便利なソフトウェアです． しかし，これらのデータをコンピュータで処理しようとするとき，これらの機能が却って冗長となり，コンピュータによる判読が難しい状況が起こります．
具体例をみてみましょう． まずは，エクセル形式（.xlsx）で表現された日進市の人口のデータ（jinkou.xlsx）です． タイトル部分に太字，表部分に罫線などのデザイン（書式）が設定されていることが分かります． これらは，エクセルを利用している人間が見るためのデザインであり，データの本質ではありません． また，エクセル形式（.xlsx）の実態は，XMLや画像などで構成されるZIPファイルであり， 専用のソフトウェア（エクセル，OpenOfficeなど）でしか開くことはできません．

次に，CSV形式（.csv）で表現された日進市の人口のデータ（jinkou.csv）です． CSVは「しーえすぶい」と読み，オープンデータで頻繁に採用されるデータ形式です． データが「,（カンマ）」で区切られて表現されるだけで，エクセルのようなデザイン（書式）は含みません． このため，一般的なエディタ（メモ帳）でも開くことができます（エクセルでも開けます）． エクセル形式（.xlsx）に比べると，人間にとっては理解しにくいですが，コンピュータの判読には優れています．
﻿町名,男,女,総数,世帯数 赤池町,1693,1647,3340,1315 浅田町,2593,2431,5024,2086 梅森町,1017,1034,2051,876 野方町,171,173,344,143 蟹甲町,171,200,371,152 折戸町,1404,1381,2785,1073  今回の授業では，日進市のオープンデータミュージアムで公開されている CSV形式のデータをエクセルで可視化することを目的とします． エクセル以外の方法でオープンデータを扱う方法は第３回以降に解説します．
公開されているオープンデータオープンデータはウェブで公開されるのが一般的であり， 総務省が運用するData.go.jpがオープンデータのカタログサイトとして知られています． このサイトでは，国土交通省，経済産業省などの組織別のデータセット，また，行財政や観光などのトピックに関するデータ・セットが提供されています． 例えば，観光 というキーワードで検索すると，「平成28年度 国際経済調査事業報告書」，「平成28年度 商店街インバウンド・空き店舗実態調査」などのデータセットがヒットします（平成30年2月28日現在）． しかし，残念ながら，これらの多くはPDF形式での提供であり，「機械判読に適したデータ」ではありません． 現状では，まだまだオープンデータの整備は不十分と言えるでしょう．
この他，内閣府のまち・ひと・しごと創生本部が提供している地域経済分析システム（RESAS）が注目されています． RESAS（りーさす）は，総務省が提供している統計情報 e-Statのオープンデータなどを可視化するためのシステムです． 地方自治体の現状や課題を発見することを目的としており，情報を直感的にわかりやすく見える化することができます． 例えば，2015年の愛知県名古屋市の 人口マップ を下記のように可視化することができます． マウスで各市区町村をホバーすると人口が表示され，名古屋市千種区は164,696人であることが分かります． また，人口推移や人口ピラミッドなどのグラフも簡単に描画することができます． このようにデータを可視化して，分かりやすく伝えることも，オープンデータの活用に必要な要素です．</description>
    </item>
    
    <item>
      <title>Excelを利用した7市町オープンデータの分析②・相関分析</title>
      <link>https://mukai-lab.info/pages/classes/seminar_fundamental_areas/chapter2/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://mukai-lab.info/pages/classes/seminar_fundamental_areas/chapter2/</guid>
      <description>相関分析とは相関分析とは，2つの変数XとYの関係性を分析する方法です． 例えば，暑い日にはアイスクリームの売上数が増加すると考えられます． このとき，「X:温度」と「Y:アイスクリームの売上数」には関係がありそうです． 一般に，相関分析には相関係数と呼ばれる評価指標が用いられます（正確にはピアソンの積率相関係数と呼ばれる）． 相関係数は-1から1の範囲で与えられ，1に近いほど正の相関，-1に近いほど負の相関を示します．
   相関係数 相関の強さ     0.7～1 強い正の相関   0.4～0.7 正の相関   0.2～0.4 弱い正の相関   -0.2～0.2 相関なし   -0.4～0.2 弱い負の相関   -0.7～-0.4 負の相関   -1～-0.7 強い負の相関    正の相関は，Xが増加するとYも増加する関係を表し，負の相関は，Xが増加するとYが減少する関係性を表します． 先の「温度」と「アイスクリームの売上数」の例では，温度が増加すると，売上数も増加するので正の相関となります． 相関係数はアンケートの分析などでも用いられるメジャーな分析手法の一つです． ここでは，日進市のオープンデータを対象に相関分析を適用してみましょう．
データの準備前回の授業で日進市の人口ピラミッドを作成しました． グラフから，日進市には子育て世帯が多く，幼稚園や保育園などが充実した地区が人気であることが予想されます． そこで，町別人口・世帯数と子育て支援施設のデータを対象に，相関関係があるかを調べてみましょう．
それでは，日進市のオープンデータミュージアムから 上記の2種類のデータをダウンロードしましょう． まずは，オープンデータミュージアムで公開されている行政活動情報の町別人口・世帯数のデータをダウンロードします． 行政活動情報のページにアクセスし， 平成30年1月1日のCSV形式のデータをダウンロードしてください． このデータには，日進市内の各町（赤池町，浅田町など）の人口や世帯数が含まれています．

次に7市町オープンデータのフォーマットに従った子育て支援施設のデータをダウンロードします． 7市町オープンデータ共通整備項目にアクセスし， CSV形式のデータをダウンロードしてください． このデータには，日進市内にある幼稚園や保育園などの子育て支援施設の名称や住所が含まれています．

相関係数の算出それでは，ダウンロードしたデータをエクセルで読み込み相関係数を算出してみましょう． まずはエクセルを起動して，空白のブックを選択します． セルA1をアクティブにした状態で，データ・タブのテキストまたはCSVからをクリックします． ダイアログが表示されたら，ダウンロードした町別人口・世帯数のファイルを選択し，インポートをクリックします． プレビュー画面で，編集をクリックし，クエリエディタを開きます． ここでは，1行目から3行目の不要なデータを削除してしまいます． 削除後に，1行目をヘッダーとして使用をクリックして，最後に，閉じて読み込むをクリックします． 読み込み後に，下記のように表示されていることを確認してください．</description>
    </item>
    
    <item>
      <title>Excelを利用した統計処理・2項分布</title>
      <link>https://mukai-lab.info/pages/classes/seminar_core_areas_learning/chapter2/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://mukai-lab.info/pages/classes/seminar_core_areas_learning/chapter2/</guid>
      <description>授業の準備今回、分析対象とするデータは、「コインを10回投げる」という試行の結果です。 コイン投げの試行の結果は2通り（表・裏）であり、表を 1 、裏を 0 と表現します。 また、表が出る確率は 50% 、同様に裏が出る確率は 50% と仮定します。 下記のデータは「コインを10回投げる」という試行を100回繰り返したときの結果です（21回目以降の試行は省略）。
上記のデータを含むファイルcoin.csvをダウンロードしましょう。 ファイルをダウンロードしたら、前回と同様にExcelでcoin.csvを読み込んでください。

2項分布まずは、各試行でコインが表になった回数を数えてみましょう。 表は1で与えられるので、各試行の値の総和が表になった回数を表します。 また、表が出る回数は0から10の範囲に収まります。
 セルL2:L101に、sum関数で表が出た回数を求める  
1回目の試行は5回、2回目の試行は7回となりました。 では「コインが表になった回数」はどのような分布になっているか確認するために 分析ツール を利用して ヒストグラム（頻度分布） を求めましょう。 最初に、下図のようにN列に0から10までのデータ区間を入力します。

次に、データタブに切り替え、データ分析をクリックします。 一覧からヒストグラムを選択し、OKをクリックすると、ダイアログが表示されます。 ダイアログに下記の設定をしてから、ヒストグラムを求めて下さい。
 入力範囲にL2:L101を設定する データ区間にN2:N12を設定する 出力オプションで新規ワークシートにチェックを入れる  
新規に作成されたシートには、0から10の範囲で表が出た回数のヒストグラムがまとめられます。 中央の5回が最頻値となっており、中央から離れるほど頻度が小さくなることが分かります（0回と10回は一度も出現していません）。 ここで、頻度を基に各データ区間の発生確率を求めましょう。 C列に頻度を100で割った値を入力します。

さらに、求めた確率で棒グラフを描きます。 C列をマウスで選択し、挿入タブの棒グラフをクリックします。 すると、下図のように、横軸が「表が出た回数」、縦軸が「確率」である棒グラフが描けます（タイトル、軸ラベル、軸の書式設定を図に合わせて修正してください）。

このグラフは2項分布と呼ばれる確率分布に近似することが可能です。 このデータは100回の繰り返しの結果ですが、試行回数が増えるほどに2項分布の理想の形状に近付きます。
2項分布の公式では2項分布の理想的な形状を考えましょう。 2項分布は上記のコインのように結果が2通りの試行を対象とします（ベルヌーイ試行 と呼びます）。 また、試行の結果が生じる確率を生起確率と呼びます。 よって、2項分布は「1回の生起確率が*p*のベルヌーイ試行を、n回行って、k回起こる確率」を表すことになります。
例えば、「コインを5回投げて表が3回出る確率（p=0.5、n=5、k=3）」を考えます。 このとき、「コインを5回投げて表が3回出る組み合わせ」は $ _n C_k = _5 C_3=10$ 通りです。</description>
    </item>
    
    <item>
      <title>Excelを利用した統計処理・正規分布</title>
      <link>https://mukai-lab.info/pages/classes/seminar_core_areas_learning/chapter3/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://mukai-lab.info/pages/classes/seminar_core_areas_learning/chapter3/</guid>
      <description>授業の準備今回、分析対象とするデータは、気象庁が公開している「名古屋の降水量（1891年～2016年）」です。 下記のデータは各年度の降水量（mm）の合計を表しています（1911年以降は省略）。 気象庁では降水量に加え、気圧、気温、湿度など天候に纏わるデータを公開しているので様々なデータを対象に分析すると面白いです。
上記のデータを含むファイルprecipitation.csvをダウンロードしましょう。 ファイルをダウンロードしたら、前回と同様にExcelでprecipitation.csvを読み込んでください。

正規分布正規分布は、平均値に近い値の頻度が高く、平均値から離れるほど頻度が低くなる特徴を持った確率分布のことです。 前回学んだ2項分布も上記と同じような特徴を持ちますが、２項分布 は離散値（例、コインの表が出る回数）を対象としますが、 正規分布 は連続値（例、降水量）を対象とする点が大きく異なります（実際、２項分布の試行回数*n*を無限大に近づけると正規分布に一致する）。 一般に、正規分布は様々な自然現象や社会現象に当てはまると考えられており、上記の降水量も例外ではありません。
まずは、降水量の分布を確認するために 分析ツール を利用して ヒストグラム（頻度分布） を求めましょう。 最初に、下図のようにD列に1100から2500までのデータ区間（幅は200）を入力します。

次に、データ タブに切り替え、データ分析 をクリックします。 一覧からヒストグラムを選択し、OKをクリックすると、ダイアログが表示されます。 ダイアログに下記の設定をしてから、ヒストグラムを求めて下さい。
 入力範囲はB2:B128を設定する データ区間はD2:D9を設定する 出力オプションで新規ワークシートにチェックを入れる  
新規に作成されたシートには、1100から2500の範囲で降水量のヒストグラムがまとめられます。 1700-1900が最頻値となっており、この範囲から離れるほど頻度が小さくなることが分かります。 ここで、頻度を基に各データ区間の確率密度を求めましょう（確率 ではないことに注意）。 実際の降水量は連続値ですが、ヒストグラムは離散値であるため、データ区間の幅を考慮しなくてはいけません。 そこで、C列に頻度を、頻度の合計である126と、データ区間の幅200を掛けた25200 で割った値を入力します。 このとき、データ区間も1700-1900のように区間を含めた表現に修正しておきましょう。

さらに、求めた確率密度で棒グラフを描きます。C列をマウスで選択し、挿入 タブの棒グラフをクリックします。 すると、下図のように、横軸が「降水量」、縦軸が「確率密度」である棒グラフが描けます（タイトル、軸ラベル、軸の書式設定を図に合わせて修正してください）。 確率密度を表していることから、棒グラフの面積の総和が1になることが分かります。

このグラフは正規分布に近似することが可能です。 一般にデータサンプルが多いほど、理想的な正規分布の形状に近付きます。
正規分布の公式正規分布の確率密度は下記の式で与えられます。 2項分布よりも難しく感じると思いますが、この式の重要なパラメータはたった2つです。 １つは平均\mu、もう１つは標準偏差\sigmaです。 この2つのパラメータで正規分布の形状が決まります。
\frac{1}{\sqrt{2 \pi} \sigma} \exp \left(- \frac{(x - \mu)^2}{2 \sigma ^2} \right)  また、上記の計算はExcelではnorm.</description>
    </item>
    
    <item>
      <title>Excelを利用した統計処理・相関係数</title>
      <link>https://mukai-lab.info/pages/classes/seminar_core_areas_learning/chapter1/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://mukai-lab.info/pages/classes/seminar_core_areas_learning/chapter1/</guid>
      <description>Microsoft ExcelとはMicrosoft Excelはマイクロソフトが開発している表計算ソフトです． 表計算ソフトとは数値データの集計や分析を行うためのソフトウェアのことを指し， Excel以外にもOpenOfficeやGoogleドキュメントなどが存在しますが， Excelがデファクトスタンダード(事実上の標準)となっています． 一般に，Excelは，マス目状のセル（入力の単位）で構成されたスプレッドシート（単にシートと呼ぶことが多い）に， 数値，文字列，計算式などのデータを入力することで，財務管理や販売管理などに利用されています． 一方で，Excelには，分析ツール（統計処理） や ソルバー（最適化処理） などの機能が備えられており，統計学的な分析も可能です． この授業では，統計分析の基本である「相関係数」や「2項分布」などを，Excelを用いた実習形式で学ぶことを目的とします． マイクロソフトの認定資格であるマイクロソフト・オフィス・スペシャリスト（MOS）の取得も視野に入れて学習していきましょう．
授業の準備今回，分析対象とするデータは，20人の5教科（国語，算数，理科，英語，社会）の得点リストです．
まずは，上記のデータを含むファイル seiseki.csv をダウンロードしましょう． ファイルをダウンロードするには，ファイルのリンクを右クリックをして，「名前を付けてリンク先を保存」を選択します（ブラウザによって異なる）． ここで，ファイルはCSV（Comma Separated Values）という形式で保存されていることに注意してください． CSV形式では，対象となるデータ（ここでは得点）が，「,（カンマ）」で区切って入力されています（メモ帳で開いて確認してみてください）．
ファイルをダウンロードしたら，Excelでseiseki.csvを読み込んでみましょう． Excelを起動し，空白のブック を選択し，ファイルを新規作成します． 次にデータタブに切り替え，テキストまたはCSVから をクリックします． 表示された データの取り込み のダイアログでseiseki.csvを選択し，インポートをクリックします． 最後に，読み込まれるデータを確認したら，読み込みをクリックします．

Excelで下記のように表示されていれば成功です． シートの1行目には項目名である氏名，国語，算数，理科，英語，社会が入力されています． また，2行目以降は，20人の生徒の得点リストが入力されています．

相関係数読み込んだ得点リストのデータを対象に，相関係数 を考えていきましょう． 相関係数とは，2種類のデータの関係の強弱を示す指標です． 例えば，夏の暑い日には，アイスクリームがよく売れますよね． このとき，温度 とアイスクリームの売上 には相関があると言えます． これを定量的に数値で相関の強弱を表したものが 相関係数 です．
まずは，視覚的に相関係数の意味を捉えていきます． 「算数と理科」の組み合わせで散布図を描きます． 算数のC列と理科のD列をマウスで選択し，挿入タブの散布図をクリックします． すると，下図のように，横軸が算数，縦軸が理科である散布図が描けます（タイトル・軸ラベル・軸の境界値を図に合わせて修正してください）．

次に，データ系列で右クリックして，近似曲線の追加をクリックしてください． このとき，近似曲線のオプションで線形近似を選択します．

この結果から，算数と理科には右上がりの相関関係があることが分かります． つまり，「算数が得意な生徒は理科も得意」，逆に，「算数が苦手な生徒は理科も苦手」と考えることができます． このような相関関係を正の相関と呼びます．
今度は，「算数と英語」の組み合わせて散布図を描きます． 算数のC列と英語のE列をマウスで選択し，挿入タブの散布図をクリックします（離れたセルを選択するにはCtrlキーを押します）． すると，下図のように，横軸が算数，縦軸が英語である散布図が描けます（タイトル・軸ラベル・軸の境界値を図に合わせて修正してください）． このとき，同様に近似曲線も追加してください．</description>
    </item>
    
    <item>
      <title>Google VR SDKで視線の検知</title>
      <link>https://mukai-lab.info/pages/tech/unity/google_vr2/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://mukai-lab.info/pages/tech/unity/google_vr2/</guid>
      <description>視線の検知VR環境では、タップなどスマートフォンで一般に用いられる操作が出来ません。 そこで、Google VRでは、 ユーザの視線による操作を可能としたGoogle VR Pointer System が用意されています。 今回は、視線を利用したオブジェクトの選択を実現してみましょう。 事前に準備が必要なプロジェクトの作成やパッケージの導入などは、 Google VR SDKを利用した360°画像ビューアーを参考にしてください。
シーンの作成シーンを新規に作成します。 ここでは、シーンの名前は[MenuScene]とします。 まずは、Google VR SDKを利用した360°画像ビューアーを参考に、 空のオブジェクトであるVR Cameraを作成し、直下にMain CameraとGvrEditorEmulatorを設定します。
次に対象となるQuadオブジェクトをシーンに配置します。 Quadオブジェクトを配置するには、[GameObject]-[3D]-[Quad]を選択します。 Quadオブジェクトのインスペクターを開き、Position の Z座標 を5に設定しましょう。 また、新規にマテリアルを作成し、Quadオブジェクトに追加しておきます（マテリアルに関しては割愛します）。 シーンを再生すると下記のように表示されます。

視線の検知上記で作成したQuadオブジェクトを視線に捉えていることを検出してみましょう。 まずは、ヒエラルキーにGvrEventSystemをドラッグ＆ドロップで配置します。 GvrEventSystemは視線に関するイベントの包括的な処理を行います。 また、ヒエラルキーのMain Cameraの直下に、GvrReticlePointer を配置します。 GvrReticlePointerは、ユーザが見つめている一点をポインタで表します。 対象となるオブジェクトを見続けているとポインタが拡大します。 シーンを再生すると下記のように表示されます。 中央に視点を表すポインタが表示されていることが分かります。 現時点ではQuadオブジェクトを見続けてもポインタに変化はありません。

次に、視線を検出するためのスクリプトをMain Cameraに設定します。 Main CameraのインスペクターでAdd Componentを選び、Physics Raycaster を選択します（Physics Raycasterはスクリプトであることに注意）。

また、対象となるQuadオブジェクトにEvent Triggerを設定します。 QuadオブジェクトのインスペクターでAdd Componentを選び、Event Trigger を選択します（Event Triggerもスクリプト）。
シーンを再生すると下記のように表示されます。 中央にあるポインタがQuadオブジェクトを捉えると、 ポインタが大きな円に変形することが分かります。</description>
    </item>
    
    <item>
      <title>Google VR SDKを利用した360°画像ビューアー</title>
      <link>https://mukai-lab.info/pages/tech/unity/google_vr/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://mukai-lab.info/pages/tech/unity/google_vr/</guid>
      <description>Google VR SDK for Unity近年、VR(Virtual Reality)に関する技術は目覚ましいスピードで発展しています。 Oculus社が開発する「Oculus Rift」、 SCE(Sony Computer Entertainment)の「PlayStation VR」など、 本格的なVRのためのヘッドマウントディスプレイも手に入れることができます。 しかし、これらの製品はまだまだ高価であり、気軽に導入することは難しいです。 このような状況のなか、Googleは、スマートフォンを組み合わせて利用する、 ダンボール製の安価な「Cardboard」というヘッドマウントディスプレイを提供しています。 同時に、Googleは、「Google VR」という、 VRに関するプロジェクトを立ち上げ、開発者向けのツールも提供しています。 そこで、今回は、ゲームエンジンの一つであるUnityで、 Cardboard向けVRを開発可能な「Google VR SDK for Unity」を利用したアプリを制作してみます。 また、VR環境には、リコーが開発する「RICHO THETA S」で撮影した360°画像（全天球画像）を用い、 ヘッドセットの動きに合わせて、360°画像を閲覧できるようにします。 開発に当たり、SlideShareで公開されているOculus Rift勉強会の資料 THETAでモバイルVRコンテンツ開発を参考にさせて頂きました。
準備アプリの開発に当たり下記の機器を利用します。 ヘッドマウントディスプレイにはCardboardではなく、 サンワサプライが販売している「VR SHINECON」を利用します。 ヘッドホンが搭載されており、Cardboardに比べると高級感があるモデルです。
また、360°画像（全天球画像）の撮影にはRICHO THETA Sを採用します。 静止画・動画に対応しており、動画のライブストリーミングも可能なモデルです。
 VR SHINECON RICHO THETA S  下記がRICHO THETA Sで撮影したサンプル画像です。 マウスを使って画像をスクロールすると、教室に一人で寂しそうに立っている向の姿が見えるはずです。 ここでは、ウェブで360°画像を表示するために「VR view on the web」を利用しています。 また、RICHO THETA Sで撮影された画像の解像度は5376x2688ですが、VR viewに最適な4096x2048に変換してあります。
 プロジェクトの作成Unityでプロジェクトを作成します。 Unityのバージョンは5.</description>
    </item>
    
    <item>
      <title>JavaFX①入力フィールドとボタン</title>
      <link>https://mukai-lab.info/pages/classes/applied_programming/chapter9/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://mukai-lab.info/pages/classes/applied_programming/chapter9/</guid>
      <description>プロジェクトの準備 -- プロジェクトの準備Eclipseで新規にプロジェクトを作成しましょう． メニューから[ファイル]-[新規]-[Javaプロジェクト]をクリックして，「新規Javaプロジェクトの作成」を開きます． ここでは，プロジェクト名に”Project9”を入力します． また，JREは&amp;rdquo;プロジェクト固有のJREを使用&amp;ldquo;を選択します． 最後に，[完了]をクリックしましょう． パッケージ・エクスプローラに作成したプロジェクトが表示されていることを確認してください．
 
本日取り上げるのJavaFXは，Eclipseの現バージョン（Mars）では， 「使用すべきではない制限されたAPI」に指定されているため， 事前に，JavaFXの利用を許可する必要があります（将来的には指定から取り除かれると思います）． メニューから[ウィンドウ]-[設定]をクリックして，「設定」のダイアログを開きます． さらに，ダイアログから[Java]-[コンパイラー]-[エラー/警告]を選択します． ここで，「使用すべきではないAPI」，「禁止された参照」，「阻止された参照」の３カ所を無視に設定してください．

JavaFXとは -- JavaFXとは従来，JavaにおけるGUI（Graphical User Interface）は， AWT（Abstract Window Toolkit）やSwingと呼ばれるGUIツールキットを利用するのが標準でした． 一方，JavaFXは2014年にリリースされたJava 8に統合された新しいGUIツールキットです． AWTやSwingに比べ，より洗練されたGUIアプリケーションの制作が可能です． それでは，このJavaFXを利用したGUIプログラミングを学習していきましょう．
ウィンドウの表示 -- ウィンドウの表示JavaFXを利用したGUIアプリケーションを作成するには， javafx.applicationパッケージに含まれるApplicationクラスを継承することから始めます． パッケージとはクラスをグループ分けして管理するためのフォルダのようなものです． パッケージ名も含めたクラス名はjavafx.application.Applicationと表記します．
まずは，Applicationクラスを継承したMyApplicationクラスを作成しましょう． メニューから[ファイル]-[新規]-[クラス]をクリックして，「新規Javaクラス」を開きます． まず，名前に”MyApplication”を入力します． 次にスーパークラスを設定するために，[参照]ボタンから「スーパークラスの選択」を開き， 一致する項目からjavafx.application.Applicationを選択して，[OK]をクリックします． 最後に[完了]をクリックしましょう．


MyApplicationクラスでは，Applicationクラスの抽象メソッドである startメソッドをオーバーライドする必要があります． また，他のパッケージのクラスを利用する場合は，ソースコードの先頭にimportという表記を用いて，import javafx.application.Application;のように記述します（Eclipseが自動的に補完してくれるはず）．
 startメソッドの引数であるStageクラスがウィンドウを表しています． 下記コードを参考にStageクラスのsetTitleメソッド，setWidthメソッド，setHeightメソッドを利用して，タイトルをProject 9，幅を320px，高さを240pxに設定しましょう． また，作成したウィンドウを表示するにはshowメソッドを利用します． プログラムの実行後にウィンドウが表示されることを確認してください．
  
プログラム実行時の注意JavaFXはmainメソッドがなくともプログラムの実行が可能という特徴を持っています． しかし，Eclipseの現バージョンでは未対応のため，下記のコードをMyApplicationクラスに記述する必要があります． プログラム実行の前に，必ず下記のコードをソースコードに挿入してください．</description>
    </item>
    
    <item>
      <title>Javaの開発環境の確認</title>
      <link>https://mukai-lab.info/pages/classes/applied_programming/chapter1/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://mukai-lab.info/pages/classes/applied_programming/chapter1/</guid>
      <description>Javaとは -- JavaとはJavaはサン・マイクロシステムズが1990年に開発したオブジェクト指向のプログラミング言語です． サン・マイクロシステムズは2010年にオラクルに吸収合併されたため， 現在，Javaはオラクルによって開発・提供されており， 無料でjava.comからダウンロードすることが可能です． Javaは下記の特徴を備えており，さまざまな分野で広く利用されています．
 オブジェクト指向であり，大規模なチームでの開発にも向いている ウィンドウズやマッキントッシュなどのプラットフォームに依存しない C，C++の文法を引き継いでおり，標準的で学びやすい  第1の特徴の「オブジェクト指向」という考え方は，Javaの重要なキーワードですが， プログラミング初心者にはちょっと難しい概念かもしれまん． 取り敢えず「もの（オブジェクト）」という考え方を中心にした開発手法と覚えておいてください． オブジェクト指向に関しては第8回で詳しく説明します．
第2の特徴はJVM（Java Virtual Machine）という方法で実現しています． 一般にJavaで開発されたプログラムはバイトコードと呼ばれる独自の形式で配布されています． このバイトコードを実行するためには事前にJVMをウィンドウズやマッキントッシュなどのPCにインストールする必要があります． つまり，どんなプラットフォームでも，JVMさえインストールしておけば，Javaのプログラムは実行可能というわけです．
第3の特徴は，Javaがオブジェクト指向を実現しつつ，C++よりもシンプルであることを目指して設計されたことが理由です． このため，JavaはCプログラマーには馴染みやすく，新人研修など教育向けのプログラミング言語としても広く利用されています．
Javaの開発環境 -- Javaの開発環境Javaのポピュラーな開発環境としてEclipseがあります． EclipseはIBMによって開発され，現在はオープンソースとして開発が継続されています． プログラミング初心者が開発環境を整えるには，日本語化プラグインを導入したパッケージPleiadesを利用するのがお薦めです． Eclipseにはバージョン管理システムのCVS，Gitなども組み込まれているため， チームで効率的にソースコードを管理することも可能です．
Eclipseを起動すると下記のメイン画面が表示されます． Eclipseのメイン画面はビューという区画で区切られています． 様々な機能を備えたビューがありますが，この授業で主に利用するのは「パッケージ・エクスプローラー」「エディタ」「問題・コンソール」の3つです． パッケージ・エクスプローラーは，プロジェクトに含まれるファイルやフォルダを階層的な構造で管理するためのビューです． エディタは，Javaのソースコードを編集・保存するためのビューです． 問題・コンソールは，コンパイル時に発生したエラーを確認したり，プログラムの実行結果を確認するためのビューです．

プロジェクトの作成 -- プロジェクトの作成Eclipseでは「プロジェクト」という単位でプログラムを管理します． プロジェクトを作成するには，メニューから[ファイル]-[新規]-[Javaプロジェクト]をクリックして，「新規Javaプロジェクト」を開きます． ここでは，プロジェクト名に&amp;rdquo;Project1&amp;rdquo;を入力して，[完了]をクリックしましょう． パッケージ・エクスプローラに作成したプロジェクトが表示されていることを確認してください． プロジェクト内に生成された&amp;rdquo;src&amp;rdquo;フォルダに，Javaのソースファイルは保存されます．

ソースファイルの作成 -- ソースファイルの作成作成したプロジェクトにJavaソースファイルを作成します． Javaのプログラムはクラスという単位で構成され，ファイル名は&amp;rdquo;クラス名.java&amp;rdquo;となります． Javaソースファイルを作成するには，メニューから[ファイル]-[新規]-[クラス]をクリックして，「新規Javaクラス」を開きます． ここでは，名前に&amp;rdquo;MyClass&amp;rdquo;を入力し，public static void main(String[] args)(V)にチェックを入れ，[完了]をクリックしましょう． パッケージ・エクスプローラに作成したソースファイルが表示されていることを確認してください．</description>
    </item>
    
    <item>
      <title>MOONBlockでゲームプログラミング</title>
      <link>https://mukai-lab.info/pages/tech/enchant_js/moonblock/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://mukai-lab.info/pages/tech/enchant_js/moonblock/</guid>
      <description>MOONBlockとはMOOBlockは株式会社ユビキタスエンターテインメントが 開発する教育用のプログラミング言語です。 普通のプログラミング言語（C言語など）は複雑な命令や制御を理解する必要がありますが、 MOONBlockではブロックを並べるだけで簡単にプログラミングできるという特徴があります （同様の方法でプログラミングが可能なMITメディアラボ開発のSCRATCHも有名です）。 事前にソフトウェアをインストールする必要もなく、 ウェブブラウザ（IE、Chromeなど）がインストールされていれば動作させることが可能です。 今回はこのMOONBlockを利用して簡単なゲームを制作することを目指しましょう。
MOONBlockの基本MOONBlockはゲームエンジンの一つであるenchant.jsがベースとなっています。 このため、MOONBlockで作成したプログラムを基にPC、Mac、iOS、Androidなど様々なプラットフォームで動作するアプリケーションを開発することが可能です。 enchant.jsはMITライセンスであり、ソースコードの著作権の表示を条件に、 「ソースコードの改変」「再配布」が認められています （詳細はenchant.jsのライセンスを参照）。
また、制作したゲームをゲーム投稿サイトの9leapに投稿することで、 ゲームを体験したユーザから様々なフィードバックを得ることができます（コンテストに応募して賞金を狙うことも）。 下記は研究室の学生が制作し9leapに応募した作品です。 時間があるときに遊んでみてください。
星を集めようはスライムを避けながら星（スター）を３つ集めるゲームです。 
イライラ棒アプリは木、森などの障害物に当たることなく、ゴールを目指すゲームです。 
ひよこマンは、３種類に変身するひよこを操りながら、鍵を集めてゴールに向かうゲームです。 
MOONBlockのゲーム素材画像ゲームを制作する際に必要なアイコン、キャラクター、背景などの素材画像は、 MOONBlockであらかじめ用意されています（非営利目的であれば自由に利用可能）。 アイコンは16&amp;times;16ピクセル、キャラクターは32&amp;times32;ピクセル、 背景は320&amp;times;320ピクセルで構成されています。 これらの素材画像を重ねて表示することでゲーム画面は構成されます。
ここでキャラクターの素材画像（chara1.png）に注目してみましょう。 少しずつ異なるクマの画像が横に並んでいることが分かります。 これらの画像を、パラパラ漫画の要領で、素早く切り替えることでクマが動いているように見せることができます。

Chara1.png

icon0.png

rpg.png
MOONBlockの開発画面下記のリンクをクリックして、MOONBlockのサイトを開きましょう！
http://www.moonblock.jp/
画面上に並んでいる「パペット」「ビヘイビア」などの箱を「キット」と呼びます。 キットにはプログラミングに必要なブロックが使用目的に合わせて別れて入っています。 キットは左右にドラッグすることで全ての種類を確認できます。
画面右上にある青い正方形は実行画面です。 プログラムの実行結果はここで確認できます。 大きさは背景画像と同じ320&amp;times;320ピクセルです。
画面左下にあるボタンをクリックすると、プログラムの保存や、プログラムの実行ができます。 一端保存して自宅でプログラミングの続きをしたり、9leapに作品を投稿するときに利用しましょう。
画面右下にあるゴミ箱には、不要になったブロックを入れます。 一度捨てたブロックは復元できないので注意してください。

くまのバナナ拾いゲームの制作くまが画面内にあるバナナを拾うゲームを作ってみましょう。
まずは、クマのキャラクターを画面に出現させましょう。 「パペット」キットから「パペット」ブロックをドラッグしてワークスペースに配置します。 パペットとは”操り人形”の意味であり、MOONBlockではクマなどのキャラクターやバナナなどのアイテムを指します。 次に、「ビヘイビア」キットから「出現」ブロックを引き出し、「パペット」ブロックに下図のように接続します。 ビヘイビアとは”振る舞い”の意味であり、パペットの動きなどを設定するときに用います。 Runボタンをクリックして実行してみましょう。 このときのブロックの状態はここから確認できます。</description>
    </item>
    
    <item>
      <title>NyARToolkit for Unityで3Dモデルのアニメーション</title>
      <link>https://mukai-lab.info/pages/tech/unity/artoolkit4/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://mukai-lab.info/pages/tech/unity/artoolkit4/</guid>
      <description>
3Dモデルのアニメーション前回に引き続き、Unityのオリジナルキャラクターである「ユニティちゃん」を利用して、 3Dモデルにアニメーションを設定してみましょう（詳細はNyARToolkit for 3Dモデルの表示を参照）。
Unityで3Dモデルにアニメーションを設定するときは、Animator ControllerというAssetを利用します。 「ユニティちゃん」のパッケージには、UnityChanLocomotions、UnityChanActionCheck、UnityChanARPoseの ３種類のAnimator Controller **が含まれています。
今回は、UnityChanLocomotionsを「ユニティちゃん」に設定して、キーボードの入力に対応してアニメーションするように改良します。
Animation Controller[UnityChan]-[Animators]にAnimation ControllerのUnityChanLocomotionsがあります。 これをドラッグし、unitychanのInspectorにあるControllerに設定します。 これで、「ユニティちゃん」はUnityChanLocomotionsで定義されたアニメーションを行うことが可能となります。

ここで、UnityChanLocomotionsの内容を確認してみましょう。 Animation Controllerは下図のようにグラフで定義されます。 まずは、Entryから始まり、Idle状態に遷移することが分かります。

Idle状態のInspectorを確認すると、 MotionにWAIT00が設定されていることが分かります。 このWAIT00が3Dモデルの動きに対応します。 また、Idle状態から、Locomotion状態、WalkBack状態、Rest状態の ３つの状態に遷移可能なことが分かります。

では、Idle状態から他の状態に遷移するための条件は何でしょうか。 TransitionsのIdle -&amp;gt; Restをクリックすると、状態遷移のための条件（Conditions）が表示されます。 ここでは、Restという変数（パラメータ）がtrueであるときにRest状態に遷移することが分かります。 同様に、Locomotions状態に遷移する条件は、Speedが0.1より大きいとき、 また、WalkBack状態に遷移する条件は、Speedが-0.1より小さいときということが分かります。 このように変数（パラメータ）に基づき、3Dモデルの状態が確定します。

スクリプトによる状態遷移の制御次に、C#スクリプトを作成し、キーボードからの入力に応じて状態遷移を制御してみます。 まずは、[Create]-[C# Script]をクリックして、新規にC#のスクリプトを作成します。 ファイル名はARAnimationsとしておきます。
まずは、キーボードの1を押すとRest状態に遷移するようにしてみます。 キーの入力判定はInput.GetKey()メソッドを利用します。 引数にはstring型で対象となるキーを指定します。 また、状態遷移のトリガーとなる変数Restの値を設定するには、 SetBool()メソッドを利用します。 引数には、String型で対象となる変数と、その値を指定します。 再生ボタンをクリックして、「ユニティちゃん」を表示した状態で、キーボードの1を押してみましょう。 ユニティちゃんが背伸びをするアニメーションが表示されるはずです。
 次に、キーボードの2を押すとLocomotions状態、3を押すとWalkBack状態、 4を押すとIdle状態に遷移するようにしてみます。 トリガーとなる変数Speedはfloat型のため、SetFloat()メソッドを利用して値を変更しています。 再生ボタンをクリックして、「ユニティちゃん」を表示した状態で、キーボードの2、3、4を押してみましょう。 ユニティちゃんが走ったり、後ずさりするアニメーションが表示されるはずです。 


これまでに紹介した機能を利用して、拡張現実を利用した作品を制作してみてください。
参考書籍</description>
    </item>
    
    <item>
      <title>NyARToolkit for Unityで3Dモデルを表示</title>
      <link>https://mukai-lab.info/pages/tech/unity/artoolkit3/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://mukai-lab.info/pages/tech/unity/artoolkit3/</guid>
      <description>
3Dモデルの準備NyARToolkitのパッケージに含まれる サンプルSimpleLiteはマーカーを検出すると赤色の立方体（Cube）を表示するプログラムです。 このSimpleLiteを修正し、3Dモデルを立体的に表示できるよう改良します。
SimpleLiteフォルダをコピーし、フォルダに含まれるC#スクリプトをARPictureCamera、 シーンをARPictureSceneにファイル名を変更した状態を前提とします （詳細はNyARToolkit for Unityの導入を参照）。
Unityでは.3ds、.objなどの一般的な3Dモデルのファイル形式を利用できますが、 今回はUnityのオリジナルキャラクターである「ユニティちゃん」を利用してみます。 「ユニティちゃん」はUnityのアセット（素材）として配布されているので導入はとても簡単です。 また、このキャラクターは、ラインセンスロゴもしくはライセンス表記があれば、キャラクターの二次創作物の制作が認められています （詳細は「ユニティちゃんライセンス条項」を参照）。

まずは、「ユニティちゃん」の公式ページから、ライセンスに同意し、データをダウンロードします。 データをダウンロードしたら、ツールバーから[Assets]-[Import package]-[Custom package]をクリックして、 ダウンロードしたパッケージを選択します。 ファイルの読込み後に、ダイアログが表示されたら、全てのファイルにチェックを入れた状態でimportをクリックしましょう。 ファイルの取り込みが終わると、プロジェクトのAssetsに新しくUnityChanフォルダが展開されます。

3Dモデルの表示[UnityChan]-[Models]に「ユニティちゃん」の3Dモデルであるunitychanがあります。 これを、ドラッグし、HierarchyにあるMarkerObjectの直下に配置します。 すると下記のようにx=0、y=0、ｚ=0の位置に「ユニティちゃん」が配置されます。

次に、「ユニティちゃん」のサイズ（Scale）や座標（Position）を調整します。 ここでは、Inspectorから、サイズの値をX=80、Y=80、Z=80、位置をX=0、Y=-40、Z=-20に修正しましょう。

再生ボタンをクリックすると、「ユニティちゃん」が表示されることを確認してください。 説明文なしに下記の画像だけだと完全に変な人かもしれません。

次回はAnimator Controllerを利用して「ユニティちゃん」に歩くなどの動きを付けることに挑戦します。
参考書籍</description>
    </item>
    
    <item>
      <title>NyARToolkit for UnityでNFTを利用したマーカーの認識</title>
      <link>https://mukai-lab.info/pages/tech/unity/artoolkit5/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://mukai-lab.info/pages/tech/unity/artoolkit5/</guid>
      <description>画像の準備NyARToolkitのパッケージに含まれるサンプルSimpleNftは NFT(Natural Feature Tracking)を利用したマーカー認識のサンプルです。 NFTとは自然特徴点を利用した物体認識のことで、この技術を利用することで、一般的な画像をマーカーとして扱うことができます （詳しくはThe Sixwish Projectを参照）。 ここでは、下記の下記の「犬の画像（001.png）」と 「うさぎの画像（002.png）」を マーカーとして利用することに挑戦します。 画像サイズは300x300ピクセル、画像フォーマットは透過背景のPNGです。 また、犬の画像を認識すると赤色の立方体、うさぎの画像を認識すると青色の立方体を表示させることにします。


SimpleNftフォルダをコピーし、フォルダに含まれるC#スクリプトをARPictureCamera、 シーンをARPictureSceneにファイル名を変更した状態を前提とします（詳細はNYARToolkit for Unityの導入を参照）。
パターンファイルの作成上記の２種類の画像から、マーカーのパターンファイルを作成します。 パターンファイルの作成には、NyARToolkitのパッケージに含まれるNftFileGeneratorを利用します （詳しくはNyARToolkit Projectを参照）。 [Data]-[Tools]にあるNftFileGeneratorをダブルクリックするとプログラムが起動します。 importをクリックし、特徴点を抽出したいJPGやPNGなどの画像を指定します（透過より背景白の方が認識精度が高いようです）。 次に、Make Feature Setをクリックし、特徴点を抽出します。 このとき、Source DPIやIset DPIsなどのパラメータは特に変更する必要はないようですが、 特徴点数が多すぎたり、少なすぎる場合にはFSET parameterを調節すると良いようです。

抽出されたパターンは赤い四角や青い円で表示されます。 パターンを保存するにはExportをクリックし、適当なファイル名で保存します。 ここでは、「犬の画像」のパターンファイルをpatt_001.bytes、 「うさぎの画像」のパターンファイルをpatt_002.bytesというファイル名で保存します。 これらのパターンファイルは、AssetsのResourcesフォルダにコピーしておきます。


マーカーオブジェクトの作成SimpleNftはマーカーを認識すると赤色の立方体を表示します。 ここでは、２種類のマーカーに応じて、赤色の立方体に加え、青色の立方体を作成しておきます。
まずは、シーンのARPictureSceneをダブルクリックし、HierarchyにあるMarkerObjectを複製します。 スクリプトからこれのオブジェクトを操作するため、２つのマーカーオブジェクトには共通のタグ（Tag）を設定します （Gameobject.FindGameObjectsWithTag(String tag)メソッドでタグからオブジェクトを取得することが可能）。 タグ名は自由に設定することができますが、ここではMarkerObjectとしておきます。

次に、Assetsで赤色と青色のマテリアルを作成します。 [Create]-[Materials]をクリックしてマテリアルを作成し、Albedoに赤色と青色を設定します。 ここでは、マテリアルの名前をRedとBlueにしておきます。 これらのマテリアルはMarkerObjectの直下にあるCubeのMaterialsに設定しておきます。

マーカーが認識されたときに表示されるのは、上記のCubeオブジェクトです。 Cubeのサイズ（Scale）や位置（Position）はマーカーの大きさに合わせて調整する必要がありますが、 ここでは、サイズの値をX=80、Y=80、Z=80、位置をX=-80、Y=80、Z=40に修正しておきます。

スクリプトの修正最後にC#スクリプトのARPictureCameraを修正します。</description>
    </item>
    
    <item>
      <title>NyARToolkit for Unityで画像を表示</title>
      <link>https://mukai-lab.info/pages/tech/unity/artoolkit2/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://mukai-lab.info/pages/tech/unity/artoolkit2/</guid>
      <description>
画像の準備NyARToolkitのパッケージに含まれる サンプルSimpleLiteはマーカーを検出すると赤色の立方体（Cube）を表示するプログラムです。 このSimpleLiteを修正し、一般的なJPGやPNGなどの画像を立体的に表示できるよう改良します。
SimpleLiteフォルダをコピーし、フォルダに含まれるC#スクリプトをARPictureCamera、 シーンをARPictureSceneにファイル名を変更した状態を前提とします （詳細はNyARToolkit for Unityの導入を参照）。
立方体の代わりに表示する犬の画像（001.png）は下記です。 この画像は、テンプレートBANKを参考に、本学の学生が作成しました。 画像サイズは300x300ピクセル、画像フォーマットは透過背景のPNGです。

まずは、新規にanimalsフォルダを作成し、上記の画像をコピーしておきます。 対象のフォルダには、C#スクリプトのARPictureCamera、シーンのARPictureScene、 画像フォルダのanimalsが含まれる状態になっていることを確認してください。

テクスチャの利用立方体（Cube）に犬の画像（001.png）をテクスチャとして貼り付けることで、 マーカーを検出すると犬の画像を立体的（マーカーから少し浮いた状態）に表示してみます。
まずは、Assetsフォルダで[Create]-[Materials]を選択し、新規にマテリアルを作成します。 マテリアルの名前はDogに変更しておきます。 画像フォーマットが透過背景であることから、InspectorでShaderをUnit/Transparentに設定します。 Unit/Transparentはテクスチャ画像のアルファ値を反映して透過にすることが可能なシェーダーです。 次に、Textureを犬の画像に変更します これで、オブジェクトに設定するマテリアルが準備できました。


次に、シーンのARPictureSceneをダブルクリックします。 ここで、Hierarchyから[Create]-[3D Object]-[Cube]を選択し、新規に立方体（Cube）のオブジェクトを作成します。 オブジェクトの名前はDogObjectに変更しておきます。 このDogObjectをドラッグして、MarkerObjectの直下に配置します。 このとき、デフォルトで設定されている、Cubeオブジェクトは削除しておきます。
DogObjectのInspectorから、オブジェクトの位置（Position）やサイズ（Scale）を修正します。 位置はX=0、Y=0、Z=20とし、サイズはX=80、Y=80、Z=0とします（Z=0とすることで幅がなくなり平面となります）。

最後に、DogObjectのMaterialsをクリックして、作成したDogを選択しておきます。 再生ボタンをクリックすると、犬の画像（001.png）が表示されることを確認してください。 テクスチャ画像が上下反対に張り付けられる場合は、 TilingのYの値を-1に変更します（Direct3DかOpenGLで振る舞いが異なるようです）。


次回は画像の代わりに3Dオブジェクトを表示することにに挑戦してみます。
参考書籍</description>
    </item>
    
    <item>
      <title>NyARToolkit for Unityの導入</title>
      <link>https://mukai-lab.info/pages/tech/unity/artoolkit/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://mukai-lab.info/pages/tech/unity/artoolkit/</guid>
      <description>NYARtoolkitとはARToolkitをベースに開発された拡張現実ライブラリがNyARToolkitです． ゲーム開発環境であるUnityで利用可能なNyARToolkit for Unityの導入方法を紹介します． ここでは，Unityのバージョンは5.3.5，NyARToolkit for Unity のバージョンは5.0.8を対象とします． また，NyARToolkitのライセンスはLGPLv3**となっています（商用ライセンスもあるようです）． このライセンスは，「著作権の表示」を条件に，商用利用や配布が認められています（詳細はWikipediaを参照）．
プロジェクトの作成Unityで新しいプロジェクトを作成します． ここでは，プロジェクト名を「ARPictureBook」としています． また，ゲーム環境は「3D」を選択しておきます．

次に，「NyARToolkit for Unity」のパッケージをインストールします． パッケージは下記URLからダウンロードできます．
https://github.com/nyatla/NyARToolkitUnity/releases
ツールバーから[Assets]-[Import package]-[Custom package]をクリックして， ダウンロードしたパッケージを選択します． ファイルの読込み後に，ダイアログが表示されたら， 全てのファイルにチェックを入れた状態でimportをクリックしましょう．

ファイルの取り込みが終わると，プロジェクトのAssetsには6つのフォルダが展開されます． Assetとは，ゲームを構成する最小の構成単位のことです． 例えば，シーン，キャラクター，画像ファイル，音楽ファイルなどもAssetです． ここでは，sampleフォルダに含まれるSimpleLiteを試しに実行してみましょう．

SimpleLiteを実行する前に下記の準備が必要です． ウェブカメラは標準的なモノであれば問題ないと思われます． また，マーカーはパッケージに付属しているMarkerHiro.pngを利用しますが， NyARToolkit用のマーカーは，tarotaroorg氏が公開している オンラインのツールを利用して，自由に作成することも可能です．
 ウェブカメラ（CMS-V30SETBKを使用） マーカーが印刷された紙（resourceフォルダに含まれるMarkerHiro.pngを印刷します）  
準備が整ったら，画面上部にある再生ボタンをクリックします． すると，ゲーム画面にカメラ映像が映し出されます． このカメラにマーカーを印刷した紙を映すと，マーカー上に赤色の立方体（Cube）表示されることを確認してください． これが，拡張現実と呼ばれる技術です．


フォルダのコピーAssetsフォルダに新規フォルダを作成し，SimpleLiteのフォルダに含まれる２つのファイルをコピーします（ARCameraBehaviorはC#のスクリプト，simpleLiteはシーンと呼ばれるファイルです）． ここでは，C#スクリプトをARPictureCamera，シーンをARPictureSceneにファイル名を変更しておきます． 次に，ARPictureSceneをダブルクリックし，HierarchyのCameraをクリックします． シーンに関連付けられたコンポーネントが表示されているので， ARCameraBehaviorを削除（Remove Component）します． さらに，Add Componentをクリックし，コピーしたARPictureCameraを選択しておきます． これで，ARPictureCameraに記述したスクリプトが，ARPictureSceneに関連付けられます．


しかし，このままではARPictureCameraがエラーとなり実行できません． これは，変更したファイル名とスクリプトのクラス名が一致しないことが原因です． そこで，ARPictureCameraのソースコードを表示し， クラス宣言部にあるクラス名を，ARCameraBehaviorからARPictureCameraに修正し，エラーを取り除きましょう． 最後に，再生ボタンをクリックして，SimpleLiteと同様の実行結果になることを確認してください．</description>
    </item>
    
    <item>
      <title>Onsen UI(1) コンポーネント</title>
      <link>https://mukai-lab.info/pages/classes/graduation_preperation_1/chapter1/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://mukai-lab.info/pages/classes/graduation_preperation_1/chapter1/</guid>
      <description>HTML5とはHTML5とは --
HTML5とは，HTML(Hyper Text Markup Language)のバージョン5のことを指し， W3C(World Wide Web Consortium)と呼ばれる非営利団体が2014年10月28日に勧告した技術のことです． HTML5では，文書構造を表すタグが追加されており，例えば，ヘッダを表すheaderタグ，フッタを表すfooterなどが利用できます． また，動画や音声などのマルチメディアファイルも，Flashなどのプラグインを必要とせず， videoタグや，audioタグを利用してページに埋め込むことが可能になりました． その他，ブラウザにデータの保存が可能なWeb Storage， サーバー・クライアント間の双方向通信が可能なWeb SocketなどもHTML5の一部として認識されています．
HTML5ハイブリッドアプリとは -- HTML5ハイブリッドアプリとはスマートフォンに搭載されているiOSやAndroidは， ウェブブラウザのようにウェブページを取得・表示するための，Web Viewという機能が利用できます． この，Web Viewを利用して，HTML，CSS，JavaScriptなどの技術で， ネイティブ・アプリと同等の機能を提供する方法がHTML5ハイブリッドアプリです． 一般に，ネイティブ・アプリを開発するには，iOSであればObjective-CやSwift， AndroidであればJavaで実装する必要があり，学生が気軽に開発を初めることは困難です． 一方，HTML5ハイブリッドアプリであれば，ウェブページを制作するための技術が中心であり， HTMLの基本を学んでいれば取り組むことが可能です． 本授業では，HTML5ハイブリッドアプリのプラットフォームであるMonacaを利用して， 様々なアプリを開発するためのプログラミング技術を身に着けます．
Monaca -- MonacaMonacaはアシアル株式会社が提供する HTML5ハイブリッドアプリ専用の開発プラットフォームです． Chromeで動作するクラウドサービスとして提供されているため， ウェブに接続出来る環境であれば，どこでも開発が可能という特徴があります （Monaca Localkitを利用すればローカルの環境でも開発可能）． Apacheが提供しているハイブリッドアプリのフレームワークである Cordovaを採用しているため，ネイティブ・アプリと同様に， スマートフォンのカメラやセンサーの機能を利用することも可能です．
また，開発中のアプリをスマートフォンで動作テストすることが可能な Monacaデバッガーというアプリを利用することが可能です． iOS版，Android版がともにリリースされており，アプリ・マーケットから取得が可能です． ブラウザのプレビューでは動作するけど，スマートフォンでは動作しないという現象が， まれに発生するので，こまめにMonacaデバッガーで動作確認すると良いでしょう． 加えて，Monacaデバッガーにはチャットやスクリーンショットなどのコミュニケーション機能が搭載されており， チームでのアプリ開発もサポートしてくれます（有料のようですが）． ブラウザでMonacaを開く前に，Monacaデバッガーを自身のスマートフォンにインストールしておきましょう．
プロジェクトの作成 -- プロジェクトの作成Monacaを開き，ログインしてみましょう． このとき，ブラウザはChromeを利用することに注意してください （IEなど他のブラウザでの動作は保証されていないようです）． ログインすると下図のようにプロジェクトを管理するためのダッシュボードが表示されます． プロジェクトはプロジェクト名，プロジェクトの説明に加え，タグを付けて管理することができます．</description>
    </item>
    
    <item>
      <title>Onsen UI(2) テキスト入力</title>
      <link>https://mukai-lab.info/pages/classes/graduation_preperation_1/chapter2/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://mukai-lab.info/pages/classes/graduation_preperation_1/chapter2/</guid>
      <description>Onsen UIとは -- Onsen UIとはOnsen UIはアシアル株式会社が提供するSPA(Single Page App)のためのフレームワークです． このOnsenという名称は，英単語Spaの日本語訳が温泉であることから名付けられたようです． 旧バージョンの1.0は，GoogleのフレームワークであるAngularJSに依存していましたが， 最新バージョンの2.0では依存を切り離すことで，AngularJSだけでなく， ReactやVue.jsなどのフレームワークでも開発が可能になりました． 本授業では，最新のバージョン2.0を採用しますが， 特定のフレームワークは用いず，標準的なJavaScriptで実装することを基本とします．
プロジェクトの作成 -- プロジェクトの作成今回は，テキスト入力の機能を利用して，クイズアプリを作成してみましょう． ダッシュボードから【新規プロジェクトの作成】-【Onsen UI】-【Onsen UI V2 JS Navigation】を選択します． プロジェクト名をクイズアプリ，説明をテキスト入力を利用したクイズアプリとします． プロジェクトを作成したらMonacaクラウドIDEの画面を開きましょう．

テキスト入力 -- テキスト入力最初にindex.htmlのpage1.htmlを下記のように修正していきましょう （基本構造は「Onsen UI(1) コンポーネント」を参照）．
 テキスト入力にはons-inputタグを利用します． ここでは，id属性にanswer，modifier属性にunderbarを設定しています． modifier属性は，コンポーネントの外見を設定するために用いられます． ons-inputタグであれば，マテリアルデザインのmaterialと， 下線が表示されるunderbarの２種類が設定可能です．
このテキスト入力にクイズの答えを入力し，回答ボタンをクリックすると， 入力された答えが正しいかを判定し，それぞれ正解，または，不正解ページに遷移することにします． ここで，正解のページはpage2.html，不正解のページはpage3.htmlとします．
-- 
次に，ons-templateタグと，ons-pageタグを利用して， 正解と不正解のページを下記のように作成します． page2.htmlは入力された回答が正解のときに表示されるページです． ツールバーに正解，中央にpタグで「向先生は射手座です！」と表示します． また，page3.htmlは入力された回答が不正解のときに表示されるページです． ツールバーに不正解，中央にpタグで「向先生は違う星座だよ！」と表示します．
 -- 
-- 
最後にscript要素のJavaScriptのコードを下記のように修正します． フォームに入力されたテキストはgetElementById()関数でID属性を参照して取得します．
var answer = document.getElementById(&amp;#34;answer&amp;#34;); 次に，if文を利用して，入力されたテキストが射手座と一致するときに， page2.</description>
    </item>
    
    <item>
      <title>Onsen UI(3) テーマローラー</title>
      <link>https://mukai-lab.info/pages/classes/graduation_preperation_1/chapter3/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://mukai-lab.info/pages/classes/graduation_preperation_1/chapter3/</guid>
      <description>Onsenテーマローラーとは -- テーマローラーとはOnsen UIでは Onsenテーマローラー というテーマ機能を利用できます． CSSファイルを直接編集しなくても，Onsenテーマーローラーで，各コンポーネントのデザインを変更することが可能です． また，Onsen UIを利用したデザインパターン（プロフィールやコンタクトリストなど）も用意されており， デザインパターンのソースコードを参考にしながら，オリジナルのデザインが可能です． アプリのデザインは個人のセンスが問われる要素です． 一からデザインを組み立てるよりも既存のデザインを流用する方が簡単かつ美しくなることが多いです．
プロジェクトの作成 -- プロジェクトの作成今回は，Onsenテーマローラを利用しながら，お店紹介アプリを作成してみましょう． ダッシュボードから【新規プロジェクトの作成】-【Onsen UI】-【Onsen UI V2 JS Minimum】を選択します． プロジェクト名を お店紹介アプリ ，説明を Onsenテーマローラーを利用したお店紹介アプリ とします． プロジェクトを作成したら MonacaクラウドIDE の画面を開きましょう．

デザインパターンの利用 -- デザインパターンの利用今回は， Onsenテーマローラー にリストアップされているパターンの中から， 「Shop Details」を利用します． まずは， Show Source をクリックして，ソースコードを表示します． 表示されたダイアログの左には HTML ファイルのソースコード， 右には CSS ファイルのソースコードが表示されます． そこで，この HTML ファイルのソースコードの body 要素をコピーして， お店紹介アプリ の index.html の body 要素を上書きします．

すると，プレビュー表示は下記のようになります． 次に， CSS ファイルのソースコードを全てコピーして， お店紹介アプリ の css/style.</description>
    </item>
    
    <item>
      <title>Onsen UI(4) ジェスチャー操作</title>
      <link>https://mukai-lab.info/pages/classes/graduation_preperation_1/chapter4/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://mukai-lab.info/pages/classes/graduation_preperation_1/chapter4/</guid>
      <description>ジェスチャー操作とは -- ジェスチャー操作とはスマートフォンなどの画面に対して，指やタッチペンなどで行う動作が ジェスチャー操作 です． 例えば，画面を１回叩く操作を タップ（Tap） ，画面を平行に動かす操作を スワイプ（Swipe） と呼びます． Onsen UIでは ons-gesture-detector 要素を利用することで，ジェスチャー操作を検出することができます． また，Onsen UIにおけるジェスチャー操作の検出は，HAMMER.JSのカスタマイズ版をベースにしているとのことです．
プロジェクトの作成 -- プロジェクトの作成今回は，ジェスチャー操作を利用した簡単なゲームを作成してみましょう． 特定のジェスチャー操作をすることで，ブロック要素（div要素）を消去するゲームです． ダッシュボードから【新規プロジェクトの作成】-【Onsen UI】-【Onsen UI V2 JS Minimum】を選択します． プロジェクト名を ジェスチャー・ゲーム ，説明を ジェスチャー操作を利用したゲームアプリ とします． プロジェクトを作成したら MonacaクラウドIDE の画面を開きましょう．

ブロック要素とイベントの検出 -- ブロック要素とイベントの検出ここでは，下記表の３つのジェスチャー操作を検出することとします．
   ジェスチャー イベント名 説明     タップ tap 画面を１回叩く   ホールド hold 画面を長く押す   スワイプ swipe 画面に平行に動かす    まずは，イベントを処理するためにjQueryを導入します． ツールバーから [設定]-[JS/CSSコンポーネントの追加と削除] をクリックします． 次に，コンポーネントの一覧から jQuery(Monaca Version) を選択し 追加 をクリックします． これで，対象のプロジェクトで jQuery が利用可能になります．</description>
    </item>
    
    <item>
      <title>OpenCVを利用した視線位置の描画</title>
      <link>https://mukai-lab.info/pages/tech/eyetracker/eyetracker2/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://mukai-lab.info/pages/tech/eyetracker/eyetracker2/</guid>
      <description>OpenCVとは前回はTobii Eye Tracker 4Cを利用して、 ディスプレイに対する視線の位置を検出しました。 今回は画像処理ライブラリのOpenCVを利用して、 視線位置に合わせてウィンドウに図形を描画することに挑戦します。 OpenCVは、インテル が開発したオープンソースのライブラリであり、 画像処理に関する様々なアルゴリズムを容易に実装することができます（2016年にインテルがItseezを買収）。 また、C/C++、Java、Python、MATLAB のライブラリとして配布されており、 プログラミング言語を問わず利用できることも魅力です。
図形描画の実装前回までにライブラリの導入は完了しているので、今回はウィンドウを表示するところからスタートしましょう。 ファイル名は MyEyeTrack2.py とします。 まずは、OpenCV(cv2) と NumPy のモジュールをインポートします。 ここで、NumPy には、np という別名を付けていることに注意してください。
 最初に、np.zeros メソッドを用いて、幅1980px、高さ1080pxの黒色の画像を生成します。 このメソッドは値が0の配列を返値とし、引数には配列の長さを表す タプル と データタイプを渡します。 ここでは、8ビットの符号なし整数（0~255）であるnp.unit8をデータタイプとしています。 この画像を imshow メソッドで表示します。 第1引数の &amp;ldquo;MyEyeTrack&amp;rdquo; はウィンドウのタイトルバーに表示される文字列です。
 前回実装したコールバックメソッドを修正し、視線位置に白色の円を描画するように改良します。 左右の視線位置の平均値を円の中心座標とします。 コールバックメソッドで取得される視線位置は、 標準化された値のためウィンドウのサイズを掛けて、ピクセル座標に変換しています。 このとき、y座標はウィンドウのタイトルバーの幅を考慮して、50 だけ減らしています （本当はキャリブレーションをやらなきゃいけないけど）。 円を描くには、cv2.circle メソッドを利用します。 引数には、画像、中心座標、半径、色、枠線の太さ を指定します。 ここで、枠線の太さに負の値を指定すると、塗りつぶしの円になります。 また、global はグローバル変数の img を用いることの宣言です。
 上記で実装したコールバックメソッドをEyeTrackerオブジェクトに登録します。
 最後にwhile文でimshowメソッドを呼び出し、画像の再描画を繰り返します。 ここでは、100ms毎に画像を描画しています。 このとき、ESCキー が押されると、ループを終了し、 コールバックメソッドの解除、ウィンドウの破棄、システムの終了を行います。</description>
    </item>
    
    <item>
      <title>OpenCVを利用した顔検出</title>
      <link>https://mukai-lab.info/pages/classes/programming_1/chapter11/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://mukai-lab.info/pages/classes/programming_1/chapter11/</guid>
      <description>スケッチの作成Processingを起動して、新規にスケッチを保存しましょう。 メニューから[ファイル]-[名前を付けて保存]をクリックして、「スケッチフォルダを名前を付けて保存」を開きます。 ファイル名に「Project11」を入力し、[保存]をクリックしましょう。 保存先に「Project11」という名前のフォルダが作成されていることを確認してください。

OpenCVの導入インテルが開発したオープンソースのライブラリであるOpenCVを導入することで、 画像処理・画像解析など様々な機能を利用することが可能となります。 ここでは、Processing用のOpenCVを導入して、顔検出を試みてみましょう。 まずは、メニューから[スケッチ]-[ライブラリをインポート]-[ライブラリを追加]をクリックして、 「Contribution Manager」を開きます。 ここで、opencvをキーワードに検索すると、 「OpenCV for Processing | Computer vision with OpenCV.」が表示されるので、 このライブラリを選択してインストールしましょう。

次に、[スケッチ]-[ライブラリをインポート]-[OpenCV for Processing]をクリックして、OpenCVライブラリをインポートします。 また、同様にVideoライブラリをインポートしてください。 ソースコードの先頭に「import gab.opencv.&amp;lowast;;」と「import processing.video.&amp;lowast;;」が 表示されていることを確認してください。
 カメラ映像の表示Captureクラスを利用して、カメラから入力した画像を表示しましょう。 下記を参考にコードを入力したら、Runボタンをクリックしてください。 ここでは、サイズ（size）が320x240、フレームレート（fps）が30となっている、 3番のカメラを使用していることに注意してください。 ウィンドウにカメラ映像が表示されることを確認してください。
 
顔位置の検出顔位置の検出にはOpenCVクラスを利用して下記のように記述します。 ここで、OpenCV.CASCADE_FRONTALFACEは顔を検出することを意味しており、 この他にOpenCV.CASCADE_PEDESTRIANSは歩行者、OpenCV.CASCADE_EYEは目を検出することが可能です （詳細はOpenCVのドキュメントを参照してください）。 検出された顔位置はRectangleクラスとして返されます。 Rectangleクラスは矩形を表しており、*x*、*y*で左上の座標、*width*、*heigth*で幅と高さを取得できます。
opencv = new OpenCV(this, cam); opencv.loadCascade(OpenCV.CASCADE_FRONTALFACE); faces = opencv.detect(); それでは、検出された顔位置にrect()関数で矩形を描いてみましょう。 下記を参考にコードを入力したら、Runボタンをクリックしてください。 ここでは、矩形の輪郭線を赤色、また、塗りつぶしを描画しないように設定しています。 検出された顔位置に赤い矩形が表示されることを確認してください。</description>
    </item>
    
    <item>
      <title>Processingではじめての画像処理</title>
      <link>https://mukai-lab.info/pages/tech/processing/processing/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://mukai-lab.info/pages/tech/processing/processing/</guid>
      <description>ProcessingとはProcessingは、2001年からMIT Media Labでスタートしたオープンソースのプロジェクトです。 当初からプログラミング教育を意識して開発され、初学者でも視覚的なコンテンツ（ビジュアルコンテンツ）を容易に作成できることが大きな特徴です。 デザイナーや建築家などの利用も多く、作品はニューヨーク近代美術館など多くの著名な美術館で公開されています。 オープンソースであることにもこだわりが強く、活発なコミュニティが形成されており、ソフトウェアを拡張するためのライブラリやツールが多く提供されています。 ウィンドウズ、マッキントッシュ、リナックスなどのプラットフォームで動作可能であり、公式サイトから無料でダウンロードすることができます。 また、ProcessingはJavaをベースに開発されており、Javaによく似た文法でコードを記述できることも人気の高い理由です。
Processingの開発環境前節で述べたように様々なプラットフォームで動作可能なパッケージが配布されていますが、 今回はオンラインでコーディングが可能なOpenProcessingを利用してみましょう。 このサイトでは、Processingで制作した作品（スケッチ）を公開することができます。 また、登録も無料で誰でも利用することが可能です。 では、下記のリンクをクリックしてOpenProcessingのサイトを開きましょう。
OpenProcessing
残念ながら現在は英語のサイトしか存在せず、ユーザ同士の交流は英語が中心です。 一方で、日本語でコメントを記述することは問題ないようです。 Processingに慣れてきたらオリジナルの作品を投稿することを目指しましょう。

まずは、公開されているスケッチを閲覧してみましょう。 「Activity」のタブをクリックすると、右下に評価の高い作品の一覧が表示されます。 これらのスケッチはOpenProcessingの登録者が制作した作品です。 自由にスケッチを選んでプログラムを実行してみましょう。 下記のは2017日6月9日現在のスケッチのリストです。

幾つか人気のある作品を取り上げてみましょう。 まずは、aadebdeb氏のrainbow spinという作品です。 マウスの動きに合わせて、描かれている虹色の渦巻きの回転方向や倍率が変化します。
 次は、Victor Galve氏のPractica 2という作品です。 マウスでクリックすると、様々な色や形の花火が打ちあがります。
 最後は、Raven Kwok氏のNoise Turbulence Doodlesという作品です。 マウスをドラッグすると円が重なりながら奇妙な形に成長します。
 スケッチの作成新しいスケッチを作成してみましょう。 サイトのトップから「+Create a Sketch」をクリックしてください。 下記のようにソースコードを入力する画面になります（デフォルトで記述されているコードは削除しておきましょう）。 ソースコードを記述した後で、をクリックすると、記述されたコードを実行することができます。

Processingをウェブ上で実行するには「P5js」、または、「Processing.js」というライブラリを利用します。 今回は後者の Processing.js を利用するため、画面右の Settings で、 Mode を Processing.js に変更してください。

図形を描く前に、スケッチの大きさや背景色を設定しましょう。 スケッチの大きさは300x300ピクセル、背景色は白にします。 大きさを設定するにはsize(幅,高さ)、背景色を設定するにはbackground(色)と記述します（255は白色を意味します）。 下記のソースコードを入力したら、をクリックしましょう。 背景色が白色のスケッチが表示されます（300x300ピクセルのスケッチが中央に配置されています）。 （「//」が先頭にある文章はコメントと呼ばれ、プログラムとは認識されません） もとのソースコードの入力画面に戻るにはをクリックします。</description>
    </item>
    
    <item>
      <title>Processingの開発環境の確認</title>
      <link>https://mukai-lab.info/pages/classes/programming_1/chapter1/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://mukai-lab.info/pages/classes/programming_1/chapter1/</guid>
      <description>ProcessingとはProcessingは、大学院生だったBenjamin FryとCasey Reasが2001年にMIT Media Labでスタートしたオープンソースのプロジェクトです。 当初からプログラミング教育を意識して開発され、初学者でも視覚的なコンテンツ（ビジュアルコンテンツ）を容易に作成できることが大きな特徴です。 一方で、デザイナーや建築家などの利用も多く、作品はニューヨーク近代美術館など多くの著名な美術館で公開されています。 オープンソースであることにもこだわりが強く、活発なコミュニティが形成されており、ソフトウェアを拡張するためのライブラリやツールが多く提供されています。 ウィンドウズ、マッキントッシュ、リナックスなどのプラットフォームで動作可能であり、公式サイトから無料でダウンロードすることができます。 また、ProcessingはJavaをベースに開発されており、Javaによく似た文法でコードを記述できることも人気の高い理由です（Javaは3年前期に開講する「プログラミング応用」で学習できます）。
 オープンソース プログラミング教育に最適 ビジュアルコンテンツの作成が容易 Javaによく似た文法  Processingの開発環境Processing自体が統合開発環境であるため、開発するために他のソフトウェアを必要としません。 Processingを拡張するためのプロジェクトは多く存在し、最新のウェブ環境（HTML5）で視覚的なプログラミングが可能なProcessing.js、AR（拡張現実）を実現するためのNyARToolkitなど応用範囲は幅広いです。
Processingを起動すると下記のメイン画面が表示されます（バージョンは3.02）。 メイン画面はシンプルに構成されており、標準的なメニューバーとツールバーに加え、ソースコードを編集するためのエディタ、プログラムのエラーを確認するためのコンソールがあります。 この画面でプログラムを作成し、Runボタンをクリックするだけで、実行結果を確認することができます。

スケッチの作成Processingはスケッチという単位でプログラムを作成します（保存する前のファイル名は「sketch_日付a」）。 まずは、スケッチを保存する場所を設定しましょう。 メニューから[ファイル]-[設定]をクリックして、「設定」を開きます。 ここで、スケッチブックの場所を「H:\MyProcessing」に変更しましょう（スケッチブックの場所は日本語名のフォルダを含まないようにする必要があります）。

次に、スケッチを保存してみましょう。 メニューから[ファイル]-[名前を付けて保存]をクリックして、「スケッチフォルダを名前を付けて保存」を開きます。 ファイル名に「Project1」を入力し、[保存]をクリックしましょう。 保存先に「Project1」という名前のフォルダが作成されていることを確認してください。 また、このフォルダを開くと中に「Project1.pde」というファイルがあります。 このファイルがProcessingのソースコードです。

コンソールへの出力コンソールに文字列を出力するにはprintln()という命令文を用います。 ここでは、「Hello World!」という文字列をコンソールに出力してみます。 下記を参考にコードを入力したら、Runボタンをクリックしてください。 命令文の最後にはセミコロン（;）が必要なことに注意してください。 コンソールに「Hello World!」が出力されていることを確認してください。

もし入力したコードにエラーがある場合は、エラータブに切り替えることで、エラーの詳細を確認することができます。 例えば、下記のコードの場合は「Missing right parenthesis &amp;ldquo;)&amp;ldquo;」と表示されます。

課題println()を使用して、「本日の授業の感想」をコンソールに出力させてください。 課題が完成したら、作成したスケッチをZIPアーカイブ形式で保存します。 ZIPアーカイブを作成するには、メニューから[ツール]-[スケッチをアーカイブ]をクリックして、「スケッチを名前を付けてアーカイブする」を開きます。 保存するファイル名を確認した上で、[保存]をクリックします。 保存先に「Project1-日付a.zip」というファイルが作成されていることを確認してください。</description>
    </item>
    
    <item>
      <title>QRコードの読み取り</title>
      <link>https://mukai-lab.info/pages/tech/robohon/robohon3/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://mukai-lab.info/pages/tech/robohon/robohon3/</guid>
      <description>ロボホンのカメラロボホンの開発キットRoBoHoN Software Development Kitに 同梱されているカメラ用のアプリ SampleCamera を基にQRコードの読み取り機能を実装します。 QRコードの読み取りには、オープンソースとして提供されているZXingを採用します。 ちなみに、 ZXing の名称は Zebra Crossing が基になっているようです。 ZXing の実装方法はNAVERまとめの記事「Java QRコード読み取り」を参考にし、 ライブラリはMaven RepositoryからダウンロードしたJARファイルを利用します。 現時点での最新バージョンは 3.3.0 です（2017年9月20日現在）。
カメラの利用まずは、SampleCamera のプロジェクトを Android Studio で開き確認しましょう。 MainActivity.javaがこのサンプルの中心となるソースファイルです。
ロボホンのカメラを利用した撮影には、静止画、動画、また、顔認識の有無などの設定が可能です。 ここでは、写真撮影 顔認識無ボタン の挙動にQRコードの読み取り機能を加えます。 下記が該当部分のソースコードです。 背面のモニタにある*cameraButton*をタップすると、getIntentForPhoto メソッドの 返り値（Intent クラスのインスタンス）が、sendBroadcast メソッドで通知される処理となっていることが分かります。
 次に、getIntentForPhoto メソッドを確認します。 ここで、登場する ShootMediaUtil クラスが重要な役割を担います。 Intent クラスのコンストラクタの引数には静止画撮影用のアクション名であるShotMediaUtil.ACTION_SHOOT_IMAGEを指定します。 また、アクション（撮影）終了後の結果通知を得るために、putExtraメソッドで ShotMediaUtil.EXTRA_REPLYTO_ACTIONを指定し、 ACTION_RESULT_TAKE_PICTURE をその返り値としています。 このインテントを sendBroadcast で通知することで、カメラの撮影機能が実行されます。
 カメラの撮影後には、結果通知として ACTION_RESULT_TAKE_PICTURE を CameraResultReceiver クラスの onReceive メソッドで受け取ります。 ここでは、ACTION_RESULT_TAKE_PICTURE に該当するコードのみを抜き出してみます。 撮影が成功していれば、インテントから ShootMediaUtil.</description>
    </item>
    
    <item>
      <title>R言語によるデータの視覚化</title>
      <link>https://mukai-lab.info/pages/classes/advanced_studies_seminar_2/chapter3/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://mukai-lab.info/pages/classes/advanced_studies_seminar_2/chapter3/</guid>
      <description>データの可視化 -- データの可視化データの特徴を理解するには，グラフなどを利用してデータを可視化することが重要です． R言語には散布図やヒストグラムなどで可視化するための機能がありますが， ここでは，よりリッチな可視化を実現するために，拡張パッケージのggplot2を採用します． ggplot2には，簡単に素早く描画するqplot関数と，複雑な描画が可能なggplot関数があります． 今回は，qplot関数に注目します．
スクリプトの作成 -- スクリプトの作成コードを入力し保存するためのスクリプトを作成しましょう． [ファイル]-[新しいスクリプト]をクリックし，Rエディタを表示します． 次に，[ファイル]-[保存]をクリックして，スクリプトを保存します． このとき，ファイル名はchapter3としてください． また，ファイルの保存場所と作業ディレクトリをデスクトップに変更しておきます．
ggplot2のインストール -- ggplot2のインストールまずは，ggplot2パッケージをインストールしましょう． ツールバーから[パッケージ]-[パッケージの読み込み]をクリックし， パッケージの一覧からggplot2を選択します． これで対応するパッケージがダウンロードされます．

このパッケージを利用可能な状態にするには， library関数を利用します． ここでは，スクリプトに下記のように記述しておきます．
library(ggplot2) これで，ggplot2を利用する準備が整いました．
ヒストグラム -- ヒストグラムまず，ヒストグラムを描いてみましょう． 対象となるデータフレームは下記のように生成しましょう． ここで，data.frameは，引数のベクトルを列とするデータフレームを生成する関数です． また，value は列名を表しています．
y &amp;lt;- c(1,1,2,3,5,6,6,6,7,9) d1 &amp;lt;- data.frame(value=y) プロンプトでデータフレームd1の要素を確認します． 要素はvalueの列だけで構成された１次元のデータとなります．
&amp;gt; d1 value 1 1 2 1 3 2 4 3 5 5 6 6 7 6 8 6 9 7 10 9 qplot()関数を利用して，このデータフレームのヒストグラムを描きます． 引数には，Y軸の列名，data=データフレーム名 を与えます． ここでは，下記のようにvalue，data=d1 が引数となります．</description>
    </item>
    
    <item>
      <title>R言語のデータ構造</title>
      <link>https://mukai-lab.info/pages/classes/advanced_studies_seminar_2/chapter2/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://mukai-lab.info/pages/classes/advanced_studies_seminar_2/chapter2/</guid>
      <description>データ構造 -- データ構造一般にプログラミング言語には，整数型，実数型，文字列型などデータの型が存在します． データの型を調べるにはtypeof関数を使用します． プロンプトで下記のように入力してみましょう．
&amp;gt; typeof(10) [1] &amp;#34;double&amp;#34; &amp;gt; typeof(&amp;#34;a&amp;#34;) [1] &amp;#34;character&amp;#34; すると，10 は double型であることが分かります． このdouble型は実数であることを表しています． 同様に，a は character型であることが分かります． このcharacter型は文字（もしくは文字列）であることを表しています． これらのデータ型は自動的に設定されるため，普段は特に意識する必要はありません．
R言語では，これらの基本的なデータ型に加えて，数値処理に適したベクトル，行列，データフレーム といった構造が存在します． これらは，基本的に複数の値をまとめて処理するときに利用し，他のプログラミング言語における配列と同じような使い方をされます． 今回は，これらデータ構造に注目していきます．
スクリプトの作成 -- スクリプトの作成コードを入力し保存するためのスクリプトを作成しましょう． [ファイル]-[新しいスクリプト]をクリックし，Rエディタを表示します． 次に，[ファイル]-[保存]をクリックして，スクリプトを保存します． このとき，ファイル名はchapter2としてください． また，ファイルの保存場所と作業ディレクトリをデスクトップに変更しておきます．
変数 -- 変数上述した実数や文字列は変数と呼ばれるオブジェクトに記録し，参照することができます． 変数に値を代入するには，&amp;lt;- という演算子を利用します． スクリプトに下記を入力して，スクリプトを読み込み実行してください（実行は「source(&amp;ldquo;chapter2.R&amp;rdquo;)」）．
x &amp;lt;- 10 y &amp;lt;- 2 z &amp;lt;- x * y これで，変数x，y，zに，それぞれ値が代入されました． 変数に代入された値を確認するには，プロンプトで下記のように，変数名をそのまま入力します．
&amp;gt; x [1] 10 &amp;gt; y [1] 2 &amp;gt; z [1] 20 x に10， y に2，z に20が代入されていることが確認できます． このように，演算子&amp;lt;-の後方に，代入したい値や式を記述します．</description>
    </item>
    
    <item>
      <title>R言語の基本的な操作</title>
      <link>https://mukai-lab.info/pages/classes/advanced_studies_seminar_2/chapter1/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://mukai-lab.info/pages/classes/advanced_studies_seminar_2/chapter1/</guid>
      <description>R言語とは -- R言語とはRは，AT &amp;amp; Tベル研究所が開発したS言語を基本に開発された統計解析向けのプログラミング言語です． オープンソースとして開発されており，誰でも自由に利用，改変，再配布が可能なフリーソフトウェアです． 統計用のソフトウェアには，マイクロソフトのExcelや， IBMのSPSSなどがありますが， R言語はプログラミング言語として統計処理が可能なことが大きな特徴となっています． 一方でGUI（グラフィカル・ユーザ・インターフェイス）は弱く，文化系の学生には取っ付きにくい印象を与えるかもしれません． しかし，Rの基本を学べば，データマイニングなどの高度な統計解析手法を利用することが可能です． この授業ではRの基本から学び，多変量解析やデータマイニングなどの応用を学習することを目標とします．
R言語のインストール -- R言語のインストールまずはRを公式サイトからダウンロードしてインストールしましょう． 現在のところ公式サイトは英語表記しかないので注意してください． この資料では，2017年3月8日の時点の最新バージョンであるR 3.3.3を利用して説明していきます． Rをインストールするとデスクトップに32ビット版の「R i386 3.3.3」と 64ビット版の「R x64 3.3.3」のショートカットが作成されます． 各自のPC環境に合わせてプログラムを実行してください． 実行すると下記のような「R console」というウィンドウが表示されます（ここでは64ビット版を使用）．

Rによる統計処理は，この「R console」に命令文を入力することが基本となります． 行頭の「&amp;gt;」はプロンプトと呼ばれ，この後にコマンド（命令）を入力して， エンターキーを押すとコマンドが実行されます． これを繰り返して，特定の処理を実現します．
四則演算 -- 四則演算まずは，加算，減算などの算術演算を実行してみましょう． Rでは，下記表の算術演算子が利用可能です．
   演算 演算子 例     加算 + 2+3   減算 - 2-3   乗算 * 2*3   除算 / 2&amp;frasl;3   べき乗 ^ 2^3   剰余 %% 2%%3    では，プロンプトの後に，「2 + 3」と入力してみましょう． すると下記のような加算の結果が得られます． ここで，[1]は出力される結果の1番目であることを意味しています． （今回は5のみが結果となるので，必然的に1番目になる）</description>
    </item>
    
    <item>
      <title>Tobii Eye Trackerを利用した視線の認識</title>
      <link>https://mukai-lab.info/pages/tech/eyetracker/eyetracker1/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://mukai-lab.info/pages/tech/eyetracker/eyetracker1/</guid>
      <description>Tobii Eye Trackerとは近年、ユーザの視線を検出するアイトラッキングという技術が注目されています。 アイトラッキングはマウスやキーボードの代替となりうるヒューマンインターフェイスの一つであり、 手足が不自由な障がい者のコミュニケーション装置としても活用されています。 光学センサーと画像処理技術を用いて、眼球の動き を解析することで、 ユーザの注視点（見つめている場所）を推定する方法が一般的です。 今回は、トビー・テクノロジー株式会社が ゲーム用に提供しているEye Tracker 4Cという 視線入力装置を利用して、ユーザの視線を検出するプログラムを実装してみます。 トビー・テクノロジーは自社の製品を利用したソフトウェアを開発するための Tobii Pro SDKを独自に提供していますが、 Eye Tracker 4CでTobii Pro SDKを利用するためには、 プロアップグレードキーが必要となることに注意が必要です （Tobii Core SDK や Tobii Gaming SDK という選択肢もありますが、研究やデータ分析を用途とする場合は Tobii Pro SDK を利用する必要があります）。 また、開発用の言語には Python、Matlab、C、Unity などに対応していますが、 ここでは、機械学習に適したPythonを採用します。 Tobii Pro SDK のドキュメントが公開されおり、この情報を参考にしながら開発を進めることになります。

開発環境の準備まずは、Pythonをインストールします。 Pythonのバージョンには3.xと2.xの２通り存在しますが、 Tobii Pro SDK に対応している 2.x を選択する必要があることに注意してください。 ここでは、現時点での最新バージョンである2.7.14を利用します(2017年10月17日)。
Pythonの本体に加えて、画像処理ライブラリのOpenCVと、 数値計算ライブラリのNumPyを追加でインストールします。 インストール方法はPythonのパッケージ管理システムであるpipを利用すれば簡単です。 コマンドプロンプトで下記のように入力します。 ここでは、3.3.0.10 のOpenCVと 1.13.3 のNumPyがインストールされました。
$ python -m pip install opencv-python Collecting opencv-python Downloading opencv_python-3.</description>
    </item>
    
    <item>
      <title>t分布を用いた検定</title>
      <link>https://mukai-lab.info/pages/classes/advanced_studies_seminar_2/chapter10/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://mukai-lab.info/pages/classes/advanced_studies_seminar_2/chapter10/</guid>
      <description>検定とは -- 検定とは第8回で示したように，母数は標本からある程度は推定することができます． しかし，標本のサンプル数nが少ないときは， 標本分散から母分散を推定することは難しくなります． このため，前回学んだ 標準正規分布を用いた検定（Z検定） を適用することができません．
 母平均\hat{\mu}は標本平均\muで推定できる 母分散\hat{\sigma}^2は標本分散（不偏分散）\sigma^2で推定できる  そこで，利用するのがt検定です． t検定では，母分散の推定値に，標本分散を用いて検定を行います． すなわち，母分散\hat{\sigma}^2が未知の場合です． このような場合は，t分布 と呼ばれる正規分布によく似た釣鐘状の分布を利用します． 今回は，t検定 の基本を解説した上で，R言語の関数を利用した検定を行います．
スクリプトの作成 -- スクリプトの作成コードを入力し保存するためのスクリプトを作成しましょう． [ファイル]-[新しいスクリプト]をクリックし，Rエディタを表示します． 次に，[ファイル]-[保存]をクリックして，スクリプトを保存します． このとき，ファイル名はchapter10としてください． また，ファイルの保存場所と作業ディレクトリをデスクトップに変更しておきます．
t検定 -- t検定具体例として，前回と同じ問題を取り上げていきます． 前回と異なるのは母集団の分散が未知というところです．
文化情報学部の学生Xに情報数学に関するテストを行ったところ， その得点の平均\hat{\mu}は60であった． このうち，向研究室に所属する5人の学生xの得点は下記であった． 向研究室に所属する学生xは， 文化情報学部の学生Xと， 同様の傾向があるか（母集団からランダムサンプリングした学生だろうか）． x = \{63,75,72,67,71\}   上記の問題を t検定 で考えます． 準備として，標本の分散を求めておきましょう．
x &amp;lt;- c(63,75,72,67,71) &amp;gt; var(x) [1] 21.8 母集団は「文化情報学部の学生X」， 標本は「向研究室に所属する学生x」と考えることができます． また，「標本平均の分布」をmとします． いずれも正規分布に従うと仮定すると，母集団の分布と，標本平均の分布は下記のようになります． ここで，母分散\hat{\sigma}^2は未知であることに注意してください．
X \sim N(60,\hat{\sigma}^2)  m \sim N(60,\hat{\sigma}^2/5)  帰無仮説 と 対立仮説 は前回と同じです． 信頼区間も前回と同じ「95%信頼度（5%棄却域）」を用いることにしましょう．</description>
    </item>
    
    <item>
      <title>アニメーション</title>
      <link>https://mukai-lab.info/pages/classes/applied_programming/chapter12/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://mukai-lab.info/pages/classes/applied_programming/chapter12/</guid>
      <description>プロジェクトの準備 -- プロジェクトの準備Eclipseで新規にプロジェクトを作成しましょう． メニューから[ファイル]-[新規]-[Javaプロジェクト]をクリックして，「新規Javaプロジェクトの作成」を開きます． ここでは，プロジェクト名に”Project12”を入力ます． また，JREは&amp;rdquo;プロジェクト固有のJREを使用&amp;ldquo;を選択します． 最後に，[完了]をクリックしましょう．
 
Applicationクラスを継承したMyApplicationクラスを作成しましょう． メニューから[ファイル]-[新規]-[クラス]をクリックして，「新規Javaクラス」を開きます． まず，名前に”MyApplication”を入力します． 次にスーパークラスを設定するために，[参照]ボタンから「スーパークラスの選択」を開き， 一致する項目からjavafx.application.Applicationを選択して，[OK]をクリックします． 最後に[完了]をクリックしましょう．

Applicationクラスの抽象メソッドであるstartメソッドをオーバーライドしておきます． 下記コードを参考に，タイトルをProject 12，幅を800px，高さを500pxに設定しましょう． プログラムの実行後にウィンドウが表示されることを確認してください．
 
プログラム実行時の注意JavaFXはmainメソッドがなくともプログラムの実行が可能という特徴を持っています． しかし，Eclipseの現バージョンでは未対応のため，下記のコードをMyApplicationクラスに記述する必要があります． プログラム実行の前に，必ず下記のコードをソースコードに挿入してください．
 イメージの描画 -- イメージの描画今回はイメージをキャンバスに描画し，パラパラ漫画の要領でアニメーションさせることに挑戦していきましょう． 前準備として，下記のコードを参考にCanvasクラスをウィンドウに配置してください． レイアウトペインとしてVBoxクラスを利用しています． プログラムの実行後に表示されるウィンドウを確認してください．
 
まずは，下記の「歩いている女性のイメージ（png画像）」をキャンバスに表示してみます． この２つのイメージを交互に表示することで歩いている様子の表現が可能です． walking1.pngとwalking2.pngをダウンロードしたら， プロジェクトのsrcフォルダにコピーしてください．
 
保存したイメージを読み込むには，下記のようにImageクラスを利用します （Imageクラスのコンストラクタの引数には，画像ファイルの位置を表すURLを指定します）． ここでは，２つのイメージを利用するため，Imageクラスの配列walkingを宣言して， walking[0]にwalking1.png，walking[1]にwalking2.pngをそれぞれ読み込みます．
Image walking[] = new Image[2]; walking[0] = new Image(this.getClass().getResource(&amp;#34;walking1.png&amp;#34;).toString()); walking[1] = new Image(this.getClass().getResource(&amp;#34;walking2.png&amp;#34;).toString()); キャンバスにイメージを表示するには，GraphicsContextクラスのdrawImage()メソッドを利用します． drawImage()メソッドの３つの引数は，表示するイメージ，X座標，Y座標を表しています．
gc.drawImage(walking[0], 0, 0); 下記のコードを参考に，新たにpaint()メソッドを定義して，walking1.</description>
    </item>
    
    <item>
      <title>アニメーションの表示</title>
      <link>https://mukai-lab.info/pages/classes/programming_1/chapter5/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://mukai-lab.info/pages/classes/programming_1/chapter5/</guid>
      <description>スケッチの作成Processingを起動して、新規にスケッチを保存しましょう。 メニューから[ファイル]-[名前を付けて保存]をクリックして、「スケッチフォルダを名前を付けて保存」を開きます。 ファイル名に「Project5」を入力し、[保存]をクリックしましょう。 保存先に「Project5」という名前のフォルダが作成されていることを確認してください。

setupとdrawアニメーションを制御するにはsetu()関数とdraw関数()が必要になります。 setup()関数には、変数の初期化など、プログラムを実行したときに1回だけ実行する処理を記述します。 一方、draw()関数は、プログラムの実行中に繰り返し実行され、アニメーションなど何かを変化させるための処理を記述します。 また、setup()関数とdraw()関数の外部で宣言された変数は両方の関数内で利用できます（グローバル変数と呼びます）。 setu()関数とdraw関数()は下記のように記述します（voidは「この関数は返値をもたない」という意味です）。
void setup(){ 1回だけ実行する処理; } void draw(){ 繰り返し実行する処理; } ここでは、ウィンドウの中央に半径10の円を描いてみましょう。 変数の初期化はsetup()関数、円の描画はdraw()関数に記述していることに注意してください。 下記を参考にコードを入力したら、Runボタンをクリックしてください。 ウィンドウの中央に円が描かれていることを確認してください。
 
直線運動 円が右方向に直線的に動くアニメーションを設定してみましょう。 右方向へのアニメーションは、draw()関数において、変数*x*の値を増加させることで表現できます。 下記を参考にコードを入力したら、Runボタンをクリックしてください。 複数の円が右方向に描画されることを確認してください。
 
しかし、上記のコードでは円が複数描画されてしまい、アニメーションしているように見えません。 そこで、draw()関数の最初で、背景を灰色（#cccccc）で塗りつぶすことで、常に円が1つだけ描画されるように変更します。 下記を参考にコードを入力したら、Runボタンをクリックしてください。 1つの円が右方向に移動することを確認してください。
 
円がウィンドウの端に到達したら、跳ね返って逆方向に進むように修正しましょう。 まずは、右端に到達したら、左方向に進むようにします。 円の速度を表す変数*speed*を宣言し、if文を利用して*x*の値が右端に到達したら*speed*の正負を反転します。 下記を参考にコードを入力したら、Runボタンをクリックしてください。 円が右端に到達すると跳ね返ることを確認してください。
 
同様に、左端に到達したら、右方向に進むようにします。 if文を利用してxの値が左端に到達したらspeedの正負を反転します。 下記を参考にコードを入力したら、Runボタンをクリックしてください。 円が左端に到達すると跳ね返ることを確認してください。
 
円運動 次は、円運動するアニメーションを設定してみましょう。 円運動を表現するにはsin()関数とcos()関数を利用します。 sin()関数とcos()関数の引数には角度を指定しますが、 ラジアン角を用いることに注意が必要です（ラジアン角は0から2&amp;pi;）。
円運動の半径を表す変数lとラジアン角を表す変数angleを宣言します。 また、座標を表すxとyはfloat型に変更します。 sin()関数とcos()関数を利用して、座標（x,y）を更新することで円運動を表現します。 下記を参考にコードを入力したら、Runボタンをクリックしてください。 円が円運動していることを確認してください。</description>
    </item>
    
    <item>
      <title>イベント処理</title>
      <link>https://mukai-lab.info/pages/classes/programming_1/chapter6/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://mukai-lab.info/pages/classes/programming_1/chapter6/</guid>
      <description>スケッチの作成Processingを起動して、新規にスケッチを保存しましょう。 メニューから[ファイル]-[名前を付けて保存]をクリックして、「スケッチフォルダを名前を付けて保存」を開きます。 ファイル名に「Project6」を入力し、[保存]をクリックしましょう。 保存先に「Project6」という名前のフォルダが作成されていることを確認してください。

マウスイベントProcessingではマウスイベントを検出するために下記表の関数が用意されています。 これらの関数内に、実行したい内容を記述することで、マウスイベントに対応した処理が可能になります。 また、これらのイベントの結果を反映させるには、draw()関数の記述が必要なことに注意してください。
   関数名 イベント     mouseMoved() マウスボタンを押さずに動かしたとき   mouseDragged() マウスボタンを押しながら動かしたとき   mousePressed() マウスボタンを押したとき   mouseReleased() マウスボタンを離したとき    ここでは、mouseMoved()関数を利用して、マウスの軌跡を描画してみましょう。 ウィンドウ内のマウスの位置は変数mouseXとmouseYで取得可能です。 マウスの動きを検知したら、半径3の塗りつぶし円を描きます。 下記を参考にコードを入力したら、Runボタンをクリックしてください。 マウスの動きに合わせて、軌跡が描かれることを確認してください。
 
次に、MousePressed()関数を利用して、マウスボタンを押したとき（クリックしたとき）に、 赤色の正方形を描画してみましょう。 下記を参考にコードを入力したら、Runボタンをクリックしてください。 マウスの位置に合わせて、正方形が描かれることを確認してください。
 
今度は、mousePressed()関数とmouseDragged()関数を組み合わせてみましょう。 マウスボタンを押した位置を中心座標として、マウスをドラッグして移動した距離を半径とした円を描きます。 まず、変数*x*と*y*を宣言し、mousePressed()関数でマウスボタンを押した位置を記録します。 次に、ouseDragged()関数で、座標(x,y)からの距離をdist()関数で求め円を描きます （dist(x1, y1, x2, y2)関数は、座標(x1,y1)と座標（x2,y2）の距離を求めます）。 下記を参考にコードを入力したら、Runボタンをクリックしてください。 マウスのドラッグ操作に合わせて、円が描かれることを確認してください。
 
キーボードイベントキーボードイベントを検出するために下記表の関数が用意されています。 これらの関数内に、実行したい内容を記述することで、キーボードイベントに対応した処理が可能になります。 また、これらのイベントの結果を反映させるには、draw()関数の記述が必要なことに注意してください。</description>
    </item>
    
    <item>
      <title>オブジェクト指向</title>
      <link>https://mukai-lab.info/pages/classes/programming_1/chapter8/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://mukai-lab.info/pages/classes/programming_1/chapter8/</guid>
      <description>スケッチの作成Processingを起動して、新規にスケッチを保存しましょう。 メニューから[ファイル]-[名前を付けて保存]をクリックして、「スケッチフォルダを名前を付けて保存」を開きます。 ファイル名に「Project8」を入力し、[保存]をクリックしましょう。 保存先に「Project8」という名前のフォルダが作成されていることを確認してください。

オブジェクト指向オブジェクト指向は大規模なプログラムを作成する際の開発者の負担を減らすためのコンセプトです。 しかし、オブジェクト指向を正しく理解には、多くの知識を経験を要します。 そこで、この授業では、オブジェクト指向における実用的なテクニックに絞って解説します。 オブジェクト指向の詳細を学びたい場合は、河合昭男氏の「ここから始めるオブジェクト指向（ITmediaエンタープライズ）」を参考にすると良いです。
オブジェクト指向の中心となるのはクラスと呼ばれる概念です。 これまでに使用したStringやPImageもクラスに該当します。 クラスは、int型やdouble型などのプリミティブなデータ型の変数（フィールド）と、 幾つかの処理をまとめて実行する関数（メソッド）を、一つにまとめて扱うことができるという特徴があります。
クラスの定義ここでは、クラスを利用してウィンドウに雪を降らせるアニメーションを設定しましょう。 雪を表現するにはどんなフィールドやメソッドが必要でしょうか。
フィールドの宣言 まずは、雪を表すSnowクラスを定義して、その位置を表す*x*と*y*をフィールドとして宣言します。 クラスを定義するには、「class」の文字列の後にスペースを空けて、クラス名を指定します（ここではSnow）。 また、「{}」で括られた内部に、フィールドの宣言やメソッドの定義を記述します。 ここでは、float型の*x*と*y*を宣言しています。
class Snow{ float x; float y; } 下記のコードを参考にSnowクラスを定義してみましょう。 setup()関数では、Snowクラスの実体（インスタンス）を生成しています。 インスタンスの生成は、クラス名 変数名 = new クラス名();と記述します。 また、フィールドに値を代入したり、保存されている値を取り出すには、 変数名.フィールド名と記述します。 ここでは、*x*には0～640のランダムな値、*y*には0を設定します。
 メソッドの定義 次に、雪を表示するためのdisp()メソッドを定義します。 メソッドは下記のように記述します。 返値とは、メソッド実行後に、呼び出し元に返す値のことを指します。 返値が不要な場合は、返値の型をvoidと表記し、return 返値;を省略することができます。
返値の型 メソッド名(){ 実行する命令 return 返値; } 下記のコードを参考にdisp()メソッドを定義してみましょう。 disp()メソッドでは、白く塗りつぶした半径5の円を描いています。 また、draw()関数で、定義したdisp()メソッドを呼び出しています。 メソッドを呼び出すには変数名.メソッド名()と記述します。 プログラムの実行後に、ウィンドウ上部に白い円が描画されていることを確認してください。
 
さらに、雪が降るアニメーションをfall()メソッドで定義します。 fall()メソッドでは、フィールド*y*の値を1だけ増加させます。 また、draw()関数では、定義したfall()メソッドを呼び出すとともに、 背景を黒で塗りつぶしていることに注意してください。 下記を参考にコードを入力したら、Runボタンをクリックしてくだい。 上から下に白い円がアニメーションしていることを確認しださい。</description>
    </item>
    
    <item>
      <title>オブジェクト指向①クラスとメソッド</title>
      <link>https://mukai-lab.info/pages/classes/applied_programming/chapter7/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://mukai-lab.info/pages/classes/applied_programming/chapter7/</guid>
      <description>プロジェクトの準備 -- プロジェクトの準備Eclipseで新規にプロジェクトを作成しましょう． メニューから[ファイル]-[新規]-[Javaプロジェクト]をクリックして，「新規Javaプロジェクトの作成」を開きます． ここでは，プロジェクト名に”Project7”を入力して，[完了]をクリックしましょう． パッケージ・エクスプローラに作成したプロジェクトが表示されていることを確認してください．

続いてソースファイルを作成しましょう． メニューから[ファイル]-[新規]-[クラス]をクリックして，「新規Javaクラス」を開きます． ここでは，名前に”MyClass”を入力し，public static void main(String[] args)(V)にチェックを入れ，[完了]をクリックしましょう． パッケージ・エクスプローラに作成したソースファイルが表示されていることを確認してください．

オブジェクト指向 -- オブジェクト指向今回はJavaの本質とも言えるオブジェクト指向について学びます． オブジェクト指向は，大規模なプログラムを作成する際の開発者の負担を減らすためのコンセプトであり， オブジェクト指向に沿ってプログラミングすることでプログラムの「柔軟性」「保守性」「再利用性」の向上が期待できます． しかし，オブジェクト指向はあくまでコンセプトであり，たとえ経験豊かなエンジニアであっても， 一言で「オブジェクト指向が何か」を言い表すことは難しく， Javaプログラミング初心者にとっては大きな障壁となりがちです．
極論すれば，オブジェクト指向とは「現実世界のオブジェクト（もの）を， そのままプログラムの世界のオブジェクト（もの）に置き換えること」と言えます． 例えば，サッカー選手をプログラムの世界に置き換えることを考えてみます （ウイニングイレブンなどのサッカーゲームを想像してください）． サッカー選手をプログラムの世界で表現するには，サッカー選手の特徴を数値化したり，それぞれの役割や操作を定義する必要があります． 例えばサッカーゲームの本田圭佑選手は，キック力は80，ドリブルスピードは76などのように，個々の特徴を数値で特徴化していますね． 他にも，ポジションはフォワードやミッドフィールダー，操作はドリブルやシュートなどを設定する必要がありそうです．
オブジェクト指向では，オブジェクト（サッカー選手）を表現する型のことをクラス，そして， 型を実体化したもの（本田圭佑選手）をインスタンスと呼びます． また，個々の特徴をフィールド，操作をメソッドと呼びます． 一方，オブジェクトは実は曖昧な表現で，クラスとインスタンスの両方の意味で用いられることがあるので注意が必要です．
クラスの定義 -- クラスの定義ここでは，現実世界の「色画用紙」をクラスで表現することを考えてみましょう． 画用紙に必要な特徴は何でしょうか． ここでは，幅（width），高さ（height），色（color）を色画用紙を表す特徴として考えていきましょう．

クラスはファイルに１つだけ定義するのが基本です． まずは，色画用紙を表すPaperクラスを新規に作成しましょう． メニューから[ファイル]-[新規]-[クラス]をクリックして，「新規Javaクラス」を開きます． ここでは，名前に”Paper”を入力し，[完了]をクリックしましょう．

クラスの宣言部に当たるpublic class クラス名{}は既に記述されています． この宣言の{}内に，画用紙の特徴を表すフィールドを定義します． ここでは，width，height，colorの3つのフィールドです． 下記のコードを参考に，色画用紙を表すクラスPaperのフィールドを宣言してみましょう．
 次に，下記のコードを参考にPaperクラスをインスタンス化してみましょう． ここでは，幅182[mm]，高さ257[mm]，赤色の画用紙を想定しています． インスタンス化はクラス名 変数名 = new クラス名()と記述します． また，フィールドに値を代入したり，保存されている値を取り出すには変数名.</description>
    </item>
    
    <item>
      <title>オブジェクト指向②継承とインターフェイス</title>
      <link>https://mukai-lab.info/pages/classes/applied_programming/chapter8/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://mukai-lab.info/pages/classes/applied_programming/chapter8/</guid>
      <description>プロジェクトの準備 -- プロジェクトの準備Eclipseで新規にプロジェクトを作成しましょう． メニューから[ファイル]-[新規]-[Javaプロジェクト]をクリックして，「新規Javaプロジェクトの作成」を開きます． ここでは，プロジェクト名に”Project8”を入力して，[完了]をクリックしましょう． パッケージ・エクスプローラに作成したプロジェクトが表示されていることを確認してください．

続いてソースファイルを作成しましょう． メニューから[ファイル]-[新規]-[クラス]をクリックして，「新規Javaクラス」を開きます． ここでは，名前に”MyClass”を入力し，public static void main(String[] args)(V)にチェックを入れ，[完了]をクリックしましょう． パッケージ・エクスプローラに作成したソースファイルが表示されていることを確認してください．

継承とは -- 継承とは前回はオブジェクト指向について学習しました． オブジェクト指向とは「現実世界のオブジェクト（もの）を，そのままプログラムの世界のオブジェクト（もの）に置き換えること」を意味しているんでしたね． そして，オブジェクトの型をクラスで表現することも理解したかと思います． 今回は，オブジェクト指向における重要な機能の１つクラスの継承について学びます． クラスの継承とは，「クラスの持つフィールドやメソッドを引き継ぎながら新しいクラスを作成すること」を意味しています． この継承という機能を利用することで，コードの冗長性を排除し，スッキリとした表現で記述することが可能になります．
ここでは，会話が出来るロボットを表すRobotクラスを作成してみましょう． メニューから[ファイル]-[新規]-[クラス]をクリックして，「新規Javaクラス」を開きます． ここでは，名前に”Robot”を入力し，[完了]をクリックしましょう．

下記のコードを参考に，nameフィールドと，speakメソッドを定義してください． コンストラクタでnameフィールドを初期化していることに注意してください．
 下記のコード参考にRobotクラスをインスタンス化してみましょう． ここでは，ロボットの名前をロボット1号とします． プログラムの実行後にコンソール出力を確認してください．
 上記で作成したロボット１号は一方的に話すだけで面白くありません． そこで，次に対話が可能なロボットに改良してみましょう． このようなときに利用すると便利な機能が継承です． Robotクラスを継承してTalkRobotを作成してみます．
メニューから[ファイル]-[新規]-[クラス]をクリックして，「新規Javaクラス」を開きます． ここでは，名前に”TalkRobot”，スーパクラスに&amp;rdquo;Robot&amp;rdquo;を入力し，[完了]をクリックしましょう． このスーパークラスとは，継承元となるクラスを意味し，「スーパークラス」の他にも「親クラス」などと呼びます． 一方，継承したクラスは，「サブクラス」や「子クラス」と呼びます．

継承するとクラス宣言部のextendsの後に継承元のクラス名が記述されます． 下記のコードを参考に，talkメソッドを定義してください． talkメソッドでは，キーボードから名前を入力すると，ロボットが入力された名前を話します． コンストラクタ内のsuper(name)は，スーパークラスであるRobotクラスのコンストラクタと同じ処理をします．
 下記のコードを参考にTalkRobotクラスをインスタンス化してみましょう． ここでは，ロボットの名前をロボット2号とします． プログラムの実行後にコンソール出力を確認してください． Robotクラスを継承することで，Robotクラスのnameフィールドやspeakメソッドを， TalkRobotでも利用できることが分かります．
 TalkRobotクラスで，speakメソッドを修正することもできます． これをオーバーライドと呼びます． ここでは，下記のコードを参考にspeakメソッドをオーバライドして， 男らしい話し方をするロボットに修正しましょう． プログラムの実行後にコンソール出力を確認してください．
 インターフェイスとは 継承する際にスーパークラスは1つしか指定することはできません． 複数の継承元の機能を引き継ぎたい場合はどうすれば良いでしょうか（多重継承と呼びます）． このような場合に利用するのがインターフェイスです． インターフェイスは下記の点がクラスとは異なります．</description>
    </item>
    
    <item>
      <title>オリジナル作品の制作①：準備</title>
      <link>https://mukai-lab.info/pages/classes/applied_programming/chapter13/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://mukai-lab.info/pages/classes/applied_programming/chapter13/</guid>
      <description>オリジナル作品の条件 -- オリジナル作品の条件
これまでに学習した技術を活かして，自由なテーマでオリジナルのJavaプログラムを制作してください． テーマは，「ユーティリティ」「ゲーム」「アート」「写真・画像編集」など自由に選んでください． これまでに制作したプログラムに新しい要素を追加して自身の作品としても構いません． ただし，作品は下記の条件を必ず満たして下さい． また，Javaの書籍やウェブサイトを参考にすることも問題ありませんが， 必ず発表の際に参考にした書籍やウェブサイトを紹介してください．
 JavaFXを利用したGUIアプリケーションであること ボタン，マウス，キーボードなどのイベント処理，または，タイムラインを利用したアニメーション処理を含むこと 実行可能JARファイルとしてエクスポートし，JARファイルのみで実行可能であること  参考書籍</description>
    </item>
    
    <item>
      <title>オリジナル作品の制作①：準備</title>
      <link>https://mukai-lab.info/pages/classes/programming_1/chapter13/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://mukai-lab.info/pages/classes/programming_1/chapter13/</guid>
      <description>
これまでに学習した技術を活かして、自由なテーマでオリジナルのProcessingプログラムを制作してください。 これまでに制作したプログラムに新しい要素を追加して自身の作品としても構いません。 ただし、作品は下記の”いずれか”の機能を必ず取り入れてください。
 アニメーションの利用 マウスやキーボードのイベント処理の利用 3Dグラフィックスの利用 カメラ映像の利用  参考書籍</description>
    </item>
    
    <item>
      <title>オリジナル作品の制作②：実装</title>
      <link>https://mukai-lab.info/pages/classes/applied_programming/chapter14/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://mukai-lab.info/pages/classes/applied_programming/chapter14/</guid>
      <description>オリジナル作品の条件 -- オリジナル作品の条件
これまでに学習した技術を活かして，自由なテーマでオリジナルのJavaプログラムを制作してください． テーマは，「ユーティリティ」「ゲーム」「アート」「写真・画像編集」など自由に選んでください． これまでに制作したプログラムに新しい要素を追加して自身の作品としても構いません． ただし，作品は下記の条件を必ず満たして下さい． また，Javaの書籍やウェブサイトを参考にすることも問題ありませんが， 必ず発表の際に参考にした書籍やウェブサイトを紹介してください．
 JavaFXを利用したGUIアプリケーションであること ボタン，マウス，キーボードなどのイベント処理，または，タイムラインを利用したアニメーション処理を含むこと 実行可能JARファイルとしてエクスポートし，JARファイルのみで実行可能であること  参考書籍</description>
    </item>
    
    <item>
      <title>オリジナル作品の制作②：実装</title>
      <link>https://mukai-lab.info/pages/classes/programming_1/chapter14/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://mukai-lab.info/pages/classes/programming_1/chapter14/</guid>
      <description>
これまでに学習した技術を活かして、自由なテーマでオリジナルのProcessingプログラムを制作してください。 これまでに制作したプログラムに新しい要素を追加して自身の作品としても構いません。 ただし、作品は下記の”いずれか”の機能を必ず取り入れてください。
 アニメーションの利用 マウスやキーボードのイベント処理の利用 3Dグラフィックスの利用 カメラ映像の利用  参考書籍</description>
    </item>
    
    <item>
      <title>オリジナル作品の制作③：発表</title>
      <link>https://mukai-lab.info/pages/classes/applied_programming/chapter15/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://mukai-lab.info/pages/classes/applied_programming/chapter15/</guid>
      <description>オリジナル作品の発表 -- オリジナル作品の発表
１人につき１分程度で制作したオリジナル作品を紹介してください． 紹介の際には下記の４項目を必ず含めて下さい．
 作品タイトル 作品の概要 操作方法（実演しながら） 苦労した点，工夫した点 （参考にした書籍やウェブサイトなど）  参考書籍</description>
    </item>
    
    <item>
      <title>オリジナル作品の制作③：発表</title>
      <link>https://mukai-lab.info/pages/classes/programming_1/chapter15/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://mukai-lab.info/pages/classes/programming_1/chapter15/</guid>
      <description>
１人につき１分程度で制作したオリジナル作品を紹介してください。 紹介の際には下記の４項目を必ず含めて下さい。
 作品タイトル 作品の概要 操作方法（実演しながら） 苦労した点、工夫した点  参考書籍</description>
    </item>
    
    <item>
      <title>オリジナル地図の発表</title>
      <link>https://mukai-lab.info/pages/classes/seminar_fundamental_areas/chapter5/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://mukai-lab.info/pages/classes/seminar_fundamental_areas/chapter5/</guid>
      <description>
オリジナル地図の作成オリジナルのオンライン地図を作成してください． 対象とするエリアは住んでいる街やお気に入りの街など自由に設定してください（日進市は除く）． また，テーマに関しても，観光に限らず，書店，図書館，美容院など自由です． ただし，作成する地図は下記の条件を満たす必要があります． ポップアップ表示する写真（画像）は事前に撮影しておくことが望ましいです．
 Leafletを利用すること 3箇所以上のマーカーを設定すること マーカーのポップアップ表示で写真（画像）を表示すること  オリジナル地図の発表作成したオンライン地図を紹介してください． 紹介する際は下記の情報を含めてください．
 対象としたエリアはどこか（例，日進市） 対象としたテーマは何か（例，観光） 表示したマーカーの詳細  課題Leafletで作成したHTMLファイルを，画像を含めたフォルダごとZIPで圧縮し，提出しなさい．
参考書籍</description>
    </item>
    
    <item>
      <title>オープンストリートマップを利用したオープンデータの可視化①・uMap</title>
      <link>https://mukai-lab.info/pages/classes/seminar_fundamental_areas/chapter3/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://mukai-lab.info/pages/classes/seminar_fundamental_areas/chapter3/</guid>
      <description>オープンストリートマップとは行政が公開しているオープンデータには， 施設の位置を表す緯度，経度の情報が含まれることが多くあります． 前回利用した日進市の子育て支援施設のオープンデータにも，施設の名称や住所に加えて，緯度・経度の情報が含まれていました． オンライン地図を利用して，これらの位置情報を可視化することで，新たな気付きを得ることが可能です．
オンライン地図として最も有名なサービスはGoogleが提供しているGoogle Mapsでしょう． Google Mapsは，滑らかな地図の表示はもちろん，ストリートビュー，ジオコーディング，ルート検索などの機能も充実しています． ここで，ジオコーディングとは住所や地名などを緯度・経度に変換する技術を指しています． 例えば，椙山女学園大学の地図をGoogle Mapで表示してみます． ウェブページにGoogle Mapsを埋め込むには，共有をクリックし， 地図を埋め込むのタブに表示されているソースコードをコピペするだけで完成です．
 Google Mapsはとても便利なのですが，利用規約が厳しいことが知られています． クレジット表示が必要なことは当然ですが，非営利であっても印刷物での使用には大きな制限があります． 新聞，雑誌，レポートなどの目的では問題ありませんが，ガイドブックや印刷広告には使用することができません． これは，行政にとっては致命的であり，自治体を紹介する印刷広告を作成しようとしても，Google Mapsを掲載することができません． そこで，代わりに用いられるのがオープンストリートマップ(OpenStreetMap: OSM)です． オープストリートマップはクリエイティブ・コモンズ CC-BY-SA 2.0と呼ばれる ライセンスで提供されており，適切にクレジットを表示すれば，営利目的の使用も含め，複製・再配布・改変が認められています． 例えば，椙山女学園大学の地図をオープンストリートマップで表示してみます． 上記のGoogle Mapsと比較しても，遜色ないことが分かるでしょう．
 加えて，オープンストリートマップの最も大きな特徴は，オープンストリートマップのアカウント登録さえすれば， 誰しもが自由に地図を編集することができるという点です． つまり，オープンストリートマップは，オンライン地図のサービスであることに加え，無料地図の共同作成プロジェクトでもあるわけです． オープンストリートマップを編集する人のことをマッパーと呼び， 複数のマッパーで街歩きをしながらオープンストリートマップを編集するイベントをマッピングパーティと呼びます． 全国各地でマッピングパーティは開催されていますので，興味があれば参加してみることをお勧めします． 日進市においては，平成29年12月9日に「ブラニッシン〜いまのにっしん，世界に発信！〜」という マッピングパーティが開催され，向も参加しました．
今回は日進市のオープンデータとオープンストリートマップを組み合わせ， 独自のオンライン地図を作成する方法について学習していきましょう．
GeoJSONここで，オープンデータの条件である「機械判読に適したデータ形式」について考えてみます． オンライン地図にオープンデータを表示するには，当然，コンピュータが読み取ることが出来る形式を用いる必要があります． これまでに，xlsx形式，csv形式を紹介しましたが，よりウェブに相性が良いデータ形式があります． それが，JSON形式（.json）です． JSONは，「じぇいそん」と読み，ブラウザで動作するプログラミング言語のJavaScriptで用いられるデータ形式です （JavaScript以外のプログラミング言語でも対応していることが多い）．
下記のCSV形式のデータを例に考えてみましょう．
町名,男,女,総数,世帯数 赤池町,1693,1647,3340,1315 浅田町,2593,2431,5024,2086 上記のデータをJSON形式に変換すると下記になります． JSON形式では，データはstring（文字列）とvalue（値）の組で表現されます． 例えば，&amp;rdquo;町名&amp;rdquo;という文字列と，&amp;rdquo;赤池町&amp;rdquo;という値が組になっていることがわかります． また，[ ]は配列を表しており，0番目の要素に赤池町のデータ，1番目の要素に浅田町のデータが格納されます． 要素は「,（カンマ）」で区切られますが，最後の要素には必要ありません（間違えやすいので要注意）．
[ { &amp;#34;町名&amp;#34;: &amp;#34;赤池町&amp;#34;, &amp;#34;男&amp;#34;: 1693, &amp;#34;女&amp;#34;: 1647, &amp;#34;総数&amp;#34;: 3340, &amp;#34;世帯数&amp;#34;: 1315 }, { &amp;#34;町名&amp;#34;: &amp;#34;浅田町&amp;#34;, &amp;#34;男&amp;#34;: 2593, &amp;#34;女&amp;#34;: 2431, &amp;#34;総数&amp;#34;: 5042, &amp;#34;世帯数&amp;#34;: 2086 } ] このJSON形式を基本として，点，線，多角形などの空間データを表現するために用いられるのが， GeoJSON形式です． GeoJSONは，「じおじぇいそん」と読み， uMap，Leeflet， OpenLayersなどの様々な地図サービスで利用可能です．</description>
    </item>
    
    <item>
      <title>オープンストリートマップを利用したオープンデータの可視化②・Leaflet</title>
      <link>https://mukai-lab.info/pages/classes/seminar_fundamental_areas/chapter4/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://mukai-lab.info/pages/classes/seminar_fundamental_areas/chapter4/</guid>
      <description>Leafletとは前回はuMAPというサービスを利用して， 日進市のオープンデータをオープンストリートマップに重ねて表示しました． uMAPを用いると，ブラウザ上で手軽にオリジナルの地図を作成することができますが， 作成された地図は静的で，ユーザとのインタラクションに応じて動的に変化させることはできません． そこで，今回はLeafletを利用して，オリジナルの地図を作成することに挑戦しましょう． Leafletは，「りーふれっと」と読み，プログラミング言語であるJavaScriptのライブラリの一つです． オープンソースで開発されており，BSD 2-Clauseライセンスであるため， クレジットさえ表示すれば，商用利用・改変・配布が可能です． Leafletを用いると，デスクトップPCやモバイル環境に適したオンライン地図を表示することができます． JavaScriptで制御可能であるため，ユーザとのインタラクションに応じて動的に地図を変更することが可能です． もちろん，前回紹介したGeoJSON形式のデータの取り込みも可能です． 今回は，このLeafletを用いて日進市の観光マップを作成します．
オープンデータの準備日進市のオープンデータミュージアムにある 観光情報データを利用します． ここでは，名称と緯度・経度の情報を利用することにします． 下記はCSV形式で表現されたデータです．
名称,緯度,経度 岩崎城址公園,35.1455654,137.0420547 愛知牧場,35.1306941,137.0876883 五色園,35.1557573,137.0682229 レトロでんしゃ館,35.1228602,137.0221455 旧市川家住宅,35.12896,137.033636 今回は，上記のテキスト情報だけでなく，下記の5つの画像ファイルを利用します． これらは日進市のイベント情報を提供しているぐるぐるNISSHINに掲載されていますが， オープンデータではないことに注意してください（授業向けに許可を得て利用しています）． 全ての画像ファイルをダウンロードしておいてください．
上記の観光情報と画像ファイル名を，下記のようにGeoJSON形式に変換します． 画像ファイル名はpropertiesに記載しています． ここでは，経度・緯度の順番で指定することに注意してください．
{ &amp;#34;type&amp;#34;: &amp;#34;FeatureCollection&amp;#34;, &amp;#34;features&amp;#34;: [ { &amp;#34;type&amp;#34;: &amp;#34;Feature&amp;#34;, &amp;#34;geometry&amp;#34;: { &amp;#34;type&amp;#34;: &amp;#34;Point&amp;#34;, &amp;#34;coordinates&amp;#34;: [137.0420547,35.1455654] }, &amp;#34;properties&amp;#34;: { &amp;#34;名称&amp;#34;: &amp;#34;岩崎城址公園&amp;#34;, &amp;#34;画像&amp;#34;: &amp;#34;iwasaki.jpg&amp;#34; } }, { &amp;#34;type&amp;#34;: &amp;#34;Feature&amp;#34;, &amp;#34;geometry&amp;#34;: { &amp;#34;type&amp;#34;: &amp;#34;Point&amp;#34;, &amp;#34;coordinates&amp;#34;: [137.0876883,35.1306941] }, &amp;#34;properties&amp;#34;: { &amp;#34;名称&amp;#34;: &amp;#34;愛知牧場&amp;#34;, &amp;#34;画像&amp;#34;: &amp;#34;bokujyou.</description>
    </item>
    
    <item>
      <title>カメラ映像の表示</title>
      <link>https://mukai-lab.info/pages/classes/programming_1/chapter10/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://mukai-lab.info/pages/classes/programming_1/chapter10/</guid>
      <description>スケッチの作成Processingを起動して、新規にスケッチを保存しましょう。 メニューから[ファイル]-[名前を付けて保存]をクリックして、「スケッチフォルダを名前を付けて保存」を開きます。 ファイル名に「Project10」を入力し、[保存]をクリックしましょう。 保存先に「Project10」という名前のフォルダが作成されていることを確認してください。

Videoライブラリの導入ProcessingではVideoライブラリを導入することで、 カメラからの映像をウィンドウに表示することができるようになります。 まずは、メニューから[スケッチ]-[ライブラリをインポート]-[ライブラリを追加]をクリックして、 「Contribution Manager」を開きます。 ここで、videoをキーワードに検索すると、 「Video|GStreamer-based video library for Processing」が表示されるので、 このライブラリを選択してインストールしましょう。

次に、[スケッチ]-[ライブラリをインポート]-[Video]をクリックして、 Videoライブラリをインポート（プログラムで利用可能な状態にすること）します。 ソースコードの１行目に「import processing.video.*;」と表示されていることを確認してください。
 カメラ映像の表示カメラから入力した映像はCaptureクラスを利用します。 まずは、setup()関数において、Captureクラスのlist()関数を呼び出し、 利用可能なカメラの一覧をString型の配列で取得します。 これをコンソールに出力し、利用可能なカメラの種類を確認してください。
 例えば、コンソールには下記のような一覧が表示されます。 この中から、サイズ（size）が320x240となっているカメラ番号を覚えておいてください。 この例では、3番が該当します。 ウィンドウのサイズも320x240に合わせます。 ちなみに、フレームレート（fps）は、1秒間に更新される画像（フレーム）数を意味しています。 つまり、フレームレートが高いほど、滑らかな動画となります。
[0] name=FULL HD 1080P Webcam,size=640x480,fps=30 [1] name=FULL HD 1080P Webcam,size=160x120,fps=30 [2] name=FULL HD 1080P Webcam,size=176x144,fps=30 [3] name=FULL HD 1080P Webcam,size=320x240,fps=30 [4] name=FULL HD 1080P Webcam,size=352x288,fps=30 [5] name=FULL HD 1080P Webcam,size=640x360,fps=30 [6] name=FULL HD 1080P Webcam,size=800x600,fps=30 [7] name=FULL HD 1080P Webcam,size=960x720,fps=30 [8] name=FULL HD 1080P Webcam,size=1024x576,fps=30 [9] name=FULL HD 1080P Webcam,size=1280x720,fps=30 次に、Captureクラスのインスタンスcamを下記のように初期化します。 引数には先程確認したカメラ番号を指定することに注意してください。 start()関数を呼び出すことで、カメラ映像の取得を開始します。</description>
    </item>
    
    <item>
      <title>グラフの表示</title>
      <link>https://mukai-lab.info/pages/classes/graduation_preperation_1/chapter6/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://mukai-lab.info/pages/classes/graduation_preperation_1/chapter6/</guid>
      <description>グラフ表示 -- グラフ表示今回はオープンソースのグラフ描画ライブラリであるChart.jsを利用して，グラフを描くことに挑戦してみましょう． Chart.jsは HTML5 の Canvas要素 にグラフを描くことが可能なライブラリで，「折れ線グラフ」「縦棒グラフ」「円グラフ」などの８種類がグラフが利用できます（2016年12月16日現在）． また，レスポンシブにも対応しているため，PCだけでなくスマーフォンでも美しく描画されるという特徴があります． まずは，導入用のパッケージをGitHubからダウンロードしましょう． ダウンロードしたら sampleフォルダ にある様々なグラフを表示してみましょう． グリグリとアニメーションしながらグラフが表示されると思います．
JSON形式 -- JSON形式グラフの元となるデータは JSON(Javascript Object Notation) と呼ばれる形式で記述します． JSONで表されたデータは，JavaScriptのオブジェクトに対応していて，JSON形式のテキストからオブジェクトを生成することができます． 一般にデータはCSVなどの形式で記述されることが多いですが， JavaScriptでテキストファイルを読み込むことは仕様上難しいことが多いため， JSONを利用する方法が採用されます．
ここでは，日進市のオープンデータミュージアムに掲載されているオープンデータからJSON形式のデータを作成することにします． 下記はオープンデータミュージアムで公開されていた 町別人口推移 から一部を抜粋したCSV形式のデータです．
city,population 赤池町,1195 浅田町,1899 梅森町,804 野方町,133 蟹甲町,158 一行目の「city」「population」は項目名であり，二行目からが実際のデータです． 例えば，赤池町は1,195人，浅田町は1,899人です． このCSV形式のデータをJSON形式に変換するには，iPentec が提供しているオンラインの変換ツールを利用すると簡単です．
変換ツールのページを開いたら「入力（CSV）」に上記のCSVデータを張り付けて， 「CSV➡JSON変換」のボタンをクリックします． すると下記のようなJSON形式のデータが出力されます．
[ { &amp;#34;city&amp;#34;: &amp;#34;赤池町&amp;#34;, &amp;#34;population&amp;#34;: &amp;#34;1195&amp;#34;}, { &amp;#34;city&amp;#34;: &amp;#34;浅田町&amp;#34;, &amp;#34;population&amp;#34;: &amp;#34;1899&amp;#34;}, { &amp;#34;city&amp;#34;: &amp;#34;梅森町&amp;#34;, &amp;#34;population&amp;#34;: &amp;#34;804&amp;#34;}, { &amp;#34;city&amp;#34;: &amp;#34;野方町&amp;#34;, &amp;#34;population&amp;#34;: &amp;#34;133&amp;#34;}, { &amp;#34;city&amp;#34;: &amp;#34;蟹甲町&amp;#34;, &amp;#34;population&amp;#34;: &amp;#34;158&amp;#34;} ] 今回はこのJSON形式のデータを利用してグラフを作成しましょう．</description>
    </item>
    
    <item>
      <title>トリガを用いた発話</title>
      <link>https://mukai-lab.info/pages/tech/robohon/robohon2/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://mukai-lab.info/pages/tech/robohon/robohon2/</guid>
      <description>サンプルアプリロボホンの開発キットRoBoHoN Software Development Kitには、 下記のサンプルアプリが同梱されています。 今回は基本的な音声UIの使い方を理解するためSampleSimpleのソースコードを解析し、 改良してみましょう。
 SampleSimple 音声UIを使った基本的な機能のアプリ SampleScenario シナリオで使える変数やタグなどのアプリ SampleProjector プロジェクターを利用したアプリ SampleAddressBook 電話帳を利用したアプリ SampleCamera カメラを利用したアプリ SampleDance ダンスを利用したアプリ SampleMultilingual 多言語対応を実装したアプリ  まずは、Android Studio で上記のサンプルを読み込み、プロジェクトとして展開します。 Android Studioを起動したら、[File]-[Open]-[Open File or Project]を選択し、 開発キットに含まれる SampleSimple のフォルダをクリックします。 ビルドが終了したら、Run Appをクリックして実行してみましょう。
実行するとロボホンの背面には「ACCOST」「RESOLVE VARIABLE」「SET_MEMORY_P」「GET_MEMORY_P」「FINISH APP」の５つのボタンが表示されています。 ここで、「ACCOST」ボタンをタップすると、「アプリから発話開始するサンプルだよ」とロボホンが発話します。 ちなみに、ACCOSTとは、アプリから強制的にトピック（発話やモーション）を実行することを意味します。

 アプリトリガによる発話最初に、ボタンなどアプリからのアクションをトリガとして、トピックを実行するアプリトリガによる発話について学びます。 まずは「ACCOST」ボタンに該当するソースコードを確認していきましょう。 一般にアンドロイドのアプリはActivityクラスを継承して開発します。 Activityクラスにはライフサイクルがあり、アプリを起動すると下図のようにメソッドを実行します。

ここで、「ACCOST」ボタンに関する振る舞いは、onCreate()メソッドの内部にあり、下記のように記述されています。 最初に、リソースIDを利用して、変数*voiceAccostButton*に、Buttonクラスのオブジェクトを代入し、ボタンをタップしたときのイベントリスナーを登録しています。 ボタンがタップされると、VoiceUIVariableListHelper クラスのインスタンスに実行したいACCOSTを登録し、VoiceUIManagerUtil クラスのupdateAppInfoメソッドで発話を実行しています。 ここで、ScenarioDefinitions.ACC_ACCOST には、実行するACCOSTの名称である jp.co.sharp.sample.simple.accost.t1 が代入されています。
 ここでのポイントは、実行するACCOSTの定義です。 具体的な定義は、シャープ株式会社が独自に定義している HVML(Hyper Voice Markup Language) というXMLファイルに記述します。 ここでは、assetsフォルダに含まれるjp_co_sharp_sample_simple_accost.</description>
    </item>
    
    <item>
      <title>ファイル入出力</title>
      <link>https://mukai-lab.info/pages/classes/applied_programming/chapter6/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://mukai-lab.info/pages/classes/applied_programming/chapter6/</guid>
      <description>プロジェクトの準備 -- プロジェクトの準備Eclipseで新規にプロジェクトを作成しましょう． メニューから[ファイル]-[新規]-[Javaプロジェクト]をクリックして，「新規Javaプロジェクトの作成」を開きます． ここでは，プロジェクト名に”Project6”を入力して，[完了]をクリックしましょう． パッケージ・エクスプローラに作成したプロジェクトが表示されていることを確認してください．

続いてソースファイルを作成しましょう． メニューから[ファイル]-[新規]-[クラス]をクリックして，「新規Javaクラス」を開きます． ここでは，名前に”MyClass”を入力し，public static void main(String[] args)(V)にチェックを入れ，[完了]をクリックしましょう． パッケージ・エクスプローラに作成したソースファイルが表示されていることを確認してください．

ストリーム -- ストリームプログラムからファイルに保存されているデータを「読み込む」ことや「書き込む」ことができます． ファイルに何かしらの操作を行う場合は，ストリームという仕組みを利用します． ストリームとは，「データの流れ」を意味しており，水道管の中を水が流れる様子に似ています． ファイルに蛇口を取り付けて，その蛇口を捻ると，ファイルに保存されているデータが少しずつ流れてくるイメージです． ここでは，10人の身長と体重が保存されたファイルからデータを読み込んでみましょう． データは氏名，身長[cm]，体重[kg]で構成され，それぞれ「,（カンマ）」で区切られていることに注意してください． このようにカンマで区切られたファイルをCSV（Comma-Separated Values）形式と呼びます． ファイルをダウンロードしたら，Eclipseのプロジェクトの中にコピーしておいてください．
 ファイルの読み込み -- ファイルの読み込みmeasure.csvから文字列データを読み込むには下記のように記述します． ファイルの読み込みにはFileReaderクラスとBufferedReaderクラスを利用しますが， ここではファイルに取り付ける蛇口がFileReader， 蛇口から流れてくるホースの役割がBufferedReaderクラスと考えてください． line=br.readLine()でファイルから1行ずつ読み込み，System.out.println(line)でコンソール出力しています． ファイルの終端に到達すると，readLine()はnullという値を返すため， while文でlineがnullになるまで，ファイルからの読み込みを繰り返しています．
 実は上記のコードだけではエラーが残ったままです． このエラーを取り除くには例外処理が必要です． 例外とはプログラムの実行中に発生する想定外の事態を意味しており， 例えば「対象のファイルが存在しない」「空っぽ（null）の変数を利用しようとした」などの状態が該当します． ファイル読込に利用するFileReaderとBufferedReaderはこの例外処理が必要なクラスです． 例外処理は下記のように，例外の発生の可能性のある命令をtry{}で囲み，例外発生時の命令をcatch(例外の種類){}に記述します．
try{ 実行する命令 }catch(例外の種類){ 例外発生時に実行する命令 } 下記のコードを参考に例外処理を施してmeasure.csvから文字列データを読み込んでみましょう． ここで，e.printStackTrace();は例外の原因を突き止めるために，例外に関する情報を遡って表示する命令です． また，IOExceptionは入出力に関する例外を意味しています． プログラムの実行後に，コンソールの出力結果を確認してください．
 CSV形式の処理 -- CSV形式の処理前述したようにCSV形式のファイルは「,（カンマ）」で区切られています． カンマで区切られた文字列（トークン）を取り出すにはStringTokenizerというクラスを利用します． 下記のコードを参考にトークン毎に取り出して，コンソールに出力してみましょう． ここで，new StringTokenizer(line, &amp;quot;,&amp;quot;)は， 変数lineに代入されている文字列を「,（カンマ）」で分割して取得することを表しています． また，身長と体重は整数のため，Integer.</description>
    </item>
    
    <item>
      <title>プログラミング</title>
      <link>https://mukai-lab.info/pages/classes/programming/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://mukai-lab.info/pages/classes/programming/</guid>
      <description> 科目名: プログラミング
講義室: 名古屋校舎教室
開講学期: 春学期
科目種別: 講義
テーマ: プログラムの基本的な構造の理解とコードの実装
概要 アプレット，組み込みプログラム，Webアプリケーションなどに広く利用されているプログラミング言語「Java」の基本を学習する．演算子や制御構文などプログラムの基本構造の修得から始め，ゲームなどの応用的なプログラムに発展させる．各回に出題される課題をこなしながら，目的に合わせたコードを実装する能力を養う．
内容／スケジュール  Javaの開発環境の確認 式と演算子 条件分岐 配列と繰り返し 乱数生成とキーボード入力 ファイル入出力 オブジェクト指向1 クラスとメソッド オブジェクト指向2 継承とインターフェイス JavaFX1 入力フィールドとボタン JavaFX2 レイアウトとグラフィックス JavaFX3 マウスとキーボード JavaFX4 アニメーション オリジナル作品の制作① 準備 オリジナル作品の制作② 実装 オリジナル作品の制作③ 発表  課題提出方法 Moodleから提出すること．
参考書籍</description>
    </item>
    
    <item>
      <title>プログラミング1</title>
      <link>https://mukai-lab.info/pages/classes/programming_1/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://mukai-lab.info/pages/classes/programming_1/</guid>
      <description> 授業科目区分: 専門教育科目
単位数: 2単位
開講学科: 文化情報学科/メディア情報学科
学年: 2年次
関連科目: プログラミング2，プログラミング応用
授業テーマ: ビジュアルデザインのためのプログラミング言語「Processing」の修得
授業内容 「Processing」は，キャセイ・レアスとベンジャミン・フライによって開発されたビジュアルデザインのためのプログラミング言語である．開発者は，コンピュータとの相互作用とのなかで，楽しくプログラミングすることを目的にこの言語を開発した．この授業では，図形を描くことから始め，アニメーション，拡張現実（AR）など，視覚的に楽しいプログラミングを体験すると共に，変数や配列などプログラミングには必須の知識を学ぶ．
授業計画  Processingの開発環境の確認 基本図形の描画 変数と繰り返し 条件分岐 アニメーションの表示 イベントの処理 画像処理 オブジェクト指向 ３Dグラフィックス カメラ映像の表示 OpenCVを利用した顔検出 ARToolkitを利用した拡張現実 オリジナル作品の制作① 準備 オリジナル作品の制作② 実装 オリジナル作品の制作③ 発表  課題提出方法 Glexaから提出すること．S*mapからログインすることも可能．
参考書籍</description>
    </item>
    
    <item>
      <title>プログラミング応用</title>
      <link>https://mukai-lab.info/pages/classes/applied_programming/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://mukai-lab.info/pages/classes/applied_programming/</guid>
      <description> 授業科目区分: 専門教育科目
単位数: 2単位
開講学科: 文化情報学科 学年: 3年次
関連科目: プログラミング1，プログラミング2
授業テーマ: オブジェクト指向言語「Java」の修得
授業内容 「Java」は，サン・マイクロシステムズが開発したオブジェクト指向のプログラミング言語である．Javaはプラットフォームに依存せず携帯電話から家電製品まで広く動作する特徴を備えている．安全性を保持するためのオブジェクト指向という概念を中心に学び，最後にはオリジナル作品を制作する．
授業計画  Javaの開発環境の確認 式と演算子 条件分岐 配列と繰り返し 乱数生成とキーボード入力 ファイル入出力 オブジェクト指向① クラスとメソッド オブジェクト指向② 継承とインターフェイス JavaFX1 入力フィールドとボタン JavaFX2 レイアウトとグラフィックス JavaFX3 マウスとキーボード JavaFX4 アニメーション オリジナル作品の制作① 準備 オリジナル作品の制作② 実装 オリジナル作品の制作③ 発表  課題提出方法 Glexaから提出すること．S*mapからログインすることも可能．
参考書籍</description>
    </item>
    
    <item>
      <title>マウスとキーボード</title>
      <link>https://mukai-lab.info/pages/classes/applied_programming/chapter11/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://mukai-lab.info/pages/classes/applied_programming/chapter11/</guid>
      <description>プロジェクトの準備 -- プロジェクトの準備Eclipseで新規にプロジェクトを作成しましょう． メニューから[ファイル]-[新規]-[Javaプロジェクト]をクリックして，「新規Javaプロジェクトの作成」を開きます． ここでは，プロジェクト名に”Project11”を入力ます． また，JREは&amp;rdquo;プロジェクト固有のJREを使用&amp;ldquo;を選択します． 最後に，[完了]をクリックしましょう． パッケージ・エクスプローラに作成したプロジェクトが表示されていることを確認してください．
 
Applicationクラスを継承したMyApplicationクラスを作成しましょう． メニューから[ファイル]-[新規]-[クラス]をクリックして，「新規Javaクラス」を開きます． まず，名前に”MyApplication”を入力します． 次にスーパークラスを設定するために，[参照]ボタンから「スーパークラスの選択」を開き， 一致する項目からjavafx.application.Applicationを選択して，[OK]をクリックします． 最後に[完了]をクリックしましょう．

Applicationクラスの抽象メソッドであるstartメソッドをオーバーライドしておきます． 下記コードを参考に，タイトルをProject 11，幅を500px，高さを500pxに設定しましょう． プログラムの実行後にウィンドウが表示されることを確認してください．
 
プログラム実行時の注意JavaFXはmainメソッドがなくともプログラムの実行が可能という特徴を持っています． しかし，Eclipseの現バージョンでは未対応のため，下記のコードをMyApplicationクラスに記述する必要があります． プログラム実行の前に，必ず下記のコードをソースコードに挿入してください．
 マウス・イベント -- マウス・イベント今回はマウス操作に応じてキャンバスに絵を描くことに挑戦していきましょう． 前準備として，下記のコードを参考にCanvasクラスをウィンドウに配置してください． レイアウトペインとしてVBoxクラスを利用しています． プログラムの実行後に表示されるウィンドウを確認してください．
 
キャンバス上でのマウスのクリックを検知するには， setOnMouseClicked()メソッドを利用します． このメソッドの引数にはラムダ式を利用して下記のように記述します． ラムダ式の左側の*event*はMouseEventクラスのインスタンスで， マウスの状態や位置などの情報を保持しています． 一方，ラムダ式の右側のpaint(event);はマウスがクリックされたときに呼び出されるメソッドです．
canvas.setOnMouseClicked(event -&amp;gt; paint(event)); 下記のコードを参考に，マウスがクリックされると，クリックされた位置に塗りつぶしの円を描いてみましょう（色はデフォルトの黒）． 円を描くコードはpaint(event)メソッドとして定義していることに注意してください． マウスの位置はMouseEventクラスのgetX()メソッドとgetY()メソッドで取得しています． プログラムの実行後に，キャンバスをクリックすると，円が描かれることに確認してください．
  
キーボード・イベント -- キーボード・イベントウィンドウ上でのマウスのクリックを検知するには，setOnKeyPressed()メソッドを利用します． このメソッドの引数にはラムダ式を利用して下記のように記述します． ラムダ式の左側の*event*はKeyEventクラスのインスタンスで， 押されたキーの状態や種類などの情報を保持しています． 一方，ラムダ式の右側のchange(event)はキーが押されたときに呼び出されるメソッドです．</description>
    </item>
    
    <item>
      <title>レイアウトとグラフィックス</title>
      <link>https://mukai-lab.info/pages/classes/applied_programming/chapter10/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://mukai-lab.info/pages/classes/applied_programming/chapter10/</guid>
      <description>プロジェクトの準備 -- プロジェクトの準備Eclipseで新規にプロジェクトを作成しましょう． メニューから[ファイル]-[新規]-[Javaプロジェクト]をクリックして，「新規Javaプロジェクトの作成」を開きます． ここでは，プロジェクト名に”Project10”を入力します． また，JREは&amp;rdquo;プロジェクト固有のJREを使用&amp;ldquo;を選択します． 最後に，[完了]をクリックしましょう． パッケージ・エクスプローラに作成したプロジェクトが表示されていることを確認してください．
 
Applicationクラスを継承したMyApplicationクラスを作成しましょう． メニューから[ファイル]-[新規]-[クラス]をクリックして，「新規Javaクラス」を開きます． まず，名前に”MyApplication”を入力します． 次にスーパークラスを設定するために，[参照]ボタンから「スーパークラスの選択」を開き， 一致する項目からjavafx.application.Applicationを選択して，[OK]をクリックします． 最後に[完了]をクリックしましょう．

Applicationクラスの抽象メソッドであるstartメソッドをオーバーライドしておきます． 下記コードを参考に，タイトルをProject 10，幅を500px，高さを500pxに設定しましょう． プログラムの実行後にウィンドウが表示されることを確認してください．
 
プログラム実行時の注意JavaFXはmainメソッドがなくともプログラムの実行が可能という特徴を持っています． しかし，Eclipseの現バージョンでは未対応のため，下記のコードをMyApplicationクラスに記述する必要があります． プログラム実行の前に，必ず下記のコードをソースコードに挿入してください．
 レイアウト -- レイアウトテキストフィールドやボタンなどのコントロールをレイアウトするにはレイアウトペインを利用します． 前回は垂直に並べるVBoxクラスを利用しましたが， 今回はアプリケーションのレイアウトに向いているBorderPaneクラスを利用してみましょう． BorderPaneクラスはウィンドウを中央，上，下，左，右に5分割してコントロールを配置します．
ここでは，ウィンドウの左右にボタン， そして，ウィンドウの中央にキャンバスを配置します． キャンバスを作成するには，下記のようにCanvasクラスをインスタンス化します（Canvasクラスの詳細は後述）． キャンバスの幅と高さを400pxに設定しています．
Canvas canvas = new Canvas(400, 400); 次に，下記のようにBorderPaneクラスをインスタンス化し，中央にコントロールを配置します． 中央，上，下，左，右に配置するにには，それぞれ，setCenter()メソッド，setTop()メソッド， setBottom()メソッド，SetLeft()メソッド，setRight()メソッドを利用します．
BorderPane pane = new BorderPane(); pane.setCenter(canvas); 下記のコードを参考に，ウィンドウの左右のボタン，ウィンドウの中央にキャンバスを配置してください． プログラムの実行後に表示されるウィンドウを確認してください．
 
これまでに紹介したVBox，BorderPane以外にも，水平に配置するHBox， 左から右に配置するFlowPane，行列に分割して配置するGridPaneなどのレイアウトペインがあります． 詳細はオラクルが提供するドキュメントを参考にしてください．
グラフィックス -- グラフィックスウィンドウに文字や図形などのグラフィックスを表示するにはCanvasクラスを利用します． キャンバスに何かを描くときは，getGraphicsContext2D()メソッドを利用してGraphicsContextクラスのインスタンスを取得します． GraphicsContextクラスには下記のようなメソッドが用意されています．</description>
    </item>
    
    <item>
      <title>ロボホンの開発環境の構築</title>
      <link>https://mukai-lab.info/pages/tech/robohon/robohon1/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://mukai-lab.info/pages/tech/robohon/robohon1/</guid>
      <description>ロボホンとはロボホン（RoBoHoN）はシャープ株式会社が開発する人型のロボットであり、音声UIを利用して自然言語で会話が出来ることを特徴としています。 ロボホンのOSはグーグル社が開発するAndroidであり、Android用のアプリ開発と同様にロボホンのアプリを制作することができます。 ロボホンの開発に必要なRoBoHoN Software Development Kitが公開されており、 ガイドラインに従って音声UIを利用したアプリを開発することが可能です。 ここで、ガイドラインとは、ロボホンの世界観を維持するための、ロボホンの キャラクター 、 話し方 、 ユーザとの関係性 のことを指しています。 今回は、ロボホンのアプリ開発に必要な環境の構築方法に関して解説します。
開発環境ロボホンアプリの開発には下記の環境が必要です。 ココロプランには、「ビジネス基本プラン」「ビジネスプラン2000」など数種類が設定されており、 プランに応じて月毎の会話上限が定められています。 アプリ開発で頻繁に音声UIを利用する場合は高額なプランも検討する必要があります。
 ロボホン本体（現状ではエミュレータは存在しない） ネットワーク環境（音声UIを利用するため） ココロプランの契約（本体購入時に同時契約）  開発プラットフォームとしては、Android Studioを利用します（ロボホンのOSはAndroid 5.0です）。 また、Android Studio のバージョンは 1.5 以降が必要とされており、今回は現時点での最新版である 2.3.3.0を採用します(2017年9月18日)。 ファイルサイズは約1.9GBと、かなり大きいので注意してください。

Android Studioのインストール・パッケージをダウンロードしたら、インストールを始めましょう。 インストールが完了したらロボホンのアプリ開発に必要なパッケージを追加でインストールします。 まずは、バージョン 1.5 の Android SDKです。 Settingsのメニューから[Appearance&amp;amp;Behavior]-[System Settings]-[Android SDK]を選択し、 Android 5.0 (Lollipop) にチェックを入れて Apply をクリックします。

同様にAndroid SDK Build-Toolsを追加します。 バージョンは21.0.0以降にチェックを入れて Apply をクリックします（Show Package Detailsをクリックするとバージョンの選択が可能です）。

開発したアプリをデバッグする際に、音声対話に失敗することを回避するために、 Instant Run の設定を無効化します。 Settingsのメニューから[Build, Execution, Developemnt]を選択し、全てのチェックをはずします。 これで、Android Studio の準備は完了です。</description>
    </item>
    
    <item>
      <title>ローカルストレージ</title>
      <link>https://mukai-lab.info/pages/classes/graduation_preperation_1/chapter5/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://mukai-lab.info/pages/classes/graduation_preperation_1/chapter5/</guid>
      <description>ローカルストレージとは -- ローカルストレージとは従来のウェブブラウザでは，データを保存する仕組みとして， クッキー(Cookie) と呼ばれる方法が主に利用されていました． しかし， クッキー は保存できるデータサイズが4キロバイトしかなく，ウェブページの更新毎に読込む必要がありました． そこで，HTML5では，クッキーに代わる新たな仕組みとして ウェブストレージ（Web Strage） が導入されました． ウェブストレージでは，5メガバイトのデータの保存が可能であり，クッキーのように自動で読込みが行われないため， より安全なデータの送受信が可能です． ウェブストレージ には下記の２種類があります．
 セッションストレージ（Session Storage） ローカルストレージ（Local Storage）  前者の セッションストレージ は，ブラウザのウィンドウ毎に，データが記録されるストレージであり，ウィンドウが閉じられると，そのデータは失われるという特徴があります． 後者の ローカルストレージ は，永続的にブラウザにデータが記録されるストレージであり，オリジン（ドメインとポートの組み合わせ）で区別されるという特徴があります． Monacaのアプリでは，このローカルストレージを利用することで，データを永続的に保存しておくことができます． つまり，ローカルストレージにデータを記録しておけば，アプリを終了してもデータが失われることがありません． そこで，今回はローカルストレージを利用した辞書アプリを作成してみましょう．
キー・バリュー・ストア型データベース（KVS） -- キー・バリュー・ストア型データベース企業等で利用されているデータベースの大部分は 関係データベース と呼ばれる仕組みを採用しています． 一方で，関係データベース はSNSなど膨大な情報を高速に処理するには不向きです． そこで，キー・バリュー・ストア型データベース に代表されるNoSQLと呼ばれる仕組みが部分的に利用されるようになってきました． ローカルストレージ も，この キー・バリュー・ストア型データベース と同じ構造を持ちます． その構造は極めてシンプルで，キー（Key） と バリュー（Value） の一対のペアでデータを記録するという方法です． 例えば，下記のように英単語を キー ，そして，その和訳を バリュー として記録しておければ， 英単語（キー） から， 和訳（バリュー） を検索することができます．
   Key Value     Apple りんご   Banana バナナ   Grapes ぶどう    プロジェクトの作成 -- プロジェクトの作成今回は，英単語 と 和訳 を登録するオリジナルの辞書アプリを作成しましょう． ダッシュボードから【新規プロジェクトの作成】-【Onsen UI】-【Onsen UI V2 JS Navigation】を選択します． プロジェクト名を 辞書アプリ ，説明を ローカルストレージを利用した辞書アプリ とします． プロジェクトを作成したら MonacaクラウドIDE の画面を開きましょう．</description>
    </item>
    
    <item>
      <title>主成分分析</title>
      <link>https://mukai-lab.info/pages/classes/advanced_studies_seminar_2/chapter13/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://mukai-lab.info/pages/classes/advanced_studies_seminar_2/chapter13/</guid>
      <description>主成分分析とは -- 主成分分析とは展開演習２の多変量解析と呼ばれる手法を取り上げます． その名が示すように複数の変数を対象に相関や共通性を見つけることが目的となります． 今回は，その中でも，複数の変数を合成して，次元（要素数）を圧縮する主成分分析に注目します． 主成分分析を完全に理解するには数学的な知識が必要となりますが，ここではR言語を利用して直観的に理解することを目指します． このような分析手法は，理解 も重要ですが，使える ことが最も重要です． 対象のデータとして，算数と理科の成績のデータ（CSV形式）を使用するので，事前にダウンロードしておきましょう．
 ファイルをダウンロードしたら，read.csv関数を利用して， 変数scoreにデータフレームとして読み込んでおきましょう．
score &amp;lt;- read.csv(&amp;#34;score2.csv&amp;#34;) スクリプトの作成 -- スクリプトの作成コードを入力し保存するためのスクリプトを作成しましょう． [ファイル]-[新しいスクリプト]をクリックし，Rエディタを表示します． 次に，[ファイル]-[保存]をクリックして，スクリプトを保存します． このとき，ファイル名はchapter13としてください． また，ファイルの保存場所と作業ディレクトリをデスクトップに変更しておきます．
合成変数 -- 合成変数主成分分析では，分散を最大化するような合成変数を求めることが目的となります． 合成変数f(X)は，算数の得点をx_1， 理科の得点をx_2とすると， 下記の式で与えられます．
f(X) = w_1 \times x_1 + w_2 \times x_2  それぞれの得点に，重みw_1，w_2を掛けただけの簡単な式です． それでは，この重みの意味を考えていましょう． まずは，w_1=1，w_2=0の場合はどうでしょうか．
x &amp;lt;- as.matrix(score[,2:3]) w1 &amp;lt;- matrix(c(1,0),nrow=2,ncol=1) &amp;gt; x %*% w1 [,1] [1,] 68 [2,] 78 [3,] 59 [4,] 65 [5,] 74 [6,] 29 [7,] 40 [8,] 71 [9,] 33 [10,] 53 [11,] 46 [12,] 27 [13,] 57 [14,] 48 [15,] 90 結果は算数の得点となります． これは理科の得点という情報を削って，新しい合成変数を生成したと考えることができます． これは，下記のように，本来は２次元のデータを，算数という１次元の軸に射影したとみなせます．</description>
    </item>
    
    <item>
      <title>乱数生成とキーボート入力</title>
      <link>https://mukai-lab.info/pages/classes/applied_programming/chapter5/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://mukai-lab.info/pages/classes/applied_programming/chapter5/</guid>
      <description>プロジェクトの準備 -- プロジェクトの準備Eclipseで新規にプロジェクトを作成しましょう． メニューから[ファイル]-[新規]-[Javaプロジェクト]をクリックして，「新規Javaプロジェクトの作成」を開きます． ここでは，プロジェクト名に”Project5”を入力して，[完了]をクリックしましょう． パッケージ・エクスプローラに作成したプロジェクトが表示されていることを確認してください．

続いてソースファイルを作成しましょう． メニューから[ファイル]-[新規]-[クラス]をクリックして，「新規Javaクラス」を開きます． ここでは，名前に”MyClass”を入力し，public static void main(String[] args)(V)にチェックを入れ，[完了]をクリックしましょう． パッケージ・エクスプローラに作成したソースファイルが表示されていることを確認してください．

乱数生成 -- 乱数生成サイコロの出た目のように規則性がなく予測不能な数値のことを乱数と呼びます． コンピュータではその性質から完全な乱数を生成することは出来ないため， 擬似乱数と呼ばれる乱数とほぼ同じ特徴を持った値を生成します． 0以上，かつ，n未満を条件とした整数の乱数を生成するには下記のように記述します． RandomはJavaのライブラリに含まれるクラスの1つですが詳細は省略します．
Random r = new Random(); int x = r.nextInt(n); 下記のコードを参考に，int型の変数xを宣言し，0～2までの乱数を代入してみましょう． プログラムの実行後に，コンソールの出力結果を確認してください． 実行毎に出力される値が変化することが分かります．
 乱数を利用しておみくじを作成してみましょう． 下記のコードを参考に，変数xの値に応じて，ランダムに”大吉”，”吉”，”凶”をコンソールに出力させてみましょう． プログラムの実行後に，コンソールの出力結果を確認してください．
 キーボード入力 -- キーボード入力ユーザから入力を受け取る方法の1つがキーボードです． キーボードから文字列を受け取るには下記のように記述します． ScannerはJavaのライブラリに含まれるクラスの1つですが詳細は省略します．
Scanner s = new Scanner(System.in); String text = s.nextLine(); s.close(); 下記のコードを参考に，変数nameにキーボードから入力した文字列を代入してみましょう． ここで，System.out.print()は，System.out.println()と同様に文字列をコンソールに出力する命令ですが，改行しないという点が異なります． また，コンソールへの出力の際には，文字列を連結するための演算子「+」を利用していることに注意が必要です．
 キーボードから整数を受け取るには下記のように記述します．</description>
    </item>
    
    <item>
      <title>卒業研究指導1</title>
      <link>https://mukai-lab.info/pages/classes/graduation_preperation_1/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://mukai-lab.info/pages/classes/graduation_preperation_1/</guid>
      <description> 授業科目区分: 専門教育科目 単位数: 2単位 開講学科: 文化情報学科 学年: 4年次 関連科目: 卒業研究指導2，卒業研究 授業テーマ: Monacaを利用したスマートフォンアプリの制作
授業内容 Monacaはクラウドで「HTML5ハイブリッドアプリ」を開発する環境の一つである． アプリの開発に必要な「コーディング」「デバッグ」「ビルド」などの一連の作業を ブラウザ（Chrome）で実行することが可能となっている 本授業では，Monacaを利用して，位置情報アプリやカメラアプリなどの 開発を経験しながら，オリジナル・アプリの制作を目指す． 事前に，Monacaのアカウントを作成し， 各自のスマートフォンにMonacaデバッガーをインストールしておくこと．
授業計画  Onsen UI① コンポーネント Onsen UI② テキスト入力 Onsen UI③ テーマローラー Onsen UI④ ジェスチャー操作 ローカルストレージ グラフの表示 地図の表示   課題提出方法 Glexaから提出すること．S*mapからログインすることも可能．
参考書籍</description>
    </item>
    
    <item>
      <title>因子分析</title>
      <link>https://mukai-lab.info/pages/classes/advanced_studies_seminar_2/chapter14/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://mukai-lab.info/pages/classes/advanced_studies_seminar_2/chapter14/</guid>
      <description>因子分析とは -- 因子分析とは因子分析は，主成分分析と同じ多変量解析の手法の一つです． 主成分分析は観測された変数を合成することが目的であるのに対し， 因子分析は観測された変数そのものが 潜在変数（因子） の合成であるとみなします． 下図は，主成分分析と因子分析の違いを表しています． 主成分は，全ての変数を合成することで求められます． 一方，因子は，独自因子 と 共通因子 に分かれており， 独自因子 は特定の変数に影響するのに対し，共通因子 は複数の変数に影響を与えます．

主成分分析は，次元を圧縮することで，データを可視化することに向いていますが，変数間の関係を分析することは苦手です． 一方，因子分析は得られた 因子 は変数間の関係を表しており，データの分析に適しています． しかし，因子分析は，主成分分析より数学的に難解であり，その仕組を完全に理解することは容易ではありません． 因子分析だけで本が一冊書けてしまう程であり，統計だけではなく，行列，ベクトルなどの知識が不可欠です． 今回も，理解 より 使える ことを重要視して，因子分析を学びましょう． 対象のデータとして，５教科の 成績のデータ（CSV形式）を使用するので，事前にダウンロードしておきましょう．
 ファイルをダウンロードしたら，read.csv関数を利用して， 変数scoreにデータフレームとして読み込んでおきましょう．
score &amp;lt;- read.csv(&amp;#34;score.csv&amp;#34;) スクリプトの作成 -- スクリプトの作成コードを入力し保存するためのスクリプトを作成しましょう． [ファイル]-[新しいスクリプト]をクリックし，Rエディタ を表示します． 次に，[ファイル]-[保存]をクリックして，スクリプトを保存します． このとき，ファイル名はchapter14としてください． また，ファイルの保存場所と作業ディレクトリをデスクトップに変更しておきます．
主成分得点と因子得点 -- 主成分得点と因子ここで，もう一度，主成分分析と因子分析の違いを整理しておきましょう． 主成分得点は下記の式で表すことができます． ここで，x_1，x_2は， 国語や算数の得点など 変数 を表しており， w_1，w_2は， それら変数の 重み であると共に，主成分を表すベクトルでした．
f(X) = w_1 \times x_1 + w_2 \times x_2  一方，因子分析は下記の式で表すことができます． ここで，f_1(X)，f_2(X)は因子得点と呼ばれます． この因子得点は，共通因子の影響を得点に換算した推定値であり，個体ごとに得点が決まります． また，w_1，w_2は，因子得点の重みであり，因子負荷量 と呼びます． 主成分を表すベクトルとは異なり，||w|| = 1という条件は満たしません（ベクトルの長さにも意味があります）． 注意すべきは，独自因子のeであり，これが主成分分析との大きな違いを生みます （e=0とすると主成分分析と同じアプローチになる）．</description>
    </item>
    
    <item>
      <title>地図の表示</title>
      <link>https://mukai-lab.info/pages/classes/graduation_preperation_1/chapter7/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://mukai-lab.info/pages/classes/graduation_preperation_1/chapter7/</guid>
      <description>地図の表示 -- 地図の表示今回は地図サービスとして有名なGoogle MapsのウェブAPIであるGoogle Maps Javascript APIを利用して地図アプリを制作してみましょう． 現在のAPIのバージョンは3.27であり，APIを利用するには，Googleアカウントにログインした状態で，Google API Consoleで認証情報を登録する必要があります（2017年1月7日時点）． まずは，Google API Consoleにアクセスし，ライブラリのリンクをクリックし， Google Maps JavaScript API を有効にします

次にAPIを利用するための認証情報である APIキー を作成します． 認証情報のリンクをクリックし，APIキー を選択します．

生成された APIキー をコピーしておきましょう． 後でウェブページに埋め込みます．
プロジェクトの作成 -- プロジェクトの作成今回も日進市のオープンデータミュージアムを利用して世帯数のデータを地図上に表示するアプリを作成しましょう． ダッシュボードから【新規プロジェクトの作成】-【Onsen UI】-【Onsen UI V2 JS Minimum】を選択します． プロジェクト名を 地図アプリ ，説明を Google Maps APIを利用した日進市の世帯数の地図 とします． プロジェクトを作成したら MonacaクラウドIDE の画面を開きましょう．

Google Maps APIを利用した地図の表示 -- Google Maps APIを利用した地図の表示それでは，Google Maps Javascript APIを利用して地図を表示させましょう． まずは地図を表示するための div要素 を作成します．</description>
    </item>
    
    <item>
      <title>基幹演習</title>
      <link>https://mukai-lab.info/pages/classes/seminar_fundamental_areas/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://mukai-lab.info/pages/classes/seminar_fundamental_areas/</guid>
      <description> 授業科目区分: 専門教育科目
単位数: 1単位
開講学科: 文化情報学科
学年: 2年次
授業テーマ: オープンデータを活用し，簡易な地図サービスを構築する
授業内容 自治体が提供しているオープンデータを基にデータの可視化や分析の方法を学習します． また，オープンストリートマップを活用し，簡易な地図サービスを構築します． これらは，シビックテック と呼ばれる活動の一環であり， これを機会に学外のアイデアソンやハッカソンのイベントに積極的に参加して欲しいです．
授業計画  Excelを利用した7市町オープンデータの分析① グラフ作成 Excelを利用した7市町オープンデータの分析② 相関分析 オープンストリートマップを利用したオープンデータの可視化① uMap オープンストリートマップを利用したオープンデータの可視化② Leaflet オリジナル地図の発表  課題提出方法 Glexaから提出すること． S*mapからログインすることも可能．
参考書籍</description>
    </item>
    
    <item>
      <title>基本図形の描画</title>
      <link>https://mukai-lab.info/pages/classes/programming_1/chapter2/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://mukai-lab.info/pages/classes/programming_1/chapter2/</guid>
      <description>スケッチの作成Processingを起動して、新規にスケッチを保存しましょう。 メニューから[ファイル]-[名前を付けて保存]をクリックして、「スケッチフォルダを名前を付けて保存」を開きます。 ファイル名に「Project2」を入力し、[保存]をクリックしましょう。 保存先に「Project2」という名前のフォルダが作成されていることを確認してください。

ウィンドウのサイズ図形はウィンドウ内のピクセルに描画します。 各ピクセルは座標で示され、Processingではウィンドウの左上が原点となります。 左端からの距離がX座標、上端からの距離がY座標を表します。 まずは、size()という命令文を用いて、ウィンドウのサイズを決めましょう。 ここでは、300×300ピクセルを指定します。 下記を参考にコードを入力したら、Runボタンをクリックしてください。 指定したサイズのウィンドウが表示されることを確認してください。
 
基本図形の描画Proceessingには基本的な図形を描く命令文が用意されています。 図形の描画など一連の処理をひとまとめにして、名前を付けたものを関数と呼びます（println()やsize()も関数です）。
点の描画 指定した座標に点を描くにはpoint()関数を利用します。 point()関数の括弧の内側には、点を描くX座標とY座標を指定します。 このように、関数の括弧の内側で指定する値のことを、引数と言います。 ここでは、X座標が50、Y座標が50の位置に点を描いてみましょう。 下記を参考にコードを入力したら、Runボタンをクリックしてください。 指定した位置に点が描かれていることを確認してください。
point(x,y);  
線の描画 ２つの座標を結ぶ線を描くにはline()関数を利用します。 引数には２つの座標を指定します。 ここでは、座標(50,100)から座標(50,200)に線を描いてみましょう。 下記を参考にコードを入力したら、Runボタンをクリックしてください。 指定した位置に線が描かれていることを確認してください。
line(x1, y1, x2, y2);  
長方形の描画 長方形を描くにはrect()関数を利用します。 引数には基準となる左上の座標と幅、高さを指定します。 ここでは、座標(100,50)を基準に、幅100、高さ100の長方形を描いてみましょう。 下記を参考にコードを入力したら、Runボタンをクリックしてください。 指定した位置に長方形が描かれていることを確認してください。
rect(x, y, width, height);  
円の描画 円を描くにはellipse()関数を利用します。 引数には基準となる中心の座標と幅、高さを指定します（幅、高さを同じ値にすると正円になる）。 ここでは、座標(150,200)を中心に、半径40の円を描いてみましょう。 下記を参考にコードを入力したら、Runボタンをクリックしてください。 指定した位置に円が描かれていることを確認してください。
ellipse(x, y, width, height);</description>
    </item>
    
    <item>
      <title>基礎演習</title>
      <link>https://mukai-lab.info/pages/classes/seminar_core_areas_learning/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://mukai-lab.info/pages/classes/seminar_core_areas_learning/</guid>
      <description> 授業科目区分: 専門教育科目
単位数: 1単位
開講学科: 文化情報学科
学年: 1年次
授業テーマ: 情報に関する基礎的な知識や技術の習得
授業内容 大学での専門的な学習を行うためのトレーニングを中心とする． マイクロソフトが開発している表計算ソフト「Microsoft Excel（マイクロソフト・エクセル）」を利用して， ２変数間の関係を表す「相関係数」や，統計の基本である「2項分布」などの確率分布を実習を通して学ぶ． 本授業の履修者は，数式や関数の入力などExcelの基本操作を修得しておくことが望ましい．
授業計画  Excelを利用した統計処理・相関係数 Excelを利用した統計処理・2項分布 Excelを利用した統計処理・正規分布  課題提出方法 Glexaから提出すること．S*mapからログインすることも可能．
参考書籍</description>
    </item>
    
    <item>
      <title>変数と繰り返し</title>
      <link>https://mukai-lab.info/pages/classes/programming_1/chapter3/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://mukai-lab.info/pages/classes/programming_1/chapter3/</guid>
      <description>スケッチの作成Processingを起動して、新規にスケッチを保存しましょう。 メニューから[ファイル]-[名前を付けて保存]をクリックして、「スケッチフォルダを名前を付けて保存」を開きます。 ファイル名に「Project3」を入力し、[保存]をクリックしましょう。 保存先に「Project3」という名前のフォルダが作成されていることを確認してください。

データ型Processingでは、「1」や「2」などの整数、「0.1」や「1.1」などの小数をデータとして扱うことができます。 これらデータの種類はデータ型で明確に区別されます。 例えば、整数はintというデータ型、小数はfloatというデータ型に該当します。 下記表に利用頻度の高いデータ型をまとめます。 取り敢えず表中のint、float、boolean、Stringだけはしっかりと覚えておきましょう（正確にはStringはクラスでありデータ型ではない）。
   データの種類 データ型 例     整数 int 1, 2, 3   小数 float 0.1, 1.1, 10.1   真理値 boolean true, false   文字列 String &amp;ldquo;ABC&amp;rdquo;, &amp;ldquo;あいう&amp;rdquo;    変数データを記憶しておくための箱が変数です。 変数を使用するには事前に変数宣言が必要です。 変数宣言はデータ型 変数名;と記述します。 データ型とはintやfloatのことを指しています。 変数名は「変数に付ける名前」のことで、自由に設定が可能ですが、 「小文字で始まるわかりやすい名前」を設定することが望ましいとされています。
変数にデータを記憶させるには、変数=代入するデータ;と記述します。 変数にデータを記憶させることを代入と呼ぶことに注意してください。 ここでは、int型の変数*x*と*y*を宣言し、ともに150を代入します。 この変数*x*と*y*を利用して、座標(x,y)の位置に半径*50*の円を描いてみましょう。 下記を参考にコードを入力したら、Runボタンをクリックしてください。 指定した半径の円が描かれていることを確認してください。</description>
    </item>
    
    <item>
      <title>対応のある2群のt検定</title>
      <link>https://mukai-lab.info/pages/classes/advanced_studies_seminar_2/chapter12/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://mukai-lab.info/pages/classes/advanced_studies_seminar_2/chapter12/</guid>
      <description>対応のある2群とは -- 対応のある2群とは前回は独立な2群（対応のない2群）の検定を考えました． 今回は，対応のある2群 の検定に注目します． 対応のある2群 とは，2つの標本に含まれる対象に，何らかの対応関係があることを意味しています． 例えば，下記のように，同じ4人の被験者に対して，2種類の条件下で測定された2群のデータは，「対応のある2群」です．
条件1: x_1 = \{a,b,c,d\} \\ 条件2: x_2 = \{a&#39;,b&#39;,c&#39;,d&#39;\}  「独立な2群の検定」には，新しい検定統計量が必要でしたが， 「対応のある2群の検定」では，2群のデータの「変化量」に着目することで， 標準的なt検定の検定統計量を適用することが可能です．
スクリプトの作成 -- スクリプトの作成コードを入力し保存するためのスクリプトを作成しましょう． [ファイル]-[新しいスクリプト]をクリックし，Rエディタを表示します． 次に，[ファイル]-[保存]をクリックして，スクリプトを保存します． このとき，ファイル名はchapter12としてください． また，ファイルの保存場所と作業ディレクトリをデスクトップに変更しておきます．
対応のある2群のt検定 -- 対応のある2群のt検定それでは，下記の問題について考えていきましょう．
向研究室の学生を対象に実施した情報数学に関するテストの得点はx_1であった． その後，向による熱心な指導を行い，再度，情報数学に関するテストを実施したところ， その得点はx_2となった． 指導の前後における得点の平均値に有意な差はあるか． （どちらも同じ母集団からランダムサンプリングした標本だろうか）． 指導前: x_1 = \{63,75,72,67,71\} \\ 指導後: x_2 = \{82,70,78,81,79\}   ここでは，指導の前後という対応関係があることから，得点の 変化量 に注目します． 変化量はD = X_2 - X_1で与えられます．
変化量の母集団: D = X_2 - X_1\\ 変化量の標本: d = x_2 - x_1 = \{19,-5,6,14,8\}  この変化量が，平均\hat{\mu}， 分散\hat{\sigma}^2の正規分布に従うと仮定します．</description>
    </item>
    
    <item>
      <title>展開演習2</title>
      <link>https://mukai-lab.info/pages/classes/advanced_studies_seminar_2/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://mukai-lab.info/pages/classes/advanced_studies_seminar_2/</guid>
      <description> 授業科目区分: 専門教育科目
単位数: 1単位
開講学科: 文化情報学科
学年: 3年次
関連科目: 統計の世界，データ解析入門
授業テーマ: R言語を利用したデータマイニング技術の修得
授業内容 オープンソースの統計解析ソフトウェアであるR言語を利用して，統計学の基礎から，機械学習などの応用まで幅広く学習する． 平均や分散などの基本統計量や，二項分布や正規分布などの基本的な確率分布を復習しておくこと． また，R言語は，SPSSのようなグラフィカル・ユーザ・インターフェースではなく， キーボードによるコマンド入力が必要となる． このため，本授業の履修者は，基本的なPCスキルを身に着けていることを前提とする．
授業計画  R言語の基本的な操作 R言語のデータ構造 R言語によるデータの視覚化 平均と分散 相関係数 2項分布 正規分布 母集団と標本 標準正規分布を用いた検定 t分布を用いた検定 独立な2群のt検定 対応のある2群のt検定 主成分分析 因子分析  課題提出方法 Glexaから提出すること．S*mapからログインすることも可能．
参考書籍</description>
    </item>
    
    <item>
      <title>平均と分散</title>
      <link>https://mukai-lab.info/pages/classes/advanced_studies_seminar_2/chapter4/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://mukai-lab.info/pages/classes/advanced_studies_seminar_2/chapter4/</guid>
      <description>基本統計量 -- 基本統計量統計量とは，観測したデータそのものではなく，それらのデータの特徴を代表的に表す値のことを表します． そのなかでも，基本統計量 は，平均，中央値，分散，標準偏差 などを指し， データの特徴を把握するための基本的な指標となります． 今回は，これら基本統計量を，公式や関数を利用して計算してみましょう． 対象のデータとして成績のデータ（CSV形式）を使用します． このデータは15人の生徒の国語，算数，理科，英語，社会の得点で構成されています．
 ファイルをダウンロードしたら，read.csv関数を利用して， 変数scoreにデータフレームとして読み込んでおきましょう（作業ディレクトリはデスクトップに変更）．
score &amp;lt;- read.csv(&amp;#34;score.csv&amp;#34;) 変数scoreの出力は下記のようになります．
&amp;gt; score 氏名 国語 算数 理科 英語 社会 1 青木 達也 60 68 72 39 71 2 石井 健二 65 78 82 37 75 3 北村 真子 84 59 85 87 84 4 河野 尚子 50 65 65 39 78 5 高木 健 72 74 83 30 83 6 西川 知里 50 29 67 62 72 7 福島 萌子 84 40 65 86 66 8 古川 翔太 78 71 82 34 88 9 山内 香菜 77 33 65 73 88 10 渡辺 太郎 76 53 75 60 71 11 浅野 渉 68 46 77 66 86 12 星野 弘 61 27 74 70 67 13 中谷 章 86 57 72 73 65 14 小泉 美沙 68 48 73 51 68 15 木下 萌子 78 90 100 53 79 スクリプトの作成 -- スクリプトの作成コードを入力し保存するためのスクリプトを作成しましょう． [ファイル]-[新しいスクリプト]をクリックし，Rエディタを表示します． 次に，[ファイル]-[保存]をクリックして，スクリプトを保存します． このとき，ファイル名はchapter4としてください． また，ファイルの保存場所と作業ディレクトリをデスクトップに変更しておきます．</description>
    </item>
    
    <item>
      <title>式と演算子</title>
      <link>https://mukai-lab.info/pages/classes/applied_programming/chapter2/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://mukai-lab.info/pages/classes/applied_programming/chapter2/</guid>
      <description>プロジェクトの準備 -- プロジェクトの準備Eclipseで新規にプロジェクトを作成しましょう． メニューから[ファイル]-[新規]-[Javaプロジェクト]をクリックして，「新規Javaプロジェクトの作成」を開きます． ここでは，プロジェクト名に”Project2”を入力して，[完了]をクリックしましょう． パッケージ・エクスプローラに作成したプロジェクトが表示されていることを確認してください．

続いてソースファイルを作成しましょう． メニューから[ファイル]-[新規]-[クラス]をクリックして，「新規Javaクラス」を開きます． ここでは，名前に”MyClass”を入力し，public static void main(String[] args)(V)にチェックを入れ，[完了]をクリックしましょう． パッケージ・エクスプローラに作成したソースファイルが表示されていることを確認してください．

リテラルとは -- リテラルとはJavaに限らず一般的なプログラム言語では，「1」や「2」などの 数値，「ABC」や「あいう」などの 文字列 をデータとして扱うことが可能です． ソースコードにおいて使用されるこれらの数値や文字列のデータを リテラル と呼びます． Javaでは，整数 や 小数 など，リテラルの種類を表す データ型 が存在します． 例えば，「1」や「2」などの整数は，int というデータ型に該当します． 下記表に利用頻度の高いデータ型をまとめるので確認してください．
   リテラルの種類 データ型 例     整数 int 1, 2, 3   小数 double 0.1, 1.1, 10.1   真理値 boolean true, false   文字列 String &amp;ldquo;ABC&amp;rdquo;, &amp;ldquo;あいう&amp;rdquo;    この他にも，64ビットの大きさの整数を表すlongや，32ビットの大きさの小数を表すfloatなどのデータ型がありますが， 取り敢えずは表中のint，double，boolean，Stringだけはしっかりと覚えておきましょう（正確にはStringはクラスでありデータ型ではない）． 文字列データを表記する際は，対象となる文字列を「&amp;ldquo;（ダブルクォート）」で囲む必要がありますので注意が必要です．</description>
    </item>
    
    <item>
      <title>条件分岐</title>
      <link>https://mukai-lab.info/pages/classes/applied_programming/chapter3/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://mukai-lab.info/pages/classes/applied_programming/chapter3/</guid>
      <description>プロジェクトの準備 -- プロジェクトの準備Eclipseで新規にプロジェクトを作成しましょう． メニューから[ファイル]-[新規]-[Javaプロジェクト]をクリックして，「新規Javaプロジェクトの作成」を開きます． ここでは，プロジェクト名に”Project3”を入力して，[完了]をクリックしましょう． パッケージ・エクスプローラに作成したプロジェクトが表示されていることを確認してください．

続いてソースファイルを作成しましょう． メニューから[ファイル]-[新規]-[クラス]をクリックして，「新規Javaクラス」を開きます． ここでは，名前に”MyClass”を入力し，public static void main(String[] args)(V)にチェックを入れ，[完了]をクリックしましょう． パッケージ・エクスプローラに作成したソースファイルが表示されていることを確認してください．

制御構文とは -- 制御構文とは制御構文とは実行する命令文の順序を変化させるための構文です． 一般的に命令文はソースコードの「上から順に１つずつ」実行されるのが基本です． この「上から順に１つずつ」実行する制御を順次と呼びます． この他，条件によって異なる命令文を実行する制御を条件分岐， 条件を満たすまで同じ命令文を繰り返す制御を繰り返しと呼びます． 今回はこの条件分岐に関して学習します． 条件分岐を理解するには，条件を表現するための条件式を学ぶ必要があります． 次章では，まず条件式に関して確認していきましょう．
条件式とは -- 条件式とは条件式とは，主に比較演算子や論理演算子を用いて表現され， 真（true）または偽（false）のどちらかの値を返す論理式のことです． この真（true）や偽（false）という値はboolean型となることに注意してください． 例えば，int型の変数xに代入されている値が数値3と一致するかどうかを条件式で表現するには，x == 3と表します． ここで，「==」は左辺と右辺が等しいかを判定する比較演算子です． 条件式で用いられる比較演算子を下記にまとめます．
   比較演算子 意味 例     A\=\=B AとBは等しい x\=\=3   A!=B AとBは等しくない x!=3   A&amp;gt;B AはBより大きい x&amp;gt;3   A&amp;gt;=B AはBと等しいか大きい x&amp;gt;=3   A&amp;lt;B AはBより小さい x&amp;lt;3   A&amp;lt;=B AはBと等しいか小さい A&amp;lt;=3    下記のコードを参考にint型の変数xを宣言して3を代入し， 上記の比較演算子の結果を確認してみましょう． プログラムの実行後に，コンソールの出力結果を確認してください．</description>
    </item>
    
    <item>
      <title>条件分岐</title>
      <link>https://mukai-lab.info/pages/classes/programming_1/chapter4/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://mukai-lab.info/pages/classes/programming_1/chapter4/</guid>
      <description>スケッチの作成Processingを起動して、新規にスケッチを保存しましょう。 メニューから[ファイル]-[名前を付けて保存]をクリックして、「スケッチフォルダを名前を付けて保存」を開きます。 ファイル名に「Project4」を入力し、[保存]をクリックしましょう。 保存先に「Project4」という名前のフォルダが作成されていることを確認してください。

乱数の生成規則性がないランダムな値のことを乱数と呼びます。 コンピュータは完全な乱数を生成することは出来ないため、 アルゴリズムに従って疑似的な乱数を生成します（疑似乱数と呼ばれます）。 コンピュータゲームにおける「トランプを配る」「サイコロを振る」などはこの疑似乱数を利用しています。 Processingで疑似乱数を先生するにはrandom()関数を利用します。 random()関数の引数には、生成する乱数の下限（low）と上限（high）を指定します。 また、生成された乱数はfloat型のデータとなることに注意が必要です。
random(low, high);
ここでは、for文を利用して、半径10の円を10箇所に描きましょう。 各円は、random()関数を利用して、ランダムな位置に配置します。 下記を参考にコードを入力したら、Runボタンをクリックしてください。 実行毎に配置が変わる円が描かれていることを確認してください。
 
比較演算子for文の繰り返し条件に記述されるi&amp;lt;10などは条件式と呼ばれます。 また、「&amp;lt;」は比較演算子と呼ばれ、左辺と右辺を比較した結果、 真（true）または偽（false）のどちらかを返す論理演算の一つです。 この真（true）や偽（false）はboolean型であることに注意してください。 例えば、変数*a*の値が5であるとき「a &amp;lt; 3」の結果はfalseとなります。 比較演算子を下記表にまとめます。
   比較演算子 意味 例     A\=\=B AとBは等しい x\=\=3   A!=B AとBは等しくない x!=3   A&amp;gt;B AはBより大きい x&amp;gt;3   A&amp;gt;=B AはBと等しいか大きい x&amp;gt;=3   A&amp;lt;B AはBより小さい x&amp;lt;3   A&amp;lt;=B AはBと等しいか小さい A&amp;lt;=3    if文条件式の結果に応じて実行する処理を分けることを条件分岐と呼びます。 条件分岐を表現するにはif文を利用します。 if文は下記のように記述し、「()」内で指定されている条件式が真（true）となるときに、「{}」内の命令文を実行します。</description>
    </item>
    
    <item>
      <title>標準正規分布を用いた検定</title>
      <link>https://mukai-lab.info/pages/classes/advanced_studies_seminar_2/chapter9/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://mukai-lab.info/pages/classes/advanced_studies_seminar_2/chapter9/</guid>
      <description>検定とは -- t検定とは検定とは「標本から推定された母数が，確率的に正しいかどうか」を判断することを意味します． 検定は，統計的仮説検定とも呼ばれ，推測統計でも利用頻度の高い重要なテクニックです． 検定を行うための手順は下記のようになります．
1．母数に関する帰無仮説と対立仮説を立てる．
2. 検定統計量を選択する．
3. 信頼区間（棄却域）を決める．
4. 標本から検定統計量を計算する．
5. 検定統計量が棄却域に含まれれば，帰無仮説を棄却して，対立仮説を採用する．棄却域に含まれなければ，帰無仮説を採択する．
難しい単語がたくさん出てきましたが，これは追々説明していきます． ここでは，母集団が正規分布であり，母平均，母分散が既知であるときに適用可能な標準正規分布を用いた検定を考えます． この，標準正規分布を用いた検定 は Z検定 とも呼ばれます．
スクリプトの作成 -- スクリプトの作成コードを入力し保存するためのスクリプトを作成しましょう． [ファイル]-[新しいスクリプト]をクリックし，Rエディタを表示します． 次に，[ファイル]-[保存]をクリックして，スクリプトを保存します． このとき，ファイル名はchapter9としてください． また，ファイルの保存場所と作業ディレクトリをデスクトップに変更しておきます．
検定の目的 -- 検定の目的まずは下記の具体例を考えていきましょう．
文化情報学部の学生Xに情報数学に関するテストを行ったところ， その得点の平均\hat{\mu}は60， 分散\hat{\sigma}^2は100であった． このうち，向研究室に所属する5人の学生xの得点は下記であった． 向研究室に所属する学生xは， 文化情報学部の学生Xと， 同様の傾向があるか（母集団からランダムサンプリングした学生だろうか）． x = \{63,75,72,67,71\}   母集団は「文化情報学部の学生X」， 標本は「向研究室に所属する学生x」と考えることができます． また，「標本平均の分布」をmとします． いずれも正規分布に従うと仮定すると，母集団の分布と，標本平均の分布は下記のようになります．
X \sim N(60,100)  m \sim N(60,100/5) = N(60,20)  ここで，標本の平均を求めてみましょう．
x &amp;lt;- c(63,75,72,67,71) &amp;gt; mean(x) [1] 69.</description>
    </item>
    
    <item>
      <title>正規分布</title>
      <link>https://mukai-lab.info/pages/classes/advanced_studies_seminar_2/chapter7/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://mukai-lab.info/pages/classes/advanced_studies_seminar_2/chapter7/</guid>
      <description>正規分布 -- 正規分布正規分布 は，ガウス分布 とも呼ばれ，平均値に近い値の頻度が高く， 平均値から離れるほど頻度が低くなるという特徴を持った確率分布のことです． 例えば，「身長」や「体重」などの分布が正規分布に従うことが知られており， その他にも様々な社会現象や自然現象に当てはまると考えられています． また，分布が数学的に扱いやすい性質を持っていることから， 統計分析によく用いられ，最も重要な 確率分布 と言っても間違いありません． 今回は，サンプルデータを基に正規分布のグラフを描く事から始め，正規分布を利用して特定の区間の生起確率を求める方法を学びます．
スクリプトの作成 -- スクリプトの作成コードを入力し保存するためのスクリプトを作成しましょう． [ファイル]-[新しいスクリプト]をクリックし，Rエディタを表示します． 次に，[ファイル]-[保存]をクリックして，スクリプトを保存します． このとき，ファイル名はchapter7としてください． また，ファイルの保存場所と作業ディレクトリをデスクトップに変更しておきます．
正規分布のグラフ -- 正規分布のグラフ気象庁が公開している 愛知県名古屋市の９月の最高気温のデータを対象に考えていきます． このデータは，1891年から2016年までの，愛知県名古屋市の9月の最高気温を表しています．
年,最高気温 1891,28.7 1892,28.1 1893,28.6 1894,28.4 1895,28.3 1896,27.7 1897,27.3 1898,28 1899,25.4 1900,28.9 ...,... 2016,29.3 ファイルをダウンロードしたら，read.csv 関数を利用して， 変数*temp*にデータフレームとして読み込んでおきましょう（作業ディレクトリはデスクトップに変更）．
temp &amp;lt;- read.csv(&amp;#34;temperature.csv&amp;#34;) 次に，hist関数を利用して，最高気温のヒストグラムを表示しましょう． 範囲は25から32までとし，区間は0.5とします． seq関数は，規則性のある数列ベクトルを生成する関数であり， ここでは，25から32まで，0.5ずつ増やした数列（{25.0,25.5,26.0,26.5,&amp;hellip;,32}）を生成します．
hist(temp[,2],breaks=seq(25,32,0.5)) 
グラフを確認すると， 区間28-8.5 が最頻値となっていることが分かります． また，この区間から離れるにつれて緩やかに頻度が減り， 全体としては左右対称な 釣鐘型 と呼ばれる分布をしています． しかし，このグラフは，縦軸が頻度を表すヒストグラムであり，確率分布ではありません． そこで，hist 関数の引数にfreq=FALSE を設定し，縦軸を 確率密度 に変更します．</description>
    </item>
    
    <item>
      <title>母集団と標本</title>
      <link>https://mukai-lab.info/pages/classes/advanced_studies_seminar_2/chapter8/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://mukai-lab.info/pages/classes/advanced_studies_seminar_2/chapter8/</guid>
      <description>母集団と標本 -- 母集団と標本統計の醍醐味の一つが「推測統計」です． 推測統計では，対象となるデータが大規模であるために，その一部を取り出したデータから推測するということを行います． このとき，対象となるデータ全体のことを母集団，取り出した一部のデータのことを標本といいます． 例えば，日本国民全体の平均身長を調べるためには，莫大な費用と時間がかかってしまいます． そこで，多少の正確さは犠牲にして，一部の国民を対象として調査し，全体を予測するということが現実的な方法です． ここでは，母集団が正規分布であると仮定して，母集団と標本の関係を明らかにしていきます． これからは，ある母集団（または標本）Xが， 平均\mu，分散\sigma^2に従うとき， 下記のように表記しますので注意してください． ここで，Nは，Normal Distribution（正規分布）の頭文字です．
X \sim N(\mu,\sigma^2)  スクリプトの作成 -- スクリプトの作成コードを入力し保存するためのスクリプトを作成しましょう． [ファイル]-[新しいスクリプト]をクリックし，Rエディタを表示します． 次に，[ファイル]-[保存]をクリックして，スクリプトを保存します． このとき，ファイル名はchapter8としてください． また，ファイルの保存場所と作業ディレクトリをデスクトップに変更しておきます．
母数の推定 -- 母数の推定母集団の特徴を表す基本統計量は母数と呼ばれます． 平均，分散などがその代表であり，母集団の平均を母平均\hat{\mu}， 母集団の分散を母分散 \hat{\sigma}^2と呼びます． また，母集団から抽出された標本の平均を標本平均 \mu， 標本の分散（不偏分散）を標本分散 \sigma^2と呼びます． テキストによっては，これらの定義が異なることもあるので注意してください．
それでは，母集団から抽出した標本を用いて，母数の値を推定してみましょう． このとき，推定する母数が「1つの値」となっている場合は，点推定 と呼びます． ここでは，平均\hat{\mu}=100， 分散\hat{\sigma}^2=100に従う母集団を考えます （標準偏差は\hat{\sigma}=10）．
X \sim N(100,100)  上記の正規分布に従った下記の10000の乱数を生成し，母集団Xとします． ファイル をダウンロードしたら，read.csv関数を利用して， 変数Xにデータフレームとして読み込んでおきましょう（作業ディレクトリはデスクトップに変更）．
89.74776 96.49404 98.46421 98.99935 93.35153 105.0311 123.9603 98.72574 105.1024 83.61765 ... ファイルを読み込んだら，母集団Xの平均と分散を求めてみましょう．</description>
    </item>
    
    <item>
      <title>独立な2群のt検定</title>
      <link>https://mukai-lab.info/pages/classes/advanced_studies_seminar_2/chapter11/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://mukai-lab.info/pages/classes/advanced_studies_seminar_2/chapter11/</guid>
      <description>平均値差の検定とは -- 平均値差の検定とはこれまでは，母集団Xと標本xの関係に注目して検定を行いました． これからは，２つの標本（標本x_1，標本x_2）の関係に注目し， それぞれの平均値の有意な差があるかどうかを検定します． ２つの標本を検定する場合，下記の条件によって適用する手法が異なります．
 独立な2群（対応のない2群） 対応のある2群  独立な2群（対応のない2群）とは，ある母集団から２つの標本を抽出したとき， それぞれの標本に含まれる対象が互いに無関係であることを意味しています． 例えば，下記のように，母集団Xから8人の被験者を抽出して， これをランダムに4人の2群に分けた場合は，「独立な2群」です．
x_1 = \{a,b,c,d\} \\ x_2 = \{e,f,g,h\}  一方，対応のある2群 とは，2つの標本に含まれる対象に，何らかの対応関係があることを意味しています． 例えば，下記のように，同じ4人の被験者に対して，2種類の条件下で測定された2群のデータは，「対応のある2群」です．
条件1: x_1 = \{a,b,c,d\} \\ 条件2: x_2 = \{a&#39;,b&#39;,c&#39;,d&#39;\}  今回は，前者の独立な2群（対応のない2群）のt検定を解説します．
スクリプトの作成 -- スクリプトの作成コードを入力し保存するためのスクリプトを作成しましょう． [ファイル]-[新しいスクリプト]をクリックし，Rエディタを表示します． 次に，[ファイル]-[保存]をクリックして，スクリプトを保存します． このとき，ファイル名はchapter11としてください． また，ファイルの保存場所と作業ディレクトリをデスクトップに変更しておきます．
t検定の前提条件 -- t検定の前提条件独立な2群の平均値差の検定にもt検定を利用します． ただし，t検定を適用するには，下記の条件を満たす必要があります．
 ランダムサンプリングにより標本が抽出されている 母集団の分布が正規分布である 母集団の分散が等質である  上記の条件1，2はこれまでの前提と同じですが，条件3が新しく追加されました． もし，条件3を満たさない場合は，t検定の代わりに，Welchの検定 を利用する必要があります． Welchの検定に関しては割愛します． ここでは，上記の全ての条件を満たしていると仮定して話を進めます．
独立な2群のt検定 -- 独立な2群のt検定それでは，下記の問題について考えていきましょう．</description>
    </item>
    
    <item>
      <title>画像処理</title>
      <link>https://mukai-lab.info/pages/classes/programming_1/chapter7/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://mukai-lab.info/pages/classes/programming_1/chapter7/</guid>
      <description>スケッチの作成Processingを起動して、新規にスケッチを保存しましょう。 メニューから[ファイル]-[名前を付けて保存]をクリックして、「スケッチフォルダを名前を付けて保存」を開きます。 ファイル名に「Project7」を入力し、[保存]をクリックしましょう。 保存先に「Project7」という名前のフォルダが作成されていることを確認してください。

画像の準備ProcessingはJPG形式やPNG形式などの画像ファイルを取り込んで表示することができます。 下記の三種類の画像（hana.jpg、night.jpg、umi.jpg）の内から一つを選び、画像をダウンロードしてください（画像提供：フリー写真素材 Futta.NET）。 いずれの画像もサイズは640&amp;times;480ピクセルです。 また、ダウンロードした画像は「スケッチフォルダ（Project7）」の中に配置しましょう。 これ以降、本資料ではhana.jpgを例に取り説明していきます。
画像の表示画像ファイルを読み込むには、PImageという型（本当はクラス）で変数を宣言し、 loadIMage()関数を利用して、変数に画像データを代入します。
PImage img; img = loadImage(ファイル名); また、ウィンドウに画像を表示するにはimage()関数を用います。 image()関数の引数には、PImage型の変数に加え、表示する位置(x,y)を指定します。 初期設定では、画像の表示位置は、画像の左上隅の座標が基準となることに注意してください。
image(img, x, y); 下記を参考にコードを入力したら、Runボタンをクリックしてくだい。 ウィンドウに指定した画像が表示されることを確認してください（ウィンドウのサイズは画像サイズと同じ640&amp;times;480ピクセルとします）。
 
画像をクリッピング（画像の一部を切り取ること）するには、copy()関数を利用します。 例えば、画像の左上の1/4の領域を切り取り、幅・高さを2倍にするには下記のように記述します。 (0,0)は元画像の左上隅の座標、(320,240)は切り取る領域の幅と高さを意味しており、これらの値で指定された領域が切り取られます。 また、2度目の(0,0)は切り取った画像を表示する位置、(640, 480)は切り取った画像の幅と高さ（この場合は拡大）を意味しています。

copy(img, 0, 0, 320, 240, 0, 0, 640, 480); 下記を参考にコードを入力したら、Runボタンをクリックしてくだい。 ウィンドウに切り取られた画像が拡大して表示されることを確認してください。
 
クリッピング機能を利用して虫眼鏡を実現してみましょう。 マウスをドラッグすると、マウス位置にある画像部分だけがズームして表示されます。 mouseDragged()関数では、image()関数で画像を表示した後に、 copy()関数を利用して100&amp;times;100ピクセルの領域を切り取り、 200&amp;times;200ピクセル（2倍）に拡大して表示しています。 また、mouseReleased()関数では、image()関数を実行し、元の画像を表示しています。 下記を参考にコードを入力したら、Runボタンをクリックしてくだい。 ドラッグすると画像が拡大して表示されることを確認してください。
 
配列と画像の色情報loadPixels()関数を実行することで、 画像データを構成する各ピクセルの色情報を取得することができます。 取得された色情報はpixels[]という名前の配列に記録されます。 配列は1つの名前で複数のデータを記録することが可能な特殊な変数と言えます。 例えば、pixels[0]、pixels[1]のように、配列名の後ろに[要素番号]を指定することで、 記録されている値を参照したり、新しい値を代入することができます（要素番号は0から始まることに注意してください）。 ここでは、640&amp;times;480ピクセルの画像を対象としているため、要素番号は0～307199(＝640&amp;times;480-1)となります。 また、配列の長さは配列名.</description>
    </item>
    
    <item>
      <title>相関係数</title>
      <link>https://mukai-lab.info/pages/classes/advanced_studies_seminar_2/chapter5/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://mukai-lab.info/pages/classes/advanced_studies_seminar_2/chapter5/</guid>
      <description>相関分析 -- 相関分析相関分析とは，2種類のデータの関係性を測るための方法を指します． 例えば，夏の熱い日には，アイスクリームがよく売れるとします． このとき，温度と，アイスクリームの売上には相関があると言えます． 今回は，このようなデータの相関を調べるに共分散と相関係数を学びましょう． 対象のデータは，前回と同じ成績のデータ（CSV形式）を使用します． このデータは15人の生徒の国語，算数，理科，英語，社会の得点で構成されています．
 ファイルをダウンロードしたら，read.csv関数を利用して， 変数scoreにデータフレームとして読み込んでおきましょう（作業ディレクトリはデスクトップに変更）．
score &amp;lt;- read.csv(&amp;#34;score.csv&amp;#34;) 変数scoreの出力は下記のようになります．
&amp;gt; score 氏名 国語 算数 理科 英語 社会 1 青木 達也 60 68 72 39 71 2 石井 健二 65 78 82 37 75 3 北村 真子 84 59 85 87 84 4 河野 尚子 50 65 65 39 78 5 高木 健 72 74 83 30 83 6 西川 知里 50 29 67 62 72 7 福島 萌子 84 40 65 86 66 8 古川 翔太 78 71 82 34 88 9 山内 香菜 77 33 65 73 88 10 渡辺 太郎 76 53 75 60 71 11 浅野 渉 68 46 77 66 86 12 星野 弘 61 27 74 70 67 13 中谷 章 86 57 72 73 65 14 小泉 美沙 68 48 73 51 68 15 木下 萌子 78 90 100 53 79 スクリプトの作成 -- スクリプトの作成コードを入力し保存するためのスクリプトを作成しましょう． [ファイル]-[新しいスクリプト]をクリックし，Rエディタを表示します． 次に，[ファイル]-[保存]をクリックして，スクリプトを保存します． このとき，ファイル名はchapter5としてください． また，ファイルの保存場所と作業ディレクトリをデスクトップに変更しておきます．</description>
    </item>
    
    <item>
      <title>脳波データをフーリエ解析</title>
      <link>https://mukai-lab.info/pages/tech/emotiv/emotiv3/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://mukai-lab.info/pages/tech/emotiv/emotiv3/</guid>
      <description>フーリエ変換とは前回までにCortexを利用してEmotiv Epoc+で計測したデータをPythonから取得する方法を説明しました． 一般に，脳波の生データから情報を読み取ることは困難であり，周波数成分に変換することが必要になります． この周波数成分の変換に必要な技術が鬼門のフーリエ変換（Fourier Transform: FT） です． 大学の工学部ではカリキュラムの１つとなっているフーリエ変換（フーリエ級数）に躓いた人も多いのではないでしょうか（何を隠そう向もその一人です）． ここでは，あまり深く考えず，フーリエ変換は 時間領域 から 周波数領域 に変換する仕組みだと理解しておけば十分です．
例を挙げて考えてみましょう． Emotivのサンプリングレートは 128Hz であることから，1秒間に 128個の信号が計測されることに注意してください． 仮に計測された脳波が，下記のグラフのような信号だったとします． この信号には，1秒間に 3周期分 のSin関数が含まれています． グラフの横軸が 時間 であることから，このデータは 時間領域 に存在しています．

これを，フーリエ変換（高速フーリエ変換）すると下記のグラフになります． このグラフの横軸は 周波数 であり，このデータは 周波数領域 に存在しています． 周波数 が 3 のところに，縦棒がありますよね． この結果は，先のグラフには 周期3 の信号が含まれていることを表しています．

フーリエ変換の凄いところは，異なる周期の信号が混ざっていても，それぞれの周波数成分の強さが取得できることです． 次に，下記のグラフの信号を考えます この信号には，1秒間に 5周期分 のSin関数が含まれています． また，その振幅は先の信号と比べて 1&amp;frasl;2 の大きさです．

この信号を，先の周期3の信号に加えます（本当に足し算するだけ）． すると，下図のようなグラフになります． これだけで，複雑なグラフになり，人間には理解できないレベルに到達します．

さぁ，フーリエ変換の出番です． 上の周期3と周期5のグラフを加えた信号を変換すると，下記のグラフになります． 周期3 の振幅は 1，また，周期5 の振幅が 0.5 となっていることが読み取れますね． フーリエ級数を発明したジョゼフ・フーリエは本当に天才だと思います（真面目）．

脳波データの記録それでは，前回までに実装したプログラムを利用して脳波データを取得しましょう． 準備として，数値計算ライブラリのNumpyと，描画ライブラリのmatplotlib.</description>
    </item>
    
  </channel>
</rss>